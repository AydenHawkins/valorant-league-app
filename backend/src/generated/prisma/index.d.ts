
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Map
 * 
 */
export type Map = $Result.DefaultSelection<Prisma.$MapPayload>
/**
 * Model League
 * 
 */
export type League = $Result.DefaultSelection<Prisma.$LeaguePayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Series
 * 
 */
export type Series = $Result.DefaultSelection<Prisma.$SeriesPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model MatchParticipation
 * 
 */
export type MatchParticipation = $Result.DefaultSelection<Prisma.$MatchParticipationPayload>
/**
 * Model MatchPlayerStats
 * 
 */
export type MatchPlayerStats = $Result.DefaultSelection<Prisma.$MatchPlayerStatsPayload>
/**
 * Model MatchTeamStats
 * 
 */
export type MatchTeamStats = $Result.DefaultSelection<Prisma.$MatchTeamStatsPayload>
/**
 * Model Round
 * 
 */
export type Round = $Result.DefaultSelection<Prisma.$RoundPayload>
/**
 * Model Plant
 * 
 */
export type Plant = $Result.DefaultSelection<Prisma.$PlantPayload>
/**
 * Model Defuse
 * 
 */
export type Defuse = $Result.DefaultSelection<Prisma.$DefusePayload>
/**
 * Model RoundPlayerStats
 * 
 */
export type RoundPlayerStats = $Result.DefaultSelection<Prisma.$RoundPlayerStatsPayload>
/**
 * Model RoundTeamStats
 * 
 */
export type RoundTeamStats = $Result.DefaultSelection<Prisma.$RoundTeamStatsPayload>
/**
 * Model Kill
 * 
 */
export type Kill = $Result.DefaultSelection<Prisma.$KillPayload>
/**
 * Model TeamRoster
 * 
 */
export type TeamRoster = $Result.DefaultSelection<Prisma.$TeamRosterPayload>
/**
 * Model Substitution
 * 
 */
export type Substitution = $Result.DefaultSelection<Prisma.$SubstitutionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.map`: Exposes CRUD operations for the **Map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maps
    * const maps = await prisma.map.findMany()
    * ```
    */
  get map(): Prisma.MapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.league`: Exposes CRUD operations for the **League** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leagues
    * const leagues = await prisma.league.findMany()
    * ```
    */
  get league(): Prisma.LeagueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **Series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Series
    * const series = await prisma.series.findMany()
    * ```
    */
  get series(): Prisma.SeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchParticipation`: Exposes CRUD operations for the **MatchParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchParticipations
    * const matchParticipations = await prisma.matchParticipation.findMany()
    * ```
    */
  get matchParticipation(): Prisma.MatchParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchPlayerStats`: Exposes CRUD operations for the **MatchPlayerStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchPlayerStats
    * const matchPlayerStats = await prisma.matchPlayerStats.findMany()
    * ```
    */
  get matchPlayerStats(): Prisma.MatchPlayerStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchTeamStats`: Exposes CRUD operations for the **MatchTeamStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchTeamStats
    * const matchTeamStats = await prisma.matchTeamStats.findMany()
    * ```
    */
  get matchTeamStats(): Prisma.MatchTeamStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.round`: Exposes CRUD operations for the **Round** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rounds
    * const rounds = await prisma.round.findMany()
    * ```
    */
  get round(): Prisma.RoundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plant`: Exposes CRUD operations for the **Plant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plants
    * const plants = await prisma.plant.findMany()
    * ```
    */
  get plant(): Prisma.PlantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defuse`: Exposes CRUD operations for the **Defuse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defuses
    * const defuses = await prisma.defuse.findMany()
    * ```
    */
  get defuse(): Prisma.DefuseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roundPlayerStats`: Exposes CRUD operations for the **RoundPlayerStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoundPlayerStats
    * const roundPlayerStats = await prisma.roundPlayerStats.findMany()
    * ```
    */
  get roundPlayerStats(): Prisma.RoundPlayerStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roundTeamStats`: Exposes CRUD operations for the **RoundTeamStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoundTeamStats
    * const roundTeamStats = await prisma.roundTeamStats.findMany()
    * ```
    */
  get roundTeamStats(): Prisma.RoundTeamStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kill`: Exposes CRUD operations for the **Kill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kills
    * const kills = await prisma.kill.findMany()
    * ```
    */
  get kill(): Prisma.KillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamRoster`: Exposes CRUD operations for the **TeamRoster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamRosters
    * const teamRosters = await prisma.teamRoster.findMany()
    * ```
    */
  get teamRoster(): Prisma.TeamRosterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.substitution`: Exposes CRUD operations for the **Substitution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Substitutions
    * const substitutions = await prisma.substitution.findMany()
    * ```
    */
  get substitution(): Prisma.SubstitutionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Agent: 'Agent',
    Map: 'Map',
    League: 'League',
    Season: 'Season',
    Team: 'Team',
    Player: 'Player',
    Series: 'Series',
    Match: 'Match',
    MatchParticipation: 'MatchParticipation',
    MatchPlayerStats: 'MatchPlayerStats',
    MatchTeamStats: 'MatchTeamStats',
    Round: 'Round',
    Plant: 'Plant',
    Defuse: 'Defuse',
    RoundPlayerStats: 'RoundPlayerStats',
    RoundTeamStats: 'RoundTeamStats',
    Kill: 'Kill',
    TeamRoster: 'TeamRoster',
    Substitution: 'Substitution'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "agent" | "map" | "league" | "season" | "team" | "player" | "series" | "match" | "matchParticipation" | "matchPlayerStats" | "matchTeamStats" | "round" | "plant" | "defuse" | "roundPlayerStats" | "roundTeamStats" | "kill" | "teamRoster" | "substitution"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Map: {
        payload: Prisma.$MapPayload<ExtArgs>
        fields: Prisma.MapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          findFirst: {
            args: Prisma.MapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          findMany: {
            args: Prisma.MapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          create: {
            args: Prisma.MapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          createMany: {
            args: Prisma.MapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          delete: {
            args: Prisma.MapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          update: {
            args: Prisma.MapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          deleteMany: {
            args: Prisma.MapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          upsert: {
            args: Prisma.MapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          aggregate: {
            args: Prisma.MapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMap>
          }
          groupBy: {
            args: Prisma.MapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapCountArgs<ExtArgs>
            result: $Utils.Optional<MapCountAggregateOutputType> | number
          }
        }
      }
      League: {
        payload: Prisma.$LeaguePayload<ExtArgs>
        fields: Prisma.LeagueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeagueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeagueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findFirst: {
            args: Prisma.LeagueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeagueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findMany: {
            args: Prisma.LeagueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          create: {
            args: Prisma.LeagueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          createMany: {
            args: Prisma.LeagueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeagueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          delete: {
            args: Prisma.LeagueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          update: {
            args: Prisma.LeagueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          deleteMany: {
            args: Prisma.LeagueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeagueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeagueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          upsert: {
            args: Prisma.LeagueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          aggregate: {
            args: Prisma.LeagueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeague>
          }
          groupBy: {
            args: Prisma.LeagueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeagueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeagueCountArgs<ExtArgs>
            result: $Utils.Optional<LeagueCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Series: {
        payload: Prisma.$SeriesPayload<ExtArgs>
        fields: Prisma.SeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findFirst: {
            args: Prisma.SeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findMany: {
            args: Prisma.SeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          create: {
            args: Prisma.SeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          createMany: {
            args: Prisma.SeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          delete: {
            args: Prisma.SeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          update: {
            args: Prisma.SeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          deleteMany: {
            args: Prisma.SeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          upsert: {
            args: Prisma.SeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeries>
          }
          groupBy: {
            args: Prisma.SeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      MatchParticipation: {
        payload: Prisma.$MatchParticipationPayload<ExtArgs>
        fields: Prisma.MatchParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>
          }
          findFirst: {
            args: Prisma.MatchParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>
          }
          findMany: {
            args: Prisma.MatchParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>[]
          }
          create: {
            args: Prisma.MatchParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>
          }
          createMany: {
            args: Prisma.MatchParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>[]
          }
          delete: {
            args: Prisma.MatchParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>
          }
          update: {
            args: Prisma.MatchParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>
          }
          deleteMany: {
            args: Prisma.MatchParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchParticipationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>[]
          }
          upsert: {
            args: Prisma.MatchParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipationPayload>
          }
          aggregate: {
            args: Prisma.MatchParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchParticipation>
          }
          groupBy: {
            args: Prisma.MatchParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<MatchParticipationCountAggregateOutputType> | number
          }
        }
      }
      MatchPlayerStats: {
        payload: Prisma.$MatchPlayerStatsPayload<ExtArgs>
        fields: Prisma.MatchPlayerStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchPlayerStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchPlayerStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>
          }
          findFirst: {
            args: Prisma.MatchPlayerStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchPlayerStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>
          }
          findMany: {
            args: Prisma.MatchPlayerStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>[]
          }
          create: {
            args: Prisma.MatchPlayerStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>
          }
          createMany: {
            args: Prisma.MatchPlayerStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchPlayerStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>[]
          }
          delete: {
            args: Prisma.MatchPlayerStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>
          }
          update: {
            args: Prisma.MatchPlayerStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>
          }
          deleteMany: {
            args: Prisma.MatchPlayerStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchPlayerStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchPlayerStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>[]
          }
          upsert: {
            args: Prisma.MatchPlayerStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPlayerStatsPayload>
          }
          aggregate: {
            args: Prisma.MatchPlayerStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchPlayerStats>
          }
          groupBy: {
            args: Prisma.MatchPlayerStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchPlayerStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchPlayerStatsCountArgs<ExtArgs>
            result: $Utils.Optional<MatchPlayerStatsCountAggregateOutputType> | number
          }
        }
      }
      MatchTeamStats: {
        payload: Prisma.$MatchTeamStatsPayload<ExtArgs>
        fields: Prisma.MatchTeamStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchTeamStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchTeamStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>
          }
          findFirst: {
            args: Prisma.MatchTeamStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchTeamStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>
          }
          findMany: {
            args: Prisma.MatchTeamStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>[]
          }
          create: {
            args: Prisma.MatchTeamStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>
          }
          createMany: {
            args: Prisma.MatchTeamStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchTeamStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>[]
          }
          delete: {
            args: Prisma.MatchTeamStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>
          }
          update: {
            args: Prisma.MatchTeamStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>
          }
          deleteMany: {
            args: Prisma.MatchTeamStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchTeamStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchTeamStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>[]
          }
          upsert: {
            args: Prisma.MatchTeamStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchTeamStatsPayload>
          }
          aggregate: {
            args: Prisma.MatchTeamStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchTeamStats>
          }
          groupBy: {
            args: Prisma.MatchTeamStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchTeamStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchTeamStatsCountArgs<ExtArgs>
            result: $Utils.Optional<MatchTeamStatsCountAggregateOutputType> | number
          }
        }
      }
      Round: {
        payload: Prisma.$RoundPayload<ExtArgs>
        fields: Prisma.RoundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          findFirst: {
            args: Prisma.RoundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          findMany: {
            args: Prisma.RoundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>[]
          }
          create: {
            args: Prisma.RoundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          createMany: {
            args: Prisma.RoundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>[]
          }
          delete: {
            args: Prisma.RoundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          update: {
            args: Prisma.RoundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          deleteMany: {
            args: Prisma.RoundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>[]
          }
          upsert: {
            args: Prisma.RoundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          aggregate: {
            args: Prisma.RoundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRound>
          }
          groupBy: {
            args: Prisma.RoundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoundCountArgs<ExtArgs>
            result: $Utils.Optional<RoundCountAggregateOutputType> | number
          }
        }
      }
      Plant: {
        payload: Prisma.$PlantPayload<ExtArgs>
        fields: Prisma.PlantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          findFirst: {
            args: Prisma.PlantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          findMany: {
            args: Prisma.PlantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          create: {
            args: Prisma.PlantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          createMany: {
            args: Prisma.PlantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          delete: {
            args: Prisma.PlantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          update: {
            args: Prisma.PlantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          deleteMany: {
            args: Prisma.PlantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          upsert: {
            args: Prisma.PlantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          aggregate: {
            args: Prisma.PlantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlant>
          }
          groupBy: {
            args: Prisma.PlantGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantCountArgs<ExtArgs>
            result: $Utils.Optional<PlantCountAggregateOutputType> | number
          }
        }
      }
      Defuse: {
        payload: Prisma.$DefusePayload<ExtArgs>
        fields: Prisma.DefuseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefuseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefuseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>
          }
          findFirst: {
            args: Prisma.DefuseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefuseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>
          }
          findMany: {
            args: Prisma.DefuseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>[]
          }
          create: {
            args: Prisma.DefuseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>
          }
          createMany: {
            args: Prisma.DefuseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefuseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>[]
          }
          delete: {
            args: Prisma.DefuseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>
          }
          update: {
            args: Prisma.DefuseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>
          }
          deleteMany: {
            args: Prisma.DefuseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefuseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DefuseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>[]
          }
          upsert: {
            args: Prisma.DefuseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefusePayload>
          }
          aggregate: {
            args: Prisma.DefuseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefuse>
          }
          groupBy: {
            args: Prisma.DefuseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefuseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefuseCountArgs<ExtArgs>
            result: $Utils.Optional<DefuseCountAggregateOutputType> | number
          }
        }
      }
      RoundPlayerStats: {
        payload: Prisma.$RoundPlayerStatsPayload<ExtArgs>
        fields: Prisma.RoundPlayerStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoundPlayerStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoundPlayerStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>
          }
          findFirst: {
            args: Prisma.RoundPlayerStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoundPlayerStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>
          }
          findMany: {
            args: Prisma.RoundPlayerStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>[]
          }
          create: {
            args: Prisma.RoundPlayerStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>
          }
          createMany: {
            args: Prisma.RoundPlayerStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoundPlayerStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>[]
          }
          delete: {
            args: Prisma.RoundPlayerStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>
          }
          update: {
            args: Prisma.RoundPlayerStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>
          }
          deleteMany: {
            args: Prisma.RoundPlayerStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoundPlayerStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoundPlayerStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>[]
          }
          upsert: {
            args: Prisma.RoundPlayerStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPlayerStatsPayload>
          }
          aggregate: {
            args: Prisma.RoundPlayerStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoundPlayerStats>
          }
          groupBy: {
            args: Prisma.RoundPlayerStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoundPlayerStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoundPlayerStatsCountArgs<ExtArgs>
            result: $Utils.Optional<RoundPlayerStatsCountAggregateOutputType> | number
          }
        }
      }
      RoundTeamStats: {
        payload: Prisma.$RoundTeamStatsPayload<ExtArgs>
        fields: Prisma.RoundTeamStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoundTeamStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoundTeamStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>
          }
          findFirst: {
            args: Prisma.RoundTeamStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoundTeamStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>
          }
          findMany: {
            args: Prisma.RoundTeamStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>[]
          }
          create: {
            args: Prisma.RoundTeamStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>
          }
          createMany: {
            args: Prisma.RoundTeamStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoundTeamStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>[]
          }
          delete: {
            args: Prisma.RoundTeamStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>
          }
          update: {
            args: Prisma.RoundTeamStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>
          }
          deleteMany: {
            args: Prisma.RoundTeamStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoundTeamStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoundTeamStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>[]
          }
          upsert: {
            args: Prisma.RoundTeamStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundTeamStatsPayload>
          }
          aggregate: {
            args: Prisma.RoundTeamStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoundTeamStats>
          }
          groupBy: {
            args: Prisma.RoundTeamStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoundTeamStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoundTeamStatsCountArgs<ExtArgs>
            result: $Utils.Optional<RoundTeamStatsCountAggregateOutputType> | number
          }
        }
      }
      Kill: {
        payload: Prisma.$KillPayload<ExtArgs>
        fields: Prisma.KillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>
          }
          findFirst: {
            args: Prisma.KillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>
          }
          findMany: {
            args: Prisma.KillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>[]
          }
          create: {
            args: Prisma.KillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>
          }
          createMany: {
            args: Prisma.KillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>[]
          }
          delete: {
            args: Prisma.KillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>
          }
          update: {
            args: Prisma.KillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>
          }
          deleteMany: {
            args: Prisma.KillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>[]
          }
          upsert: {
            args: Prisma.KillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KillPayload>
          }
          aggregate: {
            args: Prisma.KillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKill>
          }
          groupBy: {
            args: Prisma.KillGroupByArgs<ExtArgs>
            result: $Utils.Optional<KillGroupByOutputType>[]
          }
          count: {
            args: Prisma.KillCountArgs<ExtArgs>
            result: $Utils.Optional<KillCountAggregateOutputType> | number
          }
        }
      }
      TeamRoster: {
        payload: Prisma.$TeamRosterPayload<ExtArgs>
        fields: Prisma.TeamRosterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamRosterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamRosterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>
          }
          findFirst: {
            args: Prisma.TeamRosterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamRosterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>
          }
          findMany: {
            args: Prisma.TeamRosterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>[]
          }
          create: {
            args: Prisma.TeamRosterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>
          }
          createMany: {
            args: Prisma.TeamRosterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamRosterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>[]
          }
          delete: {
            args: Prisma.TeamRosterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>
          }
          update: {
            args: Prisma.TeamRosterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>
          }
          deleteMany: {
            args: Prisma.TeamRosterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamRosterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamRosterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>[]
          }
          upsert: {
            args: Prisma.TeamRosterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamRosterPayload>
          }
          aggregate: {
            args: Prisma.TeamRosterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamRoster>
          }
          groupBy: {
            args: Prisma.TeamRosterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamRosterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamRosterCountArgs<ExtArgs>
            result: $Utils.Optional<TeamRosterCountAggregateOutputType> | number
          }
        }
      }
      Substitution: {
        payload: Prisma.$SubstitutionPayload<ExtArgs>
        fields: Prisma.SubstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>
          }
          findFirst: {
            args: Prisma.SubstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>
          }
          findMany: {
            args: Prisma.SubstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>[]
          }
          create: {
            args: Prisma.SubstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>
          }
          createMany: {
            args: Prisma.SubstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubstitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>[]
          }
          delete: {
            args: Prisma.SubstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>
          }
          update: {
            args: Prisma.SubstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>
          }
          deleteMany: {
            args: Prisma.SubstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubstitutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>[]
          }
          upsert: {
            args: Prisma.SubstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubstitutionPayload>
          }
          aggregate: {
            args: Prisma.SubstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubstitution>
          }
          groupBy: {
            args: Prisma.SubstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<SubstitutionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    agent?: AgentOmit
    map?: MapOmit
    league?: LeagueOmit
    season?: SeasonOmit
    team?: TeamOmit
    player?: PlayerOmit
    series?: SeriesOmit
    match?: MatchOmit
    matchParticipation?: MatchParticipationOmit
    matchPlayerStats?: MatchPlayerStatsOmit
    matchTeamStats?: MatchTeamStatsOmit
    round?: RoundOmit
    plant?: PlantOmit
    defuse?: DefuseOmit
    roundPlayerStats?: RoundPlayerStatsOmit
    roundTeamStats?: RoundTeamStatsOmit
    kill?: KillOmit
    teamRoster?: TeamRosterOmit
    substitution?: SubstitutionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    matchParticipations: number
    matchPlayerStats: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchParticipations?: boolean | AgentCountOutputTypeCountMatchParticipationsArgs
    matchPlayerStats?: boolean | AgentCountOutputTypeCountMatchPlayerStatsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMatchParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipationWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMatchPlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchPlayerStatsWhereInput
  }


  /**
   * Count Type MapCountOutputType
   */

  export type MapCountOutputType = {
    matches: number
  }

  export type MapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matches?: boolean | MapCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapCountOutputType
     */
    select?: MapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }


  /**
   * Count Type LeagueCountOutputType
   */

  export type LeagueCountOutputType = {
    seasons: number
  }

  export type LeagueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | LeagueCountOutputTypeCountSeasonsArgs
  }

  // Custom InputTypes
  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueCountOutputType
     */
    select?: LeagueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
  }


  /**
   * Count Type SeasonCountOutputType
   */

  export type SeasonCountOutputType = {
    series: number
    teamRosters: number
  }

  export type SeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeasonCountOutputTypeCountSeriesArgs
    teamRosters?: boolean | SeasonCountOutputTypeCountTeamRostersArgs
  }

  // Custom InputTypes
  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountTeamRostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamRosterWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    rosters: number
    redSeries: number
    blueSeries: number
    teamStats: number
    substitutions: number
    roundStats: number
    matchParticipations: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rosters?: boolean | TeamCountOutputTypeCountRostersArgs
    redSeries?: boolean | TeamCountOutputTypeCountRedSeriesArgs
    blueSeries?: boolean | TeamCountOutputTypeCountBlueSeriesArgs
    teamStats?: boolean | TeamCountOutputTypeCountTeamStatsArgs
    substitutions?: boolean | TeamCountOutputTypeCountSubstitutionsArgs
    roundStats?: boolean | TeamCountOutputTypeCountRoundStatsArgs
    matchParticipations?: boolean | TeamCountOutputTypeCountMatchParticipationsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamRosterWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRedSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountBlueSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchTeamStatsWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSubstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubstitutionWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRoundStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundTeamStatsWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMatchParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipationWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    rosters: number
    subIns: number
    subOuts: number
    plants: number
    defuses: number
    roundStats: number
    matchStats: number
    kills: number
    deaths: number
    killAssists: number
    matchParticipations: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rosters?: boolean | PlayerCountOutputTypeCountRostersArgs
    subIns?: boolean | PlayerCountOutputTypeCountSubInsArgs
    subOuts?: boolean | PlayerCountOutputTypeCountSubOutsArgs
    plants?: boolean | PlayerCountOutputTypeCountPlantsArgs
    defuses?: boolean | PlayerCountOutputTypeCountDefusesArgs
    roundStats?: boolean | PlayerCountOutputTypeCountRoundStatsArgs
    matchStats?: boolean | PlayerCountOutputTypeCountMatchStatsArgs
    kills?: boolean | PlayerCountOutputTypeCountKillsArgs
    deaths?: boolean | PlayerCountOutputTypeCountDeathsArgs
    killAssists?: boolean | PlayerCountOutputTypeCountKillAssistsArgs
    matchParticipations?: boolean | PlayerCountOutputTypeCountMatchParticipationsArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountRostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamRosterWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSubInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubstitutionWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSubOutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubstitutionWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountDefusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefuseWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountRoundStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundPlayerStatsWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMatchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchPlayerStatsWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountKillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KillWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountDeathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KillWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountKillAssistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KillWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMatchParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipationWhereInput
  }


  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    matches: number
  }

  export type SeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matches?: boolean | SeriesCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }


  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    rounds: number
    matchPlayerStats: number
    matchTeamStats: number
    substitutions: number
    kills: number
    participations: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rounds?: boolean | MatchCountOutputTypeCountRoundsArgs
    matchPlayerStats?: boolean | MatchCountOutputTypeCountMatchPlayerStatsArgs
    matchTeamStats?: boolean | MatchCountOutputTypeCountMatchTeamStatsArgs
    substitutions?: boolean | MatchCountOutputTypeCountSubstitutionsArgs
    kills?: boolean | MatchCountOutputTypeCountKillsArgs
    participations?: boolean | MatchCountOutputTypeCountParticipationsArgs
  }

  // Custom InputTypes
  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountRoundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountMatchPlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchPlayerStatsWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountMatchTeamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchTeamStatsWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountSubstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubstitutionWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountKillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KillWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipationWhereInput
  }


  /**
   * Count Type MatchParticipationCountOutputType
   */

  export type MatchParticipationCountOutputType = {
    roundStats: number
  }

  export type MatchParticipationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roundStats?: boolean | MatchParticipationCountOutputTypeCountRoundStatsArgs
  }

  // Custom InputTypes
  /**
   * MatchParticipationCountOutputType without action
   */
  export type MatchParticipationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipationCountOutputType
     */
    select?: MatchParticipationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchParticipationCountOutputType without action
   */
  export type MatchParticipationCountOutputTypeCountRoundStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundPlayerStatsWhereInput
  }


  /**
   * Count Type RoundCountOutputType
   */

  export type RoundCountOutputType = {
    playerStats: number
    teamStats: number
  }

  export type RoundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerStats?: boolean | RoundCountOutputTypeCountPlayerStatsArgs
    teamStats?: boolean | RoundCountOutputTypeCountTeamStatsArgs
  }

  // Custom InputTypes
  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundCountOutputType
     */
    select?: RoundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeCountPlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundPlayerStatsWhereInput
  }

  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeCountTeamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundTeamStatsWhereInput
  }


  /**
   * Count Type KillCountOutputType
   */

  export type KillCountOutputType = {
    assistants: number
  }

  export type KillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | KillCountOutputTypeCountAssistantsArgs
  }

  // Custom InputTypes
  /**
   * KillCountOutputType without action
   */
  export type KillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KillCountOutputType
     */
    select?: KillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KillCountOutputType without action
   */
  export type KillCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    name: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchParticipations?: boolean | Agent$matchParticipationsArgs<ExtArgs>
    matchPlayerStats?: boolean | Agent$matchPlayerStatsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchParticipations?: boolean | Agent$matchParticipationsArgs<ExtArgs>
    matchPlayerStats?: boolean | Agent$matchPlayerStatsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      matchParticipations: Prisma.$MatchParticipationPayload<ExtArgs>[]
      matchPlayerStats: Prisma.$MatchPlayerStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    matchParticipations<T extends Agent$matchParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$matchParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchPlayerStats<T extends Agent$matchPlayerStatsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$matchPlayerStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly role: FieldRef<"Agent", 'String'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.matchParticipations
   */
  export type Agent$matchParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    where?: MatchParticipationWhereInput
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    cursor?: MatchParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * Agent.matchPlayerStats
   */
  export type Agent$matchPlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    where?: MatchPlayerStatsWhereInput
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    cursor?: MatchPlayerStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchPlayerStatsScalarFieldEnum | MatchPlayerStatsScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Map
   */

  export type AggregateMap = {
    _count: MapCountAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  export type MapMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MapMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Map to aggregate.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maps
    **/
    _count?: true | MapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapMaxAggregateInputType
  }

  export type GetMapAggregateType<T extends MapAggregateArgs> = {
        [P in keyof T & keyof AggregateMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMap[P]>
      : GetScalarType<T[P], AggregateMap[P]>
  }




  export type MapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
    orderBy?: MapOrderByWithAggregationInput | MapOrderByWithAggregationInput[]
    by: MapScalarFieldEnum[] | MapScalarFieldEnum
    having?: MapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCountAggregateInputType | true
    _min?: MapMinAggregateInputType
    _max?: MapMaxAggregateInputType
  }

  export type MapGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: MapCountAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  type GetMapGroupByPayload<T extends MapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapGroupByOutputType[P]>
            : GetScalarType<T[P], MapGroupByOutputType[P]>
        }
      >
    >


  export type MapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matches?: boolean | Map$matchesArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["map"]>

  export type MapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["map"]>

  export type MapSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["map"]>
  export type MapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matches?: boolean | Map$matchesArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Map"
    objects: {
      matches: Prisma.$MatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["map"]>
    composites: {}
  }

  type MapGetPayload<S extends boolean | null | undefined | MapDefaultArgs> = $Result.GetResult<Prisma.$MapPayload, S>

  type MapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapCountAggregateInputType | true
    }

  export interface MapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Map'], meta: { name: 'Map' } }
    /**
     * Find zero or one Map that matches the filter.
     * @param {MapFindUniqueArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapFindUniqueArgs>(args: SelectSubset<T, MapFindUniqueArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapFindUniqueOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapFindUniqueOrThrowArgs>(args: SelectSubset<T, MapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindFirstArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapFindFirstArgs>(args?: SelectSubset<T, MapFindFirstArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindFirstOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapFindFirstOrThrowArgs>(args?: SelectSubset<T, MapFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maps
     * const maps = await prisma.map.findMany()
     * 
     * // Get first 10 Maps
     * const maps = await prisma.map.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapWithIdOnly = await prisma.map.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapFindManyArgs>(args?: SelectSubset<T, MapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Map.
     * @param {MapCreateArgs} args - Arguments to create a Map.
     * @example
     * // Create one Map
     * const Map = await prisma.map.create({
     *   data: {
     *     // ... data to create a Map
     *   }
     * })
     * 
     */
    create<T extends MapCreateArgs>(args: SelectSubset<T, MapCreateArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maps.
     * @param {MapCreateManyArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapCreateManyArgs>(args?: SelectSubset<T, MapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maps and returns the data saved in the database.
     * @param {MapCreateManyAndReturnArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapCreateManyAndReturnArgs>(args?: SelectSubset<T, MapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Map.
     * @param {MapDeleteArgs} args - Arguments to delete one Map.
     * @example
     * // Delete one Map
     * const Map = await prisma.map.delete({
     *   where: {
     *     // ... filter to delete one Map
     *   }
     * })
     * 
     */
    delete<T extends MapDeleteArgs>(args: SelectSubset<T, MapDeleteArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Map.
     * @param {MapUpdateArgs} args - Arguments to update one Map.
     * @example
     * // Update one Map
     * const map = await prisma.map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapUpdateArgs>(args: SelectSubset<T, MapUpdateArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maps.
     * @param {MapDeleteManyArgs} args - Arguments to filter Maps to delete.
     * @example
     * // Delete a few Maps
     * const { count } = await prisma.map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapDeleteManyArgs>(args?: SelectSubset<T, MapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapUpdateManyArgs>(args: SelectSubset<T, MapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps and returns the data updated in the database.
     * @param {MapUpdateManyAndReturnArgs} args - Arguments to update many Maps.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapUpdateManyAndReturnArgs>(args: SelectSubset<T, MapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Map.
     * @param {MapUpsertArgs} args - Arguments to update or create a Map.
     * @example
     * // Update or create a Map
     * const map = await prisma.map.upsert({
     *   create: {
     *     // ... data to create a Map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Map we want to update
     *   }
     * })
     */
    upsert<T extends MapUpsertArgs>(args: SelectSubset<T, MapUpsertArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCountArgs} args - Arguments to filter Maps to count.
     * @example
     * // Count the number of Maps
     * const count = await prisma.map.count({
     *   where: {
     *     // ... the filter for the Maps we want to count
     *   }
     * })
    **/
    count<T extends MapCountArgs>(
      args?: Subset<T, MapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapAggregateArgs>(args: Subset<T, MapAggregateArgs>): Prisma.PrismaPromise<GetMapAggregateType<T>>

    /**
     * Group by Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapGroupByArgs['orderBy'] }
        : { orderBy?: MapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Map model
   */
  readonly fields: MapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    matches<T extends Map$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Map$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Map model
   */
  interface MapFieldRefs {
    readonly id: FieldRef<"Map", 'String'>
    readonly name: FieldRef<"Map", 'String'>
    readonly createdAt: FieldRef<"Map", 'DateTime'>
    readonly updatedAt: FieldRef<"Map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Map findUnique
   */
  export type MapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map findUniqueOrThrow
   */
  export type MapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map findFirst
   */
  export type MapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map findFirstOrThrow
   */
  export type MapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map findMany
   */
  export type MapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map create
   */
  export type MapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The data needed to create a Map.
     */
    data: XOR<MapCreateInput, MapUncheckedCreateInput>
  }

  /**
   * Map createMany
   */
  export type MapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maps.
     */
    data: MapCreateManyInput | MapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Map createManyAndReturn
   */
  export type MapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * The data used to create many Maps.
     */
    data: MapCreateManyInput | MapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Map update
   */
  export type MapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The data needed to update a Map.
     */
    data: XOR<MapUpdateInput, MapUncheckedUpdateInput>
    /**
     * Choose, which Map to update.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map updateMany
   */
  export type MapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maps.
     */
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
  }

  /**
   * Map updateManyAndReturn
   */
  export type MapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * The data used to update Maps.
     */
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
  }

  /**
   * Map upsert
   */
  export type MapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The filter to search for the Map to update in case it exists.
     */
    where: MapWhereUniqueInput
    /**
     * In case the Map found by the `where` argument doesn't exist, create a new Map with this data.
     */
    create: XOR<MapCreateInput, MapUncheckedCreateInput>
    /**
     * In case the Map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapUpdateInput, MapUncheckedUpdateInput>
  }

  /**
   * Map delete
   */
  export type MapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter which Map to delete.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map deleteMany
   */
  export type MapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maps to delete
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to delete.
     */
    limit?: number
  }

  /**
   * Map.matches
   */
  export type Map$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Map without action
   */
  export type MapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
  }


  /**
   * Model League
   */

  export type AggregateLeague = {
    _count: LeagueCountAggregateOutputType | null
    _avg: LeagueAvgAggregateOutputType | null
    _sum: LeagueSumAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  export type LeagueAvgAggregateOutputType = {
    id: number | null
  }

  export type LeagueSumAggregateOutputType = {
    id: number | null
  }

  export type LeagueMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeagueAvgAggregateInputType = {
    id?: true
  }

  export type LeagueSumAggregateInputType = {
    id?: true
  }

  export type LeagueMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeagueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which League to aggregate.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leagues
    **/
    _count?: true | LeagueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeagueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeagueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeagueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeagueMaxAggregateInputType
  }

  export type GetLeagueAggregateType<T extends LeagueAggregateArgs> = {
        [P in keyof T & keyof AggregateLeague]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeague[P]>
      : GetScalarType<T[P], AggregateLeague[P]>
  }




  export type LeagueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithAggregationInput | LeagueOrderByWithAggregationInput[]
    by: LeagueScalarFieldEnum[] | LeagueScalarFieldEnum
    having?: LeagueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeagueCountAggregateInputType | true
    _avg?: LeagueAvgAggregateInputType
    _sum?: LeagueSumAggregateInputType
    _min?: LeagueMinAggregateInputType
    _max?: LeagueMaxAggregateInputType
  }

  export type LeagueGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LeagueCountAggregateOutputType | null
    _avg: LeagueAvgAggregateOutputType | null
    _sum: LeagueSumAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  type GetLeagueGroupByPayload<T extends LeagueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeagueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeagueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeagueGroupByOutputType[P]>
            : GetScalarType<T[P], LeagueGroupByOutputType[P]>
        }
      >
    >


  export type LeagueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasons?: boolean | League$seasonsArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeagueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["league"]>
  export type LeagueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | League$seasonsArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LeagueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LeaguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "League"
    objects: {
      seasons: Prisma.$SeasonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["league"]>
    composites: {}
  }

  type LeagueGetPayload<S extends boolean | null | undefined | LeagueDefaultArgs> = $Result.GetResult<Prisma.$LeaguePayload, S>

  type LeagueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeagueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeagueCountAggregateInputType | true
    }

  export interface LeagueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['League'], meta: { name: 'League' } }
    /**
     * Find zero or one League that matches the filter.
     * @param {LeagueFindUniqueArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeagueFindUniqueArgs>(args: SelectSubset<T, LeagueFindUniqueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one League that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeagueFindUniqueOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeagueFindUniqueOrThrowArgs>(args: SelectSubset<T, LeagueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeagueFindFirstArgs>(args?: SelectSubset<T, LeagueFindFirstArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeagueFindFirstOrThrowArgs>(args?: SelectSubset<T, LeagueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leagues
     * const leagues = await prisma.league.findMany()
     * 
     * // Get first 10 Leagues
     * const leagues = await prisma.league.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leagueWithIdOnly = await prisma.league.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeagueFindManyArgs>(args?: SelectSubset<T, LeagueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a League.
     * @param {LeagueCreateArgs} args - Arguments to create a League.
     * @example
     * // Create one League
     * const League = await prisma.league.create({
     *   data: {
     *     // ... data to create a League
     *   }
     * })
     * 
     */
    create<T extends LeagueCreateArgs>(args: SelectSubset<T, LeagueCreateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leagues.
     * @param {LeagueCreateManyArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeagueCreateManyArgs>(args?: SelectSubset<T, LeagueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leagues and returns the data saved in the database.
     * @param {LeagueCreateManyAndReturnArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeagueCreateManyAndReturnArgs>(args?: SelectSubset<T, LeagueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a League.
     * @param {LeagueDeleteArgs} args - Arguments to delete one League.
     * @example
     * // Delete one League
     * const League = await prisma.league.delete({
     *   where: {
     *     // ... filter to delete one League
     *   }
     * })
     * 
     */
    delete<T extends LeagueDeleteArgs>(args: SelectSubset<T, LeagueDeleteArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one League.
     * @param {LeagueUpdateArgs} args - Arguments to update one League.
     * @example
     * // Update one League
     * const league = await prisma.league.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeagueUpdateArgs>(args: SelectSubset<T, LeagueUpdateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leagues.
     * @param {LeagueDeleteManyArgs} args - Arguments to filter Leagues to delete.
     * @example
     * // Delete a few Leagues
     * const { count } = await prisma.league.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeagueDeleteManyArgs>(args?: SelectSubset<T, LeagueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeagueUpdateManyArgs>(args: SelectSubset<T, LeagueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues and returns the data updated in the database.
     * @param {LeagueUpdateManyAndReturnArgs} args - Arguments to update many Leagues.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeagueUpdateManyAndReturnArgs>(args: SelectSubset<T, LeagueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one League.
     * @param {LeagueUpsertArgs} args - Arguments to update or create a League.
     * @example
     * // Update or create a League
     * const league = await prisma.league.upsert({
     *   create: {
     *     // ... data to create a League
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the League we want to update
     *   }
     * })
     */
    upsert<T extends LeagueUpsertArgs>(args: SelectSubset<T, LeagueUpsertArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueCountArgs} args - Arguments to filter Leagues to count.
     * @example
     * // Count the number of Leagues
     * const count = await prisma.league.count({
     *   where: {
     *     // ... the filter for the Leagues we want to count
     *   }
     * })
    **/
    count<T extends LeagueCountArgs>(
      args?: Subset<T, LeagueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeagueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeagueAggregateArgs>(args: Subset<T, LeagueAggregateArgs>): Prisma.PrismaPromise<GetLeagueAggregateType<T>>

    /**
     * Group by League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeagueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeagueGroupByArgs['orderBy'] }
        : { orderBy?: LeagueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeagueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeagueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the League model
   */
  readonly fields: LeagueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for League.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeagueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seasons<T extends League$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, League$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the League model
   */
  interface LeagueFieldRefs {
    readonly id: FieldRef<"League", 'Int'>
    readonly name: FieldRef<"League", 'String'>
    readonly createdAt: FieldRef<"League", 'DateTime'>
    readonly updatedAt: FieldRef<"League", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * League findUnique
   */
  export type LeagueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findUniqueOrThrow
   */
  export type LeagueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findFirst
   */
  export type LeagueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findFirstOrThrow
   */
  export type LeagueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findMany
   */
  export type LeagueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League create
   */
  export type LeagueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to create a League.
     */
    data: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
  }

  /**
   * League createMany
   */
  export type LeagueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * League createManyAndReturn
   */
  export type LeagueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * League update
   */
  export type LeagueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to update a League.
     */
    data: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
    /**
     * Choose, which League to update.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League updateMany
   */
  export type LeagueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
  }

  /**
   * League updateManyAndReturn
   */
  export type LeagueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
  }

  /**
   * League upsert
   */
  export type LeagueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The filter to search for the League to update in case it exists.
     */
    where: LeagueWhereUniqueInput
    /**
     * In case the League found by the `where` argument doesn't exist, create a new League with this data.
     */
    create: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
    /**
     * In case the League was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
  }

  /**
   * League delete
   */
  export type LeagueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter which League to delete.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League deleteMany
   */
  export type LeagueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leagues to delete
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to delete.
     */
    limit?: number
  }

  /**
   * League.seasons
   */
  export type League$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    cursor?: SeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * League without action
   */
  export type LeagueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    id: number | null
    leagueId: number | null
  }

  export type SeasonSumAggregateOutputType = {
    id: number | null
    leagueId: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: number | null
    leagueId: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: number | null
    leagueId: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    leagueId: number
    name: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    id?: true
    leagueId?: true
  }

  export type SeasonSumAggregateInputType = {
    id?: true
    leagueId?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    leagueId?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    leagueId?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    leagueId?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: number
    leagueId: number
    name: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    series?: boolean | Season$seriesArgs<ExtArgs>
    teamRosters?: boolean | Season$teamRostersArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    leagueId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "name" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["season"]>
  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    series?: boolean | Season$seriesArgs<ExtArgs>
    teamRosters?: boolean | Season$teamRostersArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      series: Prisma.$SeriesPayload<ExtArgs>[]
      teamRosters: Prisma.$TeamRosterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leagueId: number
      name: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons and returns the data updated in the database.
     * @param {SeasonUpdateManyAndReturnArgs} args - Arguments to update many Seasons.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeasonUpdateManyAndReturnArgs>(args: SelectSubset<T, SeasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    series<T extends Season$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Season$seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamRosters<T extends Season$teamRostersArgs<ExtArgs> = {}>(args?: Subset<T, Season$teamRostersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'Int'>
    readonly leagueId: FieldRef<"Season", 'Int'>
    readonly name: FieldRef<"Season", 'String'>
    readonly startDate: FieldRef<"Season", 'DateTime'>
    readonly endDate: FieldRef<"Season", 'DateTime'>
    readonly createdAt: FieldRef<"Season", 'DateTime'>
    readonly updatedAt: FieldRef<"Season", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season updateManyAndReturn
   */
  export type SeasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to delete.
     */
    limit?: number
  }

  /**
   * Season.series
   */
  export type Season$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Season.teamRosters
   */
  export type Season$teamRostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    where?: TeamRosterWhereInput
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    cursor?: TeamRosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamRosterScalarFieldEnum | TeamRosterScalarFieldEnum[]
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rosters?: boolean | Team$rostersArgs<ExtArgs>
    redSeries?: boolean | Team$redSeriesArgs<ExtArgs>
    blueSeries?: boolean | Team$blueSeriesArgs<ExtArgs>
    teamStats?: boolean | Team$teamStatsArgs<ExtArgs>
    substitutions?: boolean | Team$substitutionsArgs<ExtArgs>
    roundStats?: boolean | Team$roundStatsArgs<ExtArgs>
    matchParticipations?: boolean | Team$matchParticipationsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rosters?: boolean | Team$rostersArgs<ExtArgs>
    redSeries?: boolean | Team$redSeriesArgs<ExtArgs>
    blueSeries?: boolean | Team$blueSeriesArgs<ExtArgs>
    teamStats?: boolean | Team$teamStatsArgs<ExtArgs>
    substitutions?: boolean | Team$substitutionsArgs<ExtArgs>
    roundStats?: boolean | Team$roundStatsArgs<ExtArgs>
    matchParticipations?: boolean | Team$matchParticipationsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      rosters: Prisma.$TeamRosterPayload<ExtArgs>[]
      redSeries: Prisma.$SeriesPayload<ExtArgs>[]
      blueSeries: Prisma.$SeriesPayload<ExtArgs>[]
      teamStats: Prisma.$MatchTeamStatsPayload<ExtArgs>[]
      substitutions: Prisma.$SubstitutionPayload<ExtArgs>[]
      roundStats: Prisma.$RoundTeamStatsPayload<ExtArgs>[]
      matchParticipations: Prisma.$MatchParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rosters<T extends Team$rostersArgs<ExtArgs> = {}>(args?: Subset<T, Team$rostersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redSeries<T extends Team$redSeriesArgs<ExtArgs> = {}>(args?: Subset<T, Team$redSeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blueSeries<T extends Team$blueSeriesArgs<ExtArgs> = {}>(args?: Subset<T, Team$blueSeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamStats<T extends Team$teamStatsArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    substitutions<T extends Team$substitutionsArgs<ExtArgs> = {}>(args?: Subset<T, Team$substitutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roundStats<T extends Team$roundStatsArgs<ExtArgs> = {}>(args?: Subset<T, Team$roundStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchParticipations<T extends Team$matchParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$matchParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.rosters
   */
  export type Team$rostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    where?: TeamRosterWhereInput
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    cursor?: TeamRosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamRosterScalarFieldEnum | TeamRosterScalarFieldEnum[]
  }

  /**
   * Team.redSeries
   */
  export type Team$redSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Team.blueSeries
   */
  export type Team$blueSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Team.teamStats
   */
  export type Team$teamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    where?: MatchTeamStatsWhereInput
    orderBy?: MatchTeamStatsOrderByWithRelationInput | MatchTeamStatsOrderByWithRelationInput[]
    cursor?: MatchTeamStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchTeamStatsScalarFieldEnum | MatchTeamStatsScalarFieldEnum[]
  }

  /**
   * Team.substitutions
   */
  export type Team$substitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    where?: SubstitutionWhereInput
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    cursor?: SubstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Team.roundStats
   */
  export type Team$roundStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    where?: RoundTeamStatsWhereInput
    orderBy?: RoundTeamStatsOrderByWithRelationInput | RoundTeamStatsOrderByWithRelationInput[]
    cursor?: RoundTeamStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundTeamStatsScalarFieldEnum | RoundTeamStatsScalarFieldEnum[]
  }

  /**
   * Team.matchParticipations
   */
  export type Team$matchParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    where?: MatchParticipationWhereInput
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    cursor?: MatchParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    id: number | null
  }

  export type PlayerSumAggregateOutputType = {
    id: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: number | null
    name: string | null
    tag: string | null
    puuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tag: string | null
    puuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    name: number
    tag: number
    puuid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    id?: true
  }

  export type PlayerSumAggregateInputType = {
    id?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    name?: true
    tag?: true
    puuid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    name?: true
    tag?: true
    puuid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    name?: true
    tag?: true
    puuid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: number
    name: string
    tag: string
    puuid: string
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tag?: boolean
    puuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rosters?: boolean | Player$rostersArgs<ExtArgs>
    subIns?: boolean | Player$subInsArgs<ExtArgs>
    subOuts?: boolean | Player$subOutsArgs<ExtArgs>
    plants?: boolean | Player$plantsArgs<ExtArgs>
    defuses?: boolean | Player$defusesArgs<ExtArgs>
    roundStats?: boolean | Player$roundStatsArgs<ExtArgs>
    matchStats?: boolean | Player$matchStatsArgs<ExtArgs>
    kills?: boolean | Player$killsArgs<ExtArgs>
    deaths?: boolean | Player$deathsArgs<ExtArgs>
    killAssists?: boolean | Player$killAssistsArgs<ExtArgs>
    matchParticipations?: boolean | Player$matchParticipationsArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tag?: boolean
    puuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tag?: boolean
    puuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    name?: boolean
    tag?: boolean
    puuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tag" | "puuid" | "createdAt" | "updatedAt", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rosters?: boolean | Player$rostersArgs<ExtArgs>
    subIns?: boolean | Player$subInsArgs<ExtArgs>
    subOuts?: boolean | Player$subOutsArgs<ExtArgs>
    plants?: boolean | Player$plantsArgs<ExtArgs>
    defuses?: boolean | Player$defusesArgs<ExtArgs>
    roundStats?: boolean | Player$roundStatsArgs<ExtArgs>
    matchStats?: boolean | Player$matchStatsArgs<ExtArgs>
    kills?: boolean | Player$killsArgs<ExtArgs>
    deaths?: boolean | Player$deathsArgs<ExtArgs>
    killAssists?: boolean | Player$killAssistsArgs<ExtArgs>
    matchParticipations?: boolean | Player$matchParticipationsArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      rosters: Prisma.$TeamRosterPayload<ExtArgs>[]
      subIns: Prisma.$SubstitutionPayload<ExtArgs>[]
      subOuts: Prisma.$SubstitutionPayload<ExtArgs>[]
      plants: Prisma.$PlantPayload<ExtArgs>[]
      defuses: Prisma.$DefusePayload<ExtArgs>[]
      roundStats: Prisma.$RoundPlayerStatsPayload<ExtArgs>[]
      matchStats: Prisma.$MatchPlayerStatsPayload<ExtArgs>[]
      kills: Prisma.$KillPayload<ExtArgs>[]
      deaths: Prisma.$KillPayload<ExtArgs>[]
      killAssists: Prisma.$KillPayload<ExtArgs>[]
      matchParticipations: Prisma.$MatchParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      tag: string
      puuid: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rosters<T extends Player$rostersArgs<ExtArgs> = {}>(args?: Subset<T, Player$rostersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subIns<T extends Player$subInsArgs<ExtArgs> = {}>(args?: Subset<T, Player$subInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subOuts<T extends Player$subOutsArgs<ExtArgs> = {}>(args?: Subset<T, Player$subOutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plants<T extends Player$plantsArgs<ExtArgs> = {}>(args?: Subset<T, Player$plantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defuses<T extends Player$defusesArgs<ExtArgs> = {}>(args?: Subset<T, Player$defusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roundStats<T extends Player$roundStatsArgs<ExtArgs> = {}>(args?: Subset<T, Player$roundStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchStats<T extends Player$matchStatsArgs<ExtArgs> = {}>(args?: Subset<T, Player$matchStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kills<T extends Player$killsArgs<ExtArgs> = {}>(args?: Subset<T, Player$killsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deaths<T extends Player$deathsArgs<ExtArgs> = {}>(args?: Subset<T, Player$deathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    killAssists<T extends Player$killAssistsArgs<ExtArgs> = {}>(args?: Subset<T, Player$killAssistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchParticipations<T extends Player$matchParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Player$matchParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'Int'>
    readonly name: FieldRef<"Player", 'String'>
    readonly tag: FieldRef<"Player", 'String'>
    readonly puuid: FieldRef<"Player", 'String'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.rosters
   */
  export type Player$rostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    where?: TeamRosterWhereInput
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    cursor?: TeamRosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamRosterScalarFieldEnum | TeamRosterScalarFieldEnum[]
  }

  /**
   * Player.subIns
   */
  export type Player$subInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    where?: SubstitutionWhereInput
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    cursor?: SubstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Player.subOuts
   */
  export type Player$subOutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    where?: SubstitutionWhereInput
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    cursor?: SubstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Player.plants
   */
  export type Player$plantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    where?: PlantWhereInput
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    cursor?: PlantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Player.defuses
   */
  export type Player$defusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    where?: DefuseWhereInput
    orderBy?: DefuseOrderByWithRelationInput | DefuseOrderByWithRelationInput[]
    cursor?: DefuseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefuseScalarFieldEnum | DefuseScalarFieldEnum[]
  }

  /**
   * Player.roundStats
   */
  export type Player$roundStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    where?: RoundPlayerStatsWhereInput
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    cursor?: RoundPlayerStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundPlayerStatsScalarFieldEnum | RoundPlayerStatsScalarFieldEnum[]
  }

  /**
   * Player.matchStats
   */
  export type Player$matchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    where?: MatchPlayerStatsWhereInput
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    cursor?: MatchPlayerStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchPlayerStatsScalarFieldEnum | MatchPlayerStatsScalarFieldEnum[]
  }

  /**
   * Player.kills
   */
  export type Player$killsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    where?: KillWhereInput
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    cursor?: KillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Player.deaths
   */
  export type Player$deathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    where?: KillWhereInput
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    cursor?: KillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Player.killAssists
   */
  export type Player$killAssistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    where?: KillWhereInput
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    cursor?: KillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Player.matchParticipations
   */
  export type Player$matchParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    where?: MatchParticipationWhereInput
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    cursor?: MatchParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  export type SeriesAvgAggregateOutputType = {
    id: number | null
    seasonId: number | null
    redTeamId: number | null
    blueTeamId: number | null
    bestOf: number | null
    winnerTeamId: number | null
  }

  export type SeriesSumAggregateOutputType = {
    id: number | null
    seasonId: number | null
    redTeamId: number | null
    blueTeamId: number | null
    bestOf: number | null
    winnerTeamId: number | null
  }

  export type SeriesMinAggregateOutputType = {
    id: number | null
    seasonId: number | null
    redTeamId: number | null
    blueTeamId: number | null
    bestOf: number | null
    winnerTeamId: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeriesMaxAggregateOutputType = {
    id: number | null
    seasonId: number | null
    redTeamId: number | null
    blueTeamId: number | null
    bestOf: number | null
    winnerTeamId: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeriesCountAggregateOutputType = {
    id: number
    seasonId: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId: number
    status: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeriesAvgAggregateInputType = {
    id?: true
    seasonId?: true
    redTeamId?: true
    blueTeamId?: true
    bestOf?: true
    winnerTeamId?: true
  }

  export type SeriesSumAggregateInputType = {
    id?: true
    seasonId?: true
    redTeamId?: true
    blueTeamId?: true
    bestOf?: true
    winnerTeamId?: true
  }

  export type SeriesMinAggregateInputType = {
    id?: true
    seasonId?: true
    redTeamId?: true
    blueTeamId?: true
    bestOf?: true
    winnerTeamId?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeriesMaxAggregateInputType = {
    id?: true
    seasonId?: true
    redTeamId?: true
    blueTeamId?: true
    bestOf?: true
    winnerTeamId?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeriesCountAggregateInputType = {
    id?: true
    seasonId?: true
    redTeamId?: true
    blueTeamId?: true
    bestOf?: true
    winnerTeamId?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to aggregate.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Series
    **/
    _count?: true | SeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesMaxAggregateInputType
  }

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>
  }




  export type SeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithAggregationInput | SeriesOrderByWithAggregationInput[]
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum
    having?: SeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesCountAggregateInputType | true
    _avg?: SeriesAvgAggregateInputType
    _sum?: SeriesSumAggregateInputType
    _min?: SeriesMinAggregateInputType
    _max?: SeriesMaxAggregateInputType
  }

  export type SeriesGroupByOutputType = {
    id: number
    seasonId: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId: number | null
    status: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  type GetSeriesGroupByPayload<T extends SeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
        }
      >
    >


  export type SeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    redTeamId?: boolean
    blueTeamId?: boolean
    bestOf?: boolean
    winnerTeamId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    redTeam?: boolean | TeamDefaultArgs<ExtArgs>
    blueTeam?: boolean | TeamDefaultArgs<ExtArgs>
    matches?: boolean | Series$matchesArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    redTeamId?: boolean
    blueTeamId?: boolean
    bestOf?: boolean
    winnerTeamId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    redTeam?: boolean | TeamDefaultArgs<ExtArgs>
    blueTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    redTeamId?: boolean
    blueTeamId?: boolean
    bestOf?: boolean
    winnerTeamId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    redTeam?: boolean | TeamDefaultArgs<ExtArgs>
    blueTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectScalar = {
    id?: boolean
    seasonId?: boolean
    redTeamId?: boolean
    blueTeamId?: boolean
    bestOf?: boolean
    winnerTeamId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seasonId" | "redTeamId" | "blueTeamId" | "bestOf" | "winnerTeamId" | "status" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["series"]>
  export type SeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    redTeam?: boolean | TeamDefaultArgs<ExtArgs>
    blueTeam?: boolean | TeamDefaultArgs<ExtArgs>
    matches?: boolean | Series$matchesArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    redTeam?: boolean | TeamDefaultArgs<ExtArgs>
    blueTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    redTeam?: boolean | TeamDefaultArgs<ExtArgs>
    blueTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $SeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Series"
    objects: {
      season: Prisma.$SeasonPayload<ExtArgs>
      redTeam: Prisma.$TeamPayload<ExtArgs>
      blueTeam: Prisma.$TeamPayload<ExtArgs>
      matches: Prisma.$MatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seasonId: number
      redTeamId: number
      blueTeamId: number
      bestOf: number
      winnerTeamId: number | null
      status: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["series"]>
    composites: {}
  }

  type SeriesGetPayload<S extends boolean | null | undefined | SeriesDefaultArgs> = $Result.GetResult<Prisma.$SeriesPayload, S>

  type SeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesCountAggregateInputType | true
    }

  export interface SeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Series'], meta: { name: 'Series' } }
    /**
     * Find zero or one Series that matches the filter.
     * @param {SeriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesFindUniqueArgs>(args: SelectSubset<T, SeriesFindUniqueArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesFindFirstArgs>(args?: SelectSubset<T, SeriesFindFirstArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     * 
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeriesFindManyArgs>(args?: SelectSubset<T, SeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Series.
     * @param {SeriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     * 
     */
    create<T extends SeriesCreateArgs>(args: SelectSubset<T, SeriesCreateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Series.
     * @param {SeriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesCreateManyArgs>(args?: SelectSubset<T, SeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Series and returns the data saved in the database.
     * @param {SeriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Series.
     * @param {SeriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     * 
     */
    delete<T extends SeriesDeleteArgs>(args: SelectSubset<T, SeriesDeleteArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Series.
     * @param {SeriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesUpdateArgs>(args: SelectSubset<T, SeriesUpdateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Series.
     * @param {SeriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesDeleteManyArgs>(args?: SelectSubset<T, SeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesUpdateManyArgs>(args: SelectSubset<T, SeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {SeriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Series.
     * @param {SeriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends SeriesUpsertArgs>(args: SelectSubset<T, SeriesUpsertArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
    **/
    count<T extends SeriesCountArgs>(
      args?: Subset<T, SeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesAggregateArgs>(args: Subset<T, SeriesAggregateArgs>): Prisma.PrismaPromise<GetSeriesAggregateType<T>>

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesGroupByArgs['orderBy'] }
        : { orderBy?: SeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Series model
   */
  readonly fields: SeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    redTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blueTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    matches<T extends Series$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Series$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Series model
   */
  interface SeriesFieldRefs {
    readonly id: FieldRef<"Series", 'Int'>
    readonly seasonId: FieldRef<"Series", 'Int'>
    readonly redTeamId: FieldRef<"Series", 'Int'>
    readonly blueTeamId: FieldRef<"Series", 'Int'>
    readonly bestOf: FieldRef<"Series", 'Int'>
    readonly winnerTeamId: FieldRef<"Series", 'Int'>
    readonly status: FieldRef<"Series", 'String'>
    readonly startDate: FieldRef<"Series", 'DateTime'>
    readonly endDate: FieldRef<"Series", 'DateTime'>
    readonly createdAt: FieldRef<"Series", 'DateTime'>
    readonly updatedAt: FieldRef<"Series", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Series findUnique
   */
  export type SeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findUniqueOrThrow
   */
  export type SeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findFirst
   */
  export type SeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findFirstOrThrow
   */
  export type SeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findMany
   */
  export type SeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series create
   */
  export type SeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Series.
     */
    data: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
  }

  /**
   * Series createMany
   */
  export type SeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Series createManyAndReturn
   */
  export type SeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series update
   */
  export type SeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Series.
     */
    data: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
    /**
     * Choose, which Series to update.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series updateMany
   */
  export type SeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
  }

  /**
   * Series updateManyAndReturn
   */
  export type SeriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series upsert
   */
  export type SeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Series to update in case it exists.
     */
    where: SeriesWhereUniqueInput
    /**
     * In case the Series found by the `where` argument doesn't exist, create a new Series with this data.
     */
    create: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
    /**
     * In case the Series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
  }

  /**
   * Series delete
   */
  export type SeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter which Series to delete.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series deleteMany
   */
  export type SeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to delete
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to delete.
     */
    limit?: number
  }

  /**
   * Series.matches
   */
  export type Series$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Series without action
   */
  export type SeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    id: number | null
    seriesId: number | null
    matchNumber: number | null
    gameLengthMs: number | null
  }

  export type MatchSumAggregateOutputType = {
    id: number | null
    seriesId: number | null
    matchNumber: number | null
    gameLengthMs: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: number | null
    seriesId: number | null
    matchNumber: number | null
    riotMatchId: string | null
    mapId: string | null
    gameLengthMs: number | null
    startedAt: Date | null
    completedAt: Date | null
    isCompleted: boolean | null
    status: string | null
    winnerTeamSide: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: number | null
    seriesId: number | null
    matchNumber: number | null
    riotMatchId: string | null
    mapId: string | null
    gameLengthMs: number | null
    startedAt: Date | null
    completedAt: Date | null
    isCompleted: boolean | null
    status: string | null
    winnerTeamSide: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    seriesId: number
    matchNumber: number
    riotMatchId: number
    mapId: number
    gameLengthMs: number
    startedAt: number
    completedAt: number
    isCompleted: number
    status: number
    winnerTeamSide: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    id?: true
    seriesId?: true
    matchNumber?: true
    gameLengthMs?: true
  }

  export type MatchSumAggregateInputType = {
    id?: true
    seriesId?: true
    matchNumber?: true
    gameLengthMs?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    seriesId?: true
    matchNumber?: true
    riotMatchId?: true
    mapId?: true
    gameLengthMs?: true
    startedAt?: true
    completedAt?: true
    isCompleted?: true
    status?: true
    winnerTeamSide?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    seriesId?: true
    matchNumber?: true
    riotMatchId?: true
    mapId?: true
    gameLengthMs?: true
    startedAt?: true
    completedAt?: true
    isCompleted?: true
    status?: true
    winnerTeamSide?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    seriesId?: true
    matchNumber?: true
    riotMatchId?: true
    mapId?: true
    gameLengthMs?: true
    startedAt?: true
    completedAt?: true
    isCompleted?: true
    status?: true
    winnerTeamSide?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: number
    seriesId: number
    matchNumber: number
    riotMatchId: string | null
    mapId: string
    gameLengthMs: number | null
    startedAt: Date
    completedAt: Date | null
    isCompleted: boolean
    status: string
    winnerTeamSide: string | null
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    matchNumber?: boolean
    riotMatchId?: boolean
    mapId?: boolean
    gameLengthMs?: boolean
    startedAt?: boolean
    completedAt?: boolean
    isCompleted?: boolean
    status?: boolean
    winnerTeamSide?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
    rounds?: boolean | Match$roundsArgs<ExtArgs>
    matchPlayerStats?: boolean | Match$matchPlayerStatsArgs<ExtArgs>
    matchTeamStats?: boolean | Match$matchTeamStatsArgs<ExtArgs>
    substitutions?: boolean | Match$substitutionsArgs<ExtArgs>
    kills?: boolean | Match$killsArgs<ExtArgs>
    participations?: boolean | Match$participationsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    matchNumber?: boolean
    riotMatchId?: boolean
    mapId?: boolean
    gameLengthMs?: boolean
    startedAt?: boolean
    completedAt?: boolean
    isCompleted?: boolean
    status?: boolean
    winnerTeamSide?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    matchNumber?: boolean
    riotMatchId?: boolean
    mapId?: boolean
    gameLengthMs?: boolean
    startedAt?: boolean
    completedAt?: boolean
    isCompleted?: boolean
    status?: boolean
    winnerTeamSide?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    seriesId?: boolean
    matchNumber?: boolean
    riotMatchId?: boolean
    mapId?: boolean
    gameLengthMs?: boolean
    startedAt?: boolean
    completedAt?: boolean
    isCompleted?: boolean
    status?: boolean
    winnerTeamSide?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seriesId" | "matchNumber" | "riotMatchId" | "mapId" | "gameLengthMs" | "startedAt" | "completedAt" | "isCompleted" | "status" | "winnerTeamSide" | "createdAt" | "updatedAt", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
    rounds?: boolean | Match$roundsArgs<ExtArgs>
    matchPlayerStats?: boolean | Match$matchPlayerStatsArgs<ExtArgs>
    matchTeamStats?: boolean | Match$matchTeamStatsArgs<ExtArgs>
    substitutions?: boolean | Match$substitutionsArgs<ExtArgs>
    kills?: boolean | Match$killsArgs<ExtArgs>
    participations?: boolean | Match$participationsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }
  export type MatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      series: Prisma.$SeriesPayload<ExtArgs>
      map: Prisma.$MapPayload<ExtArgs>
      rounds: Prisma.$RoundPayload<ExtArgs>[]
      matchPlayerStats: Prisma.$MatchPlayerStatsPayload<ExtArgs>[]
      matchTeamStats: Prisma.$MatchTeamStatsPayload<ExtArgs>[]
      substitutions: Prisma.$SubstitutionPayload<ExtArgs>[]
      kills: Prisma.$KillPayload<ExtArgs>[]
      participations: Prisma.$MatchParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seriesId: number
      matchNumber: number
      riotMatchId: string | null
      mapId: string
      gameLengthMs: number | null
      startedAt: Date
      completedAt: Date | null
      isCompleted: boolean
      status: string
      winnerTeamSide: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches and returns the data updated in the database.
     * @param {MatchUpdateManyAndReturnArgs} args - Arguments to update many Matches.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    series<T extends SeriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeriesDefaultArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    map<T extends MapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MapDefaultArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rounds<T extends Match$roundsArgs<ExtArgs> = {}>(args?: Subset<T, Match$roundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchPlayerStats<T extends Match$matchPlayerStatsArgs<ExtArgs> = {}>(args?: Subset<T, Match$matchPlayerStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchTeamStats<T extends Match$matchTeamStatsArgs<ExtArgs> = {}>(args?: Subset<T, Match$matchTeamStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    substitutions<T extends Match$substitutionsArgs<ExtArgs> = {}>(args?: Subset<T, Match$substitutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kills<T extends Match$killsArgs<ExtArgs> = {}>(args?: Subset<T, Match$killsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participations<T extends Match$participationsArgs<ExtArgs> = {}>(args?: Subset<T, Match$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'Int'>
    readonly seriesId: FieldRef<"Match", 'Int'>
    readonly matchNumber: FieldRef<"Match", 'Int'>
    readonly riotMatchId: FieldRef<"Match", 'String'>
    readonly mapId: FieldRef<"Match", 'String'>
    readonly gameLengthMs: FieldRef<"Match", 'Int'>
    readonly startedAt: FieldRef<"Match", 'DateTime'>
    readonly completedAt: FieldRef<"Match", 'DateTime'>
    readonly isCompleted: FieldRef<"Match", 'Boolean'>
    readonly status: FieldRef<"Match", 'String'>
    readonly winnerTeamSide: FieldRef<"Match", 'String'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match updateManyAndReturn
   */
  export type MatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match.rounds
   */
  export type Match$roundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    where?: RoundWhereInput
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    cursor?: RoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Match.matchPlayerStats
   */
  export type Match$matchPlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    where?: MatchPlayerStatsWhereInput
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    cursor?: MatchPlayerStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchPlayerStatsScalarFieldEnum | MatchPlayerStatsScalarFieldEnum[]
  }

  /**
   * Match.matchTeamStats
   */
  export type Match$matchTeamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    where?: MatchTeamStatsWhereInput
    orderBy?: MatchTeamStatsOrderByWithRelationInput | MatchTeamStatsOrderByWithRelationInput[]
    cursor?: MatchTeamStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchTeamStatsScalarFieldEnum | MatchTeamStatsScalarFieldEnum[]
  }

  /**
   * Match.substitutions
   */
  export type Match$substitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    where?: SubstitutionWhereInput
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    cursor?: SubstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Match.kills
   */
  export type Match$killsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    where?: KillWhereInput
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    cursor?: KillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Match.participations
   */
  export type Match$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    where?: MatchParticipationWhereInput
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    cursor?: MatchParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model MatchParticipation
   */

  export type AggregateMatchParticipation = {
    _count: MatchParticipationCountAggregateOutputType | null
    _avg: MatchParticipationAvgAggregateOutputType | null
    _sum: MatchParticipationSumAggregateOutputType | null
    _min: MatchParticipationMinAggregateOutputType | null
    _max: MatchParticipationMaxAggregateOutputType | null
  }

  export type MatchParticipationAvgAggregateOutputType = {
    id: number | null
    matchId: number | null
    playerId: number | null
    teamId: number | null
  }

  export type MatchParticipationSumAggregateOutputType = {
    id: number | null
    matchId: number | null
    playerId: number | null
    teamId: number | null
  }

  export type MatchParticipationMinAggregateOutputType = {
    id: number | null
    matchId: number | null
    playerId: number | null
    teamId: number | null
    teamSide: string | null
    agentId: string | null
    createdAt: Date | null
  }

  export type MatchParticipationMaxAggregateOutputType = {
    id: number | null
    matchId: number | null
    playerId: number | null
    teamId: number | null
    teamSide: string | null
    agentId: string | null
    createdAt: Date | null
  }

  export type MatchParticipationCountAggregateOutputType = {
    id: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: number
    agentId: number
    createdAt: number
    _all: number
  }


  export type MatchParticipationAvgAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
  }

  export type MatchParticipationSumAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
  }

  export type MatchParticipationMinAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    teamSide?: true
    agentId?: true
    createdAt?: true
  }

  export type MatchParticipationMaxAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    teamSide?: true
    agentId?: true
    createdAt?: true
  }

  export type MatchParticipationCountAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    teamSide?: true
    agentId?: true
    createdAt?: true
    _all?: true
  }

  export type MatchParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchParticipation to aggregate.
     */
    where?: MatchParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipations to fetch.
     */
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchParticipations
    **/
    _count?: true | MatchParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchParticipationMaxAggregateInputType
  }

  export type GetMatchParticipationAggregateType<T extends MatchParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchParticipation[P]>
      : GetScalarType<T[P], AggregateMatchParticipation[P]>
  }




  export type MatchParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipationWhereInput
    orderBy?: MatchParticipationOrderByWithAggregationInput | MatchParticipationOrderByWithAggregationInput[]
    by: MatchParticipationScalarFieldEnum[] | MatchParticipationScalarFieldEnum
    having?: MatchParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchParticipationCountAggregateInputType | true
    _avg?: MatchParticipationAvgAggregateInputType
    _sum?: MatchParticipationSumAggregateInputType
    _min?: MatchParticipationMinAggregateInputType
    _max?: MatchParticipationMaxAggregateInputType
  }

  export type MatchParticipationGroupByOutputType = {
    id: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    agentId: string | null
    createdAt: Date
    _count: MatchParticipationCountAggregateOutputType | null
    _avg: MatchParticipationAvgAggregateOutputType | null
    _sum: MatchParticipationSumAggregateOutputType | null
    _min: MatchParticipationMinAggregateOutputType | null
    _max: MatchParticipationMaxAggregateOutputType | null
  }

  type GetMatchParticipationGroupByPayload<T extends MatchParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], MatchParticipationGroupByOutputType[P]>
        }
      >
    >


  export type MatchParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    teamSide?: boolean
    agentId?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    agent?: boolean | MatchParticipation$agentArgs<ExtArgs>
    matchStats?: boolean | MatchParticipation$matchStatsArgs<ExtArgs>
    roundStats?: boolean | MatchParticipation$roundStatsArgs<ExtArgs>
    _count?: boolean | MatchParticipationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchParticipation"]>

  export type MatchParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    teamSide?: boolean
    agentId?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    agent?: boolean | MatchParticipation$agentArgs<ExtArgs>
  }, ExtArgs["result"]["matchParticipation"]>

  export type MatchParticipationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    teamSide?: boolean
    agentId?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    agent?: boolean | MatchParticipation$agentArgs<ExtArgs>
  }, ExtArgs["result"]["matchParticipation"]>

  export type MatchParticipationSelectScalar = {
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    teamSide?: boolean
    agentId?: boolean
    createdAt?: boolean
  }

  export type MatchParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "playerId" | "teamId" | "teamSide" | "agentId" | "createdAt", ExtArgs["result"]["matchParticipation"]>
  export type MatchParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    agent?: boolean | MatchParticipation$agentArgs<ExtArgs>
    matchStats?: boolean | MatchParticipation$matchStatsArgs<ExtArgs>
    roundStats?: boolean | MatchParticipation$roundStatsArgs<ExtArgs>
    _count?: boolean | MatchParticipationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    agent?: boolean | MatchParticipation$agentArgs<ExtArgs>
  }
  export type MatchParticipationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    agent?: boolean | MatchParticipation$agentArgs<ExtArgs>
  }

  export type $MatchParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchParticipation"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
      matchStats: Prisma.$MatchPlayerStatsPayload<ExtArgs> | null
      roundStats: Prisma.$RoundPlayerStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matchId: number
      playerId: number
      teamId: number
      teamSide: string
      agentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["matchParticipation"]>
    composites: {}
  }

  type MatchParticipationGetPayload<S extends boolean | null | undefined | MatchParticipationDefaultArgs> = $Result.GetResult<Prisma.$MatchParticipationPayload, S>

  type MatchParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchParticipationCountAggregateInputType | true
    }

  export interface MatchParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchParticipation'], meta: { name: 'MatchParticipation' } }
    /**
     * Find zero or one MatchParticipation that matches the filter.
     * @param {MatchParticipationFindUniqueArgs} args - Arguments to find a MatchParticipation
     * @example
     * // Get one MatchParticipation
     * const matchParticipation = await prisma.matchParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchParticipationFindUniqueArgs>(args: SelectSubset<T, MatchParticipationFindUniqueArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchParticipationFindUniqueOrThrowArgs} args - Arguments to find a MatchParticipation
     * @example
     * // Get one MatchParticipation
     * const matchParticipation = await prisma.matchParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationFindFirstArgs} args - Arguments to find a MatchParticipation
     * @example
     * // Get one MatchParticipation
     * const matchParticipation = await prisma.matchParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchParticipationFindFirstArgs>(args?: SelectSubset<T, MatchParticipationFindFirstArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationFindFirstOrThrowArgs} args - Arguments to find a MatchParticipation
     * @example
     * // Get one MatchParticipation
     * const matchParticipation = await prisma.matchParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchParticipations
     * const matchParticipations = await prisma.matchParticipation.findMany()
     * 
     * // Get first 10 MatchParticipations
     * const matchParticipations = await prisma.matchParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchParticipationWithIdOnly = await prisma.matchParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchParticipationFindManyArgs>(args?: SelectSubset<T, MatchParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchParticipation.
     * @param {MatchParticipationCreateArgs} args - Arguments to create a MatchParticipation.
     * @example
     * // Create one MatchParticipation
     * const MatchParticipation = await prisma.matchParticipation.create({
     *   data: {
     *     // ... data to create a MatchParticipation
     *   }
     * })
     * 
     */
    create<T extends MatchParticipationCreateArgs>(args: SelectSubset<T, MatchParticipationCreateArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchParticipations.
     * @param {MatchParticipationCreateManyArgs} args - Arguments to create many MatchParticipations.
     * @example
     * // Create many MatchParticipations
     * const matchParticipation = await prisma.matchParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchParticipationCreateManyArgs>(args?: SelectSubset<T, MatchParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchParticipations and returns the data saved in the database.
     * @param {MatchParticipationCreateManyAndReturnArgs} args - Arguments to create many MatchParticipations.
     * @example
     * // Create many MatchParticipations
     * const matchParticipation = await prisma.matchParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchParticipations and only return the `id`
     * const matchParticipationWithIdOnly = await prisma.matchParticipation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchParticipation.
     * @param {MatchParticipationDeleteArgs} args - Arguments to delete one MatchParticipation.
     * @example
     * // Delete one MatchParticipation
     * const MatchParticipation = await prisma.matchParticipation.delete({
     *   where: {
     *     // ... filter to delete one MatchParticipation
     *   }
     * })
     * 
     */
    delete<T extends MatchParticipationDeleteArgs>(args: SelectSubset<T, MatchParticipationDeleteArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchParticipation.
     * @param {MatchParticipationUpdateArgs} args - Arguments to update one MatchParticipation.
     * @example
     * // Update one MatchParticipation
     * const matchParticipation = await prisma.matchParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchParticipationUpdateArgs>(args: SelectSubset<T, MatchParticipationUpdateArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchParticipations.
     * @param {MatchParticipationDeleteManyArgs} args - Arguments to filter MatchParticipations to delete.
     * @example
     * // Delete a few MatchParticipations
     * const { count } = await prisma.matchParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchParticipationDeleteManyArgs>(args?: SelectSubset<T, MatchParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchParticipations
     * const matchParticipation = await prisma.matchParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchParticipationUpdateManyArgs>(args: SelectSubset<T, MatchParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchParticipations and returns the data updated in the database.
     * @param {MatchParticipationUpdateManyAndReturnArgs} args - Arguments to update many MatchParticipations.
     * @example
     * // Update many MatchParticipations
     * const matchParticipation = await prisma.matchParticipation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchParticipations and only return the `id`
     * const matchParticipationWithIdOnly = await prisma.matchParticipation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchParticipationUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchParticipationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchParticipation.
     * @param {MatchParticipationUpsertArgs} args - Arguments to update or create a MatchParticipation.
     * @example
     * // Update or create a MatchParticipation
     * const matchParticipation = await prisma.matchParticipation.upsert({
     *   create: {
     *     // ... data to create a MatchParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchParticipation we want to update
     *   }
     * })
     */
    upsert<T extends MatchParticipationUpsertArgs>(args: SelectSubset<T, MatchParticipationUpsertArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationCountArgs} args - Arguments to filter MatchParticipations to count.
     * @example
     * // Count the number of MatchParticipations
     * const count = await prisma.matchParticipation.count({
     *   where: {
     *     // ... the filter for the MatchParticipations we want to count
     *   }
     * })
    **/
    count<T extends MatchParticipationCountArgs>(
      args?: Subset<T, MatchParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchParticipationAggregateArgs>(args: Subset<T, MatchParticipationAggregateArgs>): Prisma.PrismaPromise<GetMatchParticipationAggregateType<T>>

    /**
     * Group by MatchParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchParticipationGroupByArgs['orderBy'] }
        : { orderBy?: MatchParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchParticipation model
   */
  readonly fields: MatchParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends MatchParticipation$agentArgs<ExtArgs> = {}>(args?: Subset<T, MatchParticipation$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    matchStats<T extends MatchParticipation$matchStatsArgs<ExtArgs> = {}>(args?: Subset<T, MatchParticipation$matchStatsArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roundStats<T extends MatchParticipation$roundStatsArgs<ExtArgs> = {}>(args?: Subset<T, MatchParticipation$roundStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchParticipation model
   */
  interface MatchParticipationFieldRefs {
    readonly id: FieldRef<"MatchParticipation", 'Int'>
    readonly matchId: FieldRef<"MatchParticipation", 'Int'>
    readonly playerId: FieldRef<"MatchParticipation", 'Int'>
    readonly teamId: FieldRef<"MatchParticipation", 'Int'>
    readonly teamSide: FieldRef<"MatchParticipation", 'String'>
    readonly agentId: FieldRef<"MatchParticipation", 'String'>
    readonly createdAt: FieldRef<"MatchParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchParticipation findUnique
   */
  export type MatchParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipation to fetch.
     */
    where: MatchParticipationWhereUniqueInput
  }

  /**
   * MatchParticipation findUniqueOrThrow
   */
  export type MatchParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipation to fetch.
     */
    where: MatchParticipationWhereUniqueInput
  }

  /**
   * MatchParticipation findFirst
   */
  export type MatchParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipation to fetch.
     */
    where?: MatchParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipations to fetch.
     */
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchParticipations.
     */
    cursor?: MatchParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchParticipations.
     */
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * MatchParticipation findFirstOrThrow
   */
  export type MatchParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipation to fetch.
     */
    where?: MatchParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipations to fetch.
     */
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchParticipations.
     */
    cursor?: MatchParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchParticipations.
     */
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * MatchParticipation findMany
   */
  export type MatchParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipations to fetch.
     */
    where?: MatchParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipations to fetch.
     */
    orderBy?: MatchParticipationOrderByWithRelationInput | MatchParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchParticipations.
     */
    cursor?: MatchParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipations.
     */
    skip?: number
    distinct?: MatchParticipationScalarFieldEnum | MatchParticipationScalarFieldEnum[]
  }

  /**
   * MatchParticipation create
   */
  export type MatchParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchParticipation.
     */
    data: XOR<MatchParticipationCreateInput, MatchParticipationUncheckedCreateInput>
  }

  /**
   * MatchParticipation createMany
   */
  export type MatchParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchParticipations.
     */
    data: MatchParticipationCreateManyInput | MatchParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchParticipation createManyAndReturn
   */
  export type MatchParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * The data used to create many MatchParticipations.
     */
    data: MatchParticipationCreateManyInput | MatchParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchParticipation update
   */
  export type MatchParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchParticipation.
     */
    data: XOR<MatchParticipationUpdateInput, MatchParticipationUncheckedUpdateInput>
    /**
     * Choose, which MatchParticipation to update.
     */
    where: MatchParticipationWhereUniqueInput
  }

  /**
   * MatchParticipation updateMany
   */
  export type MatchParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchParticipations.
     */
    data: XOR<MatchParticipationUpdateManyMutationInput, MatchParticipationUncheckedUpdateManyInput>
    /**
     * Filter which MatchParticipations to update
     */
    where?: MatchParticipationWhereInput
    /**
     * Limit how many MatchParticipations to update.
     */
    limit?: number
  }

  /**
   * MatchParticipation updateManyAndReturn
   */
  export type MatchParticipationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * The data used to update MatchParticipations.
     */
    data: XOR<MatchParticipationUpdateManyMutationInput, MatchParticipationUncheckedUpdateManyInput>
    /**
     * Filter which MatchParticipations to update
     */
    where?: MatchParticipationWhereInput
    /**
     * Limit how many MatchParticipations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchParticipation upsert
   */
  export type MatchParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchParticipation to update in case it exists.
     */
    where: MatchParticipationWhereUniqueInput
    /**
     * In case the MatchParticipation found by the `where` argument doesn't exist, create a new MatchParticipation with this data.
     */
    create: XOR<MatchParticipationCreateInput, MatchParticipationUncheckedCreateInput>
    /**
     * In case the MatchParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchParticipationUpdateInput, MatchParticipationUncheckedUpdateInput>
  }

  /**
   * MatchParticipation delete
   */
  export type MatchParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
    /**
     * Filter which MatchParticipation to delete.
     */
    where: MatchParticipationWhereUniqueInput
  }

  /**
   * MatchParticipation deleteMany
   */
  export type MatchParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchParticipations to delete
     */
    where?: MatchParticipationWhereInput
    /**
     * Limit how many MatchParticipations to delete.
     */
    limit?: number
  }

  /**
   * MatchParticipation.agent
   */
  export type MatchParticipation$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * MatchParticipation.matchStats
   */
  export type MatchParticipation$matchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    where?: MatchPlayerStatsWhereInput
  }

  /**
   * MatchParticipation.roundStats
   */
  export type MatchParticipation$roundStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    where?: RoundPlayerStatsWhereInput
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    cursor?: RoundPlayerStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundPlayerStatsScalarFieldEnum | RoundPlayerStatsScalarFieldEnum[]
  }

  /**
   * MatchParticipation without action
   */
  export type MatchParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipation
     */
    select?: MatchParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipation
     */
    omit?: MatchParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipationInclude<ExtArgs> | null
  }


  /**
   * Model MatchPlayerStats
   */

  export type AggregateMatchPlayerStats = {
    _count: MatchPlayerStatsCountAggregateOutputType | null
    _avg: MatchPlayerStatsAvgAggregateOutputType | null
    _sum: MatchPlayerStatsSumAggregateOutputType | null
    _min: MatchPlayerStatsMinAggregateOutputType | null
    _max: MatchPlayerStatsMaxAggregateOutputType | null
  }

  export type MatchPlayerStatsAvgAggregateOutputType = {
    id: number | null
    matchParticipationId: number | null
    matchId: number | null
    playerId: number | null
    score: number | null
    kills: number | null
    deaths: number | null
    assists: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    damageDealt: number | null
    damageReceived: number | null
    adr: number | null
    acs: number | null
    kd: number | null
    hsPercent: number | null
    kast: number | null
    firstKills: number | null
    firstDeaths: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    spentOverall: number | null
    spentAverage: number | null
    loadoutOverall: number | null
    loadoutAverage: number | null
  }

  export type MatchPlayerStatsSumAggregateOutputType = {
    id: number | null
    matchParticipationId: number | null
    matchId: number | null
    playerId: number | null
    score: number | null
    kills: number | null
    deaths: number | null
    assists: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    damageDealt: number | null
    damageReceived: number | null
    adr: number | null
    acs: number | null
    kd: number | null
    hsPercent: number | null
    kast: number | null
    firstKills: number | null
    firstDeaths: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    spentOverall: number | null
    spentAverage: number | null
    loadoutOverall: number | null
    loadoutAverage: number | null
  }

  export type MatchPlayerStatsMinAggregateOutputType = {
    id: number | null
    matchParticipationId: number | null
    matchId: number | null
    playerId: number | null
    agentId: string | null
    agentName: string | null
    score: number | null
    kills: number | null
    deaths: number | null
    assists: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    damageDealt: number | null
    damageReceived: number | null
    adr: number | null
    acs: number | null
    kd: number | null
    hsPercent: number | null
    kast: number | null
    firstKills: number | null
    firstDeaths: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    spentOverall: number | null
    spentAverage: number | null
    loadoutOverall: number | null
    loadoutAverage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchPlayerStatsMaxAggregateOutputType = {
    id: number | null
    matchParticipationId: number | null
    matchId: number | null
    playerId: number | null
    agentId: string | null
    agentName: string | null
    score: number | null
    kills: number | null
    deaths: number | null
    assists: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    damageDealt: number | null
    damageReceived: number | null
    adr: number | null
    acs: number | null
    kd: number | null
    hsPercent: number | null
    kast: number | null
    firstKills: number | null
    firstDeaths: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    spentOverall: number | null
    spentAverage: number | null
    loadoutOverall: number | null
    loadoutAverage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchPlayerStatsCountAggregateOutputType = {
    id: number
    matchParticipationId: number
    matchId: number
    playerId: number
    agentId: number
    agentName: number
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr: number
    acs: number
    kd: number
    hsPercent: number
    kast: number
    firstKills: number
    firstDeaths: number
    grenadeCasts: number
    ability1Casts: number
    ability2Casts: number
    ultimateCasts: number
    spentOverall: number
    spentAverage: number
    loadoutOverall: number
    loadoutAverage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchPlayerStatsAvgAggregateInputType = {
    id?: true
    matchParticipationId?: true
    matchId?: true
    playerId?: true
    score?: true
    kills?: true
    deaths?: true
    assists?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    damageDealt?: true
    damageReceived?: true
    adr?: true
    acs?: true
    kd?: true
    hsPercent?: true
    kast?: true
    firstKills?: true
    firstDeaths?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    spentOverall?: true
    spentAverage?: true
    loadoutOverall?: true
    loadoutAverage?: true
  }

  export type MatchPlayerStatsSumAggregateInputType = {
    id?: true
    matchParticipationId?: true
    matchId?: true
    playerId?: true
    score?: true
    kills?: true
    deaths?: true
    assists?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    damageDealt?: true
    damageReceived?: true
    adr?: true
    acs?: true
    kd?: true
    hsPercent?: true
    kast?: true
    firstKills?: true
    firstDeaths?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    spentOverall?: true
    spentAverage?: true
    loadoutOverall?: true
    loadoutAverage?: true
  }

  export type MatchPlayerStatsMinAggregateInputType = {
    id?: true
    matchParticipationId?: true
    matchId?: true
    playerId?: true
    agentId?: true
    agentName?: true
    score?: true
    kills?: true
    deaths?: true
    assists?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    damageDealt?: true
    damageReceived?: true
    adr?: true
    acs?: true
    kd?: true
    hsPercent?: true
    kast?: true
    firstKills?: true
    firstDeaths?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    spentOverall?: true
    spentAverage?: true
    loadoutOverall?: true
    loadoutAverage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchPlayerStatsMaxAggregateInputType = {
    id?: true
    matchParticipationId?: true
    matchId?: true
    playerId?: true
    agentId?: true
    agentName?: true
    score?: true
    kills?: true
    deaths?: true
    assists?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    damageDealt?: true
    damageReceived?: true
    adr?: true
    acs?: true
    kd?: true
    hsPercent?: true
    kast?: true
    firstKills?: true
    firstDeaths?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    spentOverall?: true
    spentAverage?: true
    loadoutOverall?: true
    loadoutAverage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchPlayerStatsCountAggregateInputType = {
    id?: true
    matchParticipationId?: true
    matchId?: true
    playerId?: true
    agentId?: true
    agentName?: true
    score?: true
    kills?: true
    deaths?: true
    assists?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    damageDealt?: true
    damageReceived?: true
    adr?: true
    acs?: true
    kd?: true
    hsPercent?: true
    kast?: true
    firstKills?: true
    firstDeaths?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    spentOverall?: true
    spentAverage?: true
    loadoutOverall?: true
    loadoutAverage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchPlayerStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchPlayerStats to aggregate.
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchPlayerStats to fetch.
     */
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchPlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchPlayerStats
    **/
    _count?: true | MatchPlayerStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchPlayerStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchPlayerStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchPlayerStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchPlayerStatsMaxAggregateInputType
  }

  export type GetMatchPlayerStatsAggregateType<T extends MatchPlayerStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchPlayerStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchPlayerStats[P]>
      : GetScalarType<T[P], AggregateMatchPlayerStats[P]>
  }




  export type MatchPlayerStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchPlayerStatsWhereInput
    orderBy?: MatchPlayerStatsOrderByWithAggregationInput | MatchPlayerStatsOrderByWithAggregationInput[]
    by: MatchPlayerStatsScalarFieldEnum[] | MatchPlayerStatsScalarFieldEnum
    having?: MatchPlayerStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchPlayerStatsCountAggregateInputType | true
    _avg?: MatchPlayerStatsAvgAggregateInputType
    _sum?: MatchPlayerStatsSumAggregateInputType
    _min?: MatchPlayerStatsMinAggregateInputType
    _max?: MatchPlayerStatsMaxAggregateInputType
  }

  export type MatchPlayerStatsGroupByOutputType = {
    id: number
    matchParticipationId: number
    matchId: number
    playerId: number
    agentId: string | null
    agentName: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr: number | null
    acs: number | null
    kd: number | null
    hsPercent: number | null
    kast: number | null
    firstKills: number | null
    firstDeaths: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    spentOverall: number | null
    spentAverage: number | null
    loadoutOverall: number | null
    loadoutAverage: number | null
    createdAt: Date
    updatedAt: Date
    _count: MatchPlayerStatsCountAggregateOutputType | null
    _avg: MatchPlayerStatsAvgAggregateOutputType | null
    _sum: MatchPlayerStatsSumAggregateOutputType | null
    _min: MatchPlayerStatsMinAggregateOutputType | null
    _max: MatchPlayerStatsMaxAggregateOutputType | null
  }

  type GetMatchPlayerStatsGroupByPayload<T extends MatchPlayerStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchPlayerStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchPlayerStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchPlayerStatsGroupByOutputType[P]>
            : GetScalarType<T[P], MatchPlayerStatsGroupByOutputType[P]>
        }
      >
    >


  export type MatchPlayerStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchParticipationId?: boolean
    matchId?: boolean
    playerId?: boolean
    agentId?: boolean
    agentName?: boolean
    score?: boolean
    kills?: boolean
    deaths?: boolean
    assists?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    adr?: boolean
    acs?: boolean
    kd?: boolean
    hsPercent?: boolean
    kast?: boolean
    firstKills?: boolean
    firstDeaths?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    spentOverall?: boolean
    spentAverage?: boolean
    loadoutOverall?: boolean
    loadoutAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    Agent?: boolean | MatchPlayerStats$AgentArgs<ExtArgs>
  }, ExtArgs["result"]["matchPlayerStats"]>

  export type MatchPlayerStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchParticipationId?: boolean
    matchId?: boolean
    playerId?: boolean
    agentId?: boolean
    agentName?: boolean
    score?: boolean
    kills?: boolean
    deaths?: boolean
    assists?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    adr?: boolean
    acs?: boolean
    kd?: boolean
    hsPercent?: boolean
    kast?: boolean
    firstKills?: boolean
    firstDeaths?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    spentOverall?: boolean
    spentAverage?: boolean
    loadoutOverall?: boolean
    loadoutAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    Agent?: boolean | MatchPlayerStats$AgentArgs<ExtArgs>
  }, ExtArgs["result"]["matchPlayerStats"]>

  export type MatchPlayerStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchParticipationId?: boolean
    matchId?: boolean
    playerId?: boolean
    agentId?: boolean
    agentName?: boolean
    score?: boolean
    kills?: boolean
    deaths?: boolean
    assists?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    adr?: boolean
    acs?: boolean
    kd?: boolean
    hsPercent?: boolean
    kast?: boolean
    firstKills?: boolean
    firstDeaths?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    spentOverall?: boolean
    spentAverage?: boolean
    loadoutOverall?: boolean
    loadoutAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    Agent?: boolean | MatchPlayerStats$AgentArgs<ExtArgs>
  }, ExtArgs["result"]["matchPlayerStats"]>

  export type MatchPlayerStatsSelectScalar = {
    id?: boolean
    matchParticipationId?: boolean
    matchId?: boolean
    playerId?: boolean
    agentId?: boolean
    agentName?: boolean
    score?: boolean
    kills?: boolean
    deaths?: boolean
    assists?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    adr?: boolean
    acs?: boolean
    kd?: boolean
    hsPercent?: boolean
    kast?: boolean
    firstKills?: boolean
    firstDeaths?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    spentOverall?: boolean
    spentAverage?: boolean
    loadoutOverall?: boolean
    loadoutAverage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchPlayerStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchParticipationId" | "matchId" | "playerId" | "agentId" | "agentName" | "score" | "kills" | "deaths" | "assists" | "headshots" | "bodyshots" | "legshots" | "damageDealt" | "damageReceived" | "adr" | "acs" | "kd" | "hsPercent" | "kast" | "firstKills" | "firstDeaths" | "grenadeCasts" | "ability1Casts" | "ability2Casts" | "ultimateCasts" | "spentOverall" | "spentAverage" | "loadoutOverall" | "loadoutAverage" | "createdAt" | "updatedAt", ExtArgs["result"]["matchPlayerStats"]>
  export type MatchPlayerStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    Agent?: boolean | MatchPlayerStats$AgentArgs<ExtArgs>
  }
  export type MatchPlayerStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    Agent?: boolean | MatchPlayerStats$AgentArgs<ExtArgs>
  }
  export type MatchPlayerStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    Agent?: boolean | MatchPlayerStats$AgentArgs<ExtArgs>
  }

  export type $MatchPlayerStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchPlayerStats"
    objects: {
      matchParticipation: Prisma.$MatchParticipationPayload<ExtArgs>
      match: Prisma.$MatchPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
      Agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matchParticipationId: number
      matchId: number
      playerId: number
      agentId: string | null
      agentName: string | null
      score: number
      kills: number
      deaths: number
      assists: number
      headshots: number
      bodyshots: number
      legshots: number
      damageDealt: number
      damageReceived: number
      adr: number | null
      acs: number | null
      kd: number | null
      hsPercent: number | null
      kast: number | null
      firstKills: number | null
      firstDeaths: number | null
      grenadeCasts: number | null
      ability1Casts: number | null
      ability2Casts: number | null
      ultimateCasts: number | null
      spentOverall: number | null
      spentAverage: number | null
      loadoutOverall: number | null
      loadoutAverage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matchPlayerStats"]>
    composites: {}
  }

  type MatchPlayerStatsGetPayload<S extends boolean | null | undefined | MatchPlayerStatsDefaultArgs> = $Result.GetResult<Prisma.$MatchPlayerStatsPayload, S>

  type MatchPlayerStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchPlayerStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchPlayerStatsCountAggregateInputType | true
    }

  export interface MatchPlayerStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchPlayerStats'], meta: { name: 'MatchPlayerStats' } }
    /**
     * Find zero or one MatchPlayerStats that matches the filter.
     * @param {MatchPlayerStatsFindUniqueArgs} args - Arguments to find a MatchPlayerStats
     * @example
     * // Get one MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchPlayerStatsFindUniqueArgs>(args: SelectSubset<T, MatchPlayerStatsFindUniqueArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchPlayerStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchPlayerStatsFindUniqueOrThrowArgs} args - Arguments to find a MatchPlayerStats
     * @example
     * // Get one MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchPlayerStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchPlayerStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchPlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsFindFirstArgs} args - Arguments to find a MatchPlayerStats
     * @example
     * // Get one MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchPlayerStatsFindFirstArgs>(args?: SelectSubset<T, MatchPlayerStatsFindFirstArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchPlayerStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsFindFirstOrThrowArgs} args - Arguments to find a MatchPlayerStats
     * @example
     * // Get one MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchPlayerStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchPlayerStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchPlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.findMany()
     * 
     * // Get first 10 MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchPlayerStatsWithIdOnly = await prisma.matchPlayerStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchPlayerStatsFindManyArgs>(args?: SelectSubset<T, MatchPlayerStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchPlayerStats.
     * @param {MatchPlayerStatsCreateArgs} args - Arguments to create a MatchPlayerStats.
     * @example
     * // Create one MatchPlayerStats
     * const MatchPlayerStats = await prisma.matchPlayerStats.create({
     *   data: {
     *     // ... data to create a MatchPlayerStats
     *   }
     * })
     * 
     */
    create<T extends MatchPlayerStatsCreateArgs>(args: SelectSubset<T, MatchPlayerStatsCreateArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchPlayerStats.
     * @param {MatchPlayerStatsCreateManyArgs} args - Arguments to create many MatchPlayerStats.
     * @example
     * // Create many MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchPlayerStatsCreateManyArgs>(args?: SelectSubset<T, MatchPlayerStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchPlayerStats and returns the data saved in the database.
     * @param {MatchPlayerStatsCreateManyAndReturnArgs} args - Arguments to create many MatchPlayerStats.
     * @example
     * // Create many MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchPlayerStats and only return the `id`
     * const matchPlayerStatsWithIdOnly = await prisma.matchPlayerStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchPlayerStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchPlayerStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchPlayerStats.
     * @param {MatchPlayerStatsDeleteArgs} args - Arguments to delete one MatchPlayerStats.
     * @example
     * // Delete one MatchPlayerStats
     * const MatchPlayerStats = await prisma.matchPlayerStats.delete({
     *   where: {
     *     // ... filter to delete one MatchPlayerStats
     *   }
     * })
     * 
     */
    delete<T extends MatchPlayerStatsDeleteArgs>(args: SelectSubset<T, MatchPlayerStatsDeleteArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchPlayerStats.
     * @param {MatchPlayerStatsUpdateArgs} args - Arguments to update one MatchPlayerStats.
     * @example
     * // Update one MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchPlayerStatsUpdateArgs>(args: SelectSubset<T, MatchPlayerStatsUpdateArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchPlayerStats.
     * @param {MatchPlayerStatsDeleteManyArgs} args - Arguments to filter MatchPlayerStats to delete.
     * @example
     * // Delete a few MatchPlayerStats
     * const { count } = await prisma.matchPlayerStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchPlayerStatsDeleteManyArgs>(args?: SelectSubset<T, MatchPlayerStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchPlayerStatsUpdateManyArgs>(args: SelectSubset<T, MatchPlayerStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchPlayerStats and returns the data updated in the database.
     * @param {MatchPlayerStatsUpdateManyAndReturnArgs} args - Arguments to update many MatchPlayerStats.
     * @example
     * // Update many MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchPlayerStats and only return the `id`
     * const matchPlayerStatsWithIdOnly = await prisma.matchPlayerStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchPlayerStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchPlayerStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchPlayerStats.
     * @param {MatchPlayerStatsUpsertArgs} args - Arguments to update or create a MatchPlayerStats.
     * @example
     * // Update or create a MatchPlayerStats
     * const matchPlayerStats = await prisma.matchPlayerStats.upsert({
     *   create: {
     *     // ... data to create a MatchPlayerStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchPlayerStats we want to update
     *   }
     * })
     */
    upsert<T extends MatchPlayerStatsUpsertArgs>(args: SelectSubset<T, MatchPlayerStatsUpsertArgs<ExtArgs>>): Prisma__MatchPlayerStatsClient<$Result.GetResult<Prisma.$MatchPlayerStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsCountArgs} args - Arguments to filter MatchPlayerStats to count.
     * @example
     * // Count the number of MatchPlayerStats
     * const count = await prisma.matchPlayerStats.count({
     *   where: {
     *     // ... the filter for the MatchPlayerStats we want to count
     *   }
     * })
    **/
    count<T extends MatchPlayerStatsCountArgs>(
      args?: Subset<T, MatchPlayerStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchPlayerStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchPlayerStatsAggregateArgs>(args: Subset<T, MatchPlayerStatsAggregateArgs>): Prisma.PrismaPromise<GetMatchPlayerStatsAggregateType<T>>

    /**
     * Group by MatchPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchPlayerStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchPlayerStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchPlayerStatsGroupByArgs['orderBy'] }
        : { orderBy?: MatchPlayerStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchPlayerStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchPlayerStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchPlayerStats model
   */
  readonly fields: MatchPlayerStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchPlayerStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchPlayerStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    matchParticipation<T extends MatchParticipationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchParticipationDefaultArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Agent<T extends MatchPlayerStats$AgentArgs<ExtArgs> = {}>(args?: Subset<T, MatchPlayerStats$AgentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchPlayerStats model
   */
  interface MatchPlayerStatsFieldRefs {
    readonly id: FieldRef<"MatchPlayerStats", 'Int'>
    readonly matchParticipationId: FieldRef<"MatchPlayerStats", 'Int'>
    readonly matchId: FieldRef<"MatchPlayerStats", 'Int'>
    readonly playerId: FieldRef<"MatchPlayerStats", 'Int'>
    readonly agentId: FieldRef<"MatchPlayerStats", 'String'>
    readonly agentName: FieldRef<"MatchPlayerStats", 'String'>
    readonly score: FieldRef<"MatchPlayerStats", 'Int'>
    readonly kills: FieldRef<"MatchPlayerStats", 'Int'>
    readonly deaths: FieldRef<"MatchPlayerStats", 'Int'>
    readonly assists: FieldRef<"MatchPlayerStats", 'Int'>
    readonly headshots: FieldRef<"MatchPlayerStats", 'Int'>
    readonly bodyshots: FieldRef<"MatchPlayerStats", 'Int'>
    readonly legshots: FieldRef<"MatchPlayerStats", 'Int'>
    readonly damageDealt: FieldRef<"MatchPlayerStats", 'Int'>
    readonly damageReceived: FieldRef<"MatchPlayerStats", 'Int'>
    readonly adr: FieldRef<"MatchPlayerStats", 'Float'>
    readonly acs: FieldRef<"MatchPlayerStats", 'Float'>
    readonly kd: FieldRef<"MatchPlayerStats", 'Float'>
    readonly hsPercent: FieldRef<"MatchPlayerStats", 'Float'>
    readonly kast: FieldRef<"MatchPlayerStats", 'Float'>
    readonly firstKills: FieldRef<"MatchPlayerStats", 'Int'>
    readonly firstDeaths: FieldRef<"MatchPlayerStats", 'Int'>
    readonly grenadeCasts: FieldRef<"MatchPlayerStats", 'Int'>
    readonly ability1Casts: FieldRef<"MatchPlayerStats", 'Int'>
    readonly ability2Casts: FieldRef<"MatchPlayerStats", 'Int'>
    readonly ultimateCasts: FieldRef<"MatchPlayerStats", 'Int'>
    readonly spentOverall: FieldRef<"MatchPlayerStats", 'Int'>
    readonly spentAverage: FieldRef<"MatchPlayerStats", 'Float'>
    readonly loadoutOverall: FieldRef<"MatchPlayerStats", 'Int'>
    readonly loadoutAverage: FieldRef<"MatchPlayerStats", 'Float'>
    readonly createdAt: FieldRef<"MatchPlayerStats", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchPlayerStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchPlayerStats findUnique
   */
  export type MatchPlayerStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchPlayerStats to fetch.
     */
    where: MatchPlayerStatsWhereUniqueInput
  }

  /**
   * MatchPlayerStats findUniqueOrThrow
   */
  export type MatchPlayerStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchPlayerStats to fetch.
     */
    where: MatchPlayerStatsWhereUniqueInput
  }

  /**
   * MatchPlayerStats findFirst
   */
  export type MatchPlayerStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchPlayerStats to fetch.
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchPlayerStats to fetch.
     */
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchPlayerStats.
     */
    cursor?: MatchPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchPlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchPlayerStats.
     */
    distinct?: MatchPlayerStatsScalarFieldEnum | MatchPlayerStatsScalarFieldEnum[]
  }

  /**
   * MatchPlayerStats findFirstOrThrow
   */
  export type MatchPlayerStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchPlayerStats to fetch.
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchPlayerStats to fetch.
     */
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchPlayerStats.
     */
    cursor?: MatchPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchPlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchPlayerStats.
     */
    distinct?: MatchPlayerStatsScalarFieldEnum | MatchPlayerStatsScalarFieldEnum[]
  }

  /**
   * MatchPlayerStats findMany
   */
  export type MatchPlayerStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchPlayerStats to fetch.
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchPlayerStats to fetch.
     */
    orderBy?: MatchPlayerStatsOrderByWithRelationInput | MatchPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchPlayerStats.
     */
    cursor?: MatchPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchPlayerStats.
     */
    skip?: number
    distinct?: MatchPlayerStatsScalarFieldEnum | MatchPlayerStatsScalarFieldEnum[]
  }

  /**
   * MatchPlayerStats create
   */
  export type MatchPlayerStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchPlayerStats.
     */
    data: XOR<MatchPlayerStatsCreateInput, MatchPlayerStatsUncheckedCreateInput>
  }

  /**
   * MatchPlayerStats createMany
   */
  export type MatchPlayerStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchPlayerStats.
     */
    data: MatchPlayerStatsCreateManyInput | MatchPlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchPlayerStats createManyAndReturn
   */
  export type MatchPlayerStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * The data used to create many MatchPlayerStats.
     */
    data: MatchPlayerStatsCreateManyInput | MatchPlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchPlayerStats update
   */
  export type MatchPlayerStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchPlayerStats.
     */
    data: XOR<MatchPlayerStatsUpdateInput, MatchPlayerStatsUncheckedUpdateInput>
    /**
     * Choose, which MatchPlayerStats to update.
     */
    where: MatchPlayerStatsWhereUniqueInput
  }

  /**
   * MatchPlayerStats updateMany
   */
  export type MatchPlayerStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchPlayerStats.
     */
    data: XOR<MatchPlayerStatsUpdateManyMutationInput, MatchPlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which MatchPlayerStats to update
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * Limit how many MatchPlayerStats to update.
     */
    limit?: number
  }

  /**
   * MatchPlayerStats updateManyAndReturn
   */
  export type MatchPlayerStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * The data used to update MatchPlayerStats.
     */
    data: XOR<MatchPlayerStatsUpdateManyMutationInput, MatchPlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which MatchPlayerStats to update
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * Limit how many MatchPlayerStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchPlayerStats upsert
   */
  export type MatchPlayerStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchPlayerStats to update in case it exists.
     */
    where: MatchPlayerStatsWhereUniqueInput
    /**
     * In case the MatchPlayerStats found by the `where` argument doesn't exist, create a new MatchPlayerStats with this data.
     */
    create: XOR<MatchPlayerStatsCreateInput, MatchPlayerStatsUncheckedCreateInput>
    /**
     * In case the MatchPlayerStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchPlayerStatsUpdateInput, MatchPlayerStatsUncheckedUpdateInput>
  }

  /**
   * MatchPlayerStats delete
   */
  export type MatchPlayerStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter which MatchPlayerStats to delete.
     */
    where: MatchPlayerStatsWhereUniqueInput
  }

  /**
   * MatchPlayerStats deleteMany
   */
  export type MatchPlayerStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchPlayerStats to delete
     */
    where?: MatchPlayerStatsWhereInput
    /**
     * Limit how many MatchPlayerStats to delete.
     */
    limit?: number
  }

  /**
   * MatchPlayerStats.Agent
   */
  export type MatchPlayerStats$AgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * MatchPlayerStats without action
   */
  export type MatchPlayerStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchPlayerStats
     */
    select?: MatchPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchPlayerStats
     */
    omit?: MatchPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchPlayerStatsInclude<ExtArgs> | null
  }


  /**
   * Model MatchTeamStats
   */

  export type AggregateMatchTeamStats = {
    _count: MatchTeamStatsCountAggregateOutputType | null
    _avg: MatchTeamStatsAvgAggregateOutputType | null
    _sum: MatchTeamStatsSumAggregateOutputType | null
    _min: MatchTeamStatsMinAggregateOutputType | null
    _max: MatchTeamStatsMaxAggregateOutputType | null
  }

  export type MatchTeamStatsAvgAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    roundsWon: number | null
    roundsLost: number | null
  }

  export type MatchTeamStatsSumAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    roundsWon: number | null
    roundsLost: number | null
  }

  export type MatchTeamStatsMinAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    teamSide: string | null
    roundsWon: number | null
    roundsLost: number | null
    won: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchTeamStatsMaxAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    teamSide: string | null
    roundsWon: number | null
    roundsLost: number | null
    won: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchTeamStatsCountAggregateOutputType = {
    id: number
    matchId: number
    teamId: number
    teamSide: number
    roundsWon: number
    roundsLost: number
    won: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchTeamStatsAvgAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    roundsWon?: true
    roundsLost?: true
  }

  export type MatchTeamStatsSumAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    roundsWon?: true
    roundsLost?: true
  }

  export type MatchTeamStatsMinAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    teamSide?: true
    roundsWon?: true
    roundsLost?: true
    won?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchTeamStatsMaxAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    teamSide?: true
    roundsWon?: true
    roundsLost?: true
    won?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchTeamStatsCountAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    teamSide?: true
    roundsWon?: true
    roundsLost?: true
    won?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchTeamStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchTeamStats to aggregate.
     */
    where?: MatchTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchTeamStats to fetch.
     */
    orderBy?: MatchTeamStatsOrderByWithRelationInput | MatchTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchTeamStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchTeamStats
    **/
    _count?: true | MatchTeamStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchTeamStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchTeamStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchTeamStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchTeamStatsMaxAggregateInputType
  }

  export type GetMatchTeamStatsAggregateType<T extends MatchTeamStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchTeamStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchTeamStats[P]>
      : GetScalarType<T[P], AggregateMatchTeamStats[P]>
  }




  export type MatchTeamStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchTeamStatsWhereInput
    orderBy?: MatchTeamStatsOrderByWithAggregationInput | MatchTeamStatsOrderByWithAggregationInput[]
    by: MatchTeamStatsScalarFieldEnum[] | MatchTeamStatsScalarFieldEnum
    having?: MatchTeamStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchTeamStatsCountAggregateInputType | true
    _avg?: MatchTeamStatsAvgAggregateInputType
    _sum?: MatchTeamStatsSumAggregateInputType
    _min?: MatchTeamStatsMinAggregateInputType
    _max?: MatchTeamStatsMaxAggregateInputType
  }

  export type MatchTeamStatsGroupByOutputType = {
    id: number
    matchId: number
    teamId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt: Date
    updatedAt: Date
    _count: MatchTeamStatsCountAggregateOutputType | null
    _avg: MatchTeamStatsAvgAggregateOutputType | null
    _sum: MatchTeamStatsSumAggregateOutputType | null
    _min: MatchTeamStatsMinAggregateOutputType | null
    _max: MatchTeamStatsMaxAggregateOutputType | null
  }

  type GetMatchTeamStatsGroupByPayload<T extends MatchTeamStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchTeamStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchTeamStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchTeamStatsGroupByOutputType[P]>
            : GetScalarType<T[P], MatchTeamStatsGroupByOutputType[P]>
        }
      >
    >


  export type MatchTeamStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    teamSide?: boolean
    roundsWon?: boolean
    roundsLost?: boolean
    won?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchTeamStats"]>

  export type MatchTeamStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    teamSide?: boolean
    roundsWon?: boolean
    roundsLost?: boolean
    won?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchTeamStats"]>

  export type MatchTeamStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    teamSide?: boolean
    roundsWon?: boolean
    roundsLost?: boolean
    won?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchTeamStats"]>

  export type MatchTeamStatsSelectScalar = {
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    teamSide?: boolean
    roundsWon?: boolean
    roundsLost?: boolean
    won?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchTeamStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "teamId" | "teamSide" | "roundsWon" | "roundsLost" | "won" | "createdAt" | "updatedAt", ExtArgs["result"]["matchTeamStats"]>
  export type MatchTeamStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type MatchTeamStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type MatchTeamStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $MatchTeamStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchTeamStats"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matchId: number
      teamId: number
      teamSide: string
      roundsWon: number
      roundsLost: number
      won: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matchTeamStats"]>
    composites: {}
  }

  type MatchTeamStatsGetPayload<S extends boolean | null | undefined | MatchTeamStatsDefaultArgs> = $Result.GetResult<Prisma.$MatchTeamStatsPayload, S>

  type MatchTeamStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchTeamStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchTeamStatsCountAggregateInputType | true
    }

  export interface MatchTeamStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchTeamStats'], meta: { name: 'MatchTeamStats' } }
    /**
     * Find zero or one MatchTeamStats that matches the filter.
     * @param {MatchTeamStatsFindUniqueArgs} args - Arguments to find a MatchTeamStats
     * @example
     * // Get one MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchTeamStatsFindUniqueArgs>(args: SelectSubset<T, MatchTeamStatsFindUniqueArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchTeamStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchTeamStatsFindUniqueOrThrowArgs} args - Arguments to find a MatchTeamStats
     * @example
     * // Get one MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchTeamStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchTeamStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchTeamStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsFindFirstArgs} args - Arguments to find a MatchTeamStats
     * @example
     * // Get one MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchTeamStatsFindFirstArgs>(args?: SelectSubset<T, MatchTeamStatsFindFirstArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchTeamStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsFindFirstOrThrowArgs} args - Arguments to find a MatchTeamStats
     * @example
     * // Get one MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchTeamStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchTeamStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchTeamStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.findMany()
     * 
     * // Get first 10 MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchTeamStatsWithIdOnly = await prisma.matchTeamStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchTeamStatsFindManyArgs>(args?: SelectSubset<T, MatchTeamStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchTeamStats.
     * @param {MatchTeamStatsCreateArgs} args - Arguments to create a MatchTeamStats.
     * @example
     * // Create one MatchTeamStats
     * const MatchTeamStats = await prisma.matchTeamStats.create({
     *   data: {
     *     // ... data to create a MatchTeamStats
     *   }
     * })
     * 
     */
    create<T extends MatchTeamStatsCreateArgs>(args: SelectSubset<T, MatchTeamStatsCreateArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchTeamStats.
     * @param {MatchTeamStatsCreateManyArgs} args - Arguments to create many MatchTeamStats.
     * @example
     * // Create many MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchTeamStatsCreateManyArgs>(args?: SelectSubset<T, MatchTeamStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchTeamStats and returns the data saved in the database.
     * @param {MatchTeamStatsCreateManyAndReturnArgs} args - Arguments to create many MatchTeamStats.
     * @example
     * // Create many MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchTeamStats and only return the `id`
     * const matchTeamStatsWithIdOnly = await prisma.matchTeamStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchTeamStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchTeamStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchTeamStats.
     * @param {MatchTeamStatsDeleteArgs} args - Arguments to delete one MatchTeamStats.
     * @example
     * // Delete one MatchTeamStats
     * const MatchTeamStats = await prisma.matchTeamStats.delete({
     *   where: {
     *     // ... filter to delete one MatchTeamStats
     *   }
     * })
     * 
     */
    delete<T extends MatchTeamStatsDeleteArgs>(args: SelectSubset<T, MatchTeamStatsDeleteArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchTeamStats.
     * @param {MatchTeamStatsUpdateArgs} args - Arguments to update one MatchTeamStats.
     * @example
     * // Update one MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchTeamStatsUpdateArgs>(args: SelectSubset<T, MatchTeamStatsUpdateArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchTeamStats.
     * @param {MatchTeamStatsDeleteManyArgs} args - Arguments to filter MatchTeamStats to delete.
     * @example
     * // Delete a few MatchTeamStats
     * const { count } = await prisma.matchTeamStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchTeamStatsDeleteManyArgs>(args?: SelectSubset<T, MatchTeamStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchTeamStatsUpdateManyArgs>(args: SelectSubset<T, MatchTeamStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchTeamStats and returns the data updated in the database.
     * @param {MatchTeamStatsUpdateManyAndReturnArgs} args - Arguments to update many MatchTeamStats.
     * @example
     * // Update many MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchTeamStats and only return the `id`
     * const matchTeamStatsWithIdOnly = await prisma.matchTeamStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchTeamStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchTeamStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchTeamStats.
     * @param {MatchTeamStatsUpsertArgs} args - Arguments to update or create a MatchTeamStats.
     * @example
     * // Update or create a MatchTeamStats
     * const matchTeamStats = await prisma.matchTeamStats.upsert({
     *   create: {
     *     // ... data to create a MatchTeamStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchTeamStats we want to update
     *   }
     * })
     */
    upsert<T extends MatchTeamStatsUpsertArgs>(args: SelectSubset<T, MatchTeamStatsUpsertArgs<ExtArgs>>): Prisma__MatchTeamStatsClient<$Result.GetResult<Prisma.$MatchTeamStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsCountArgs} args - Arguments to filter MatchTeamStats to count.
     * @example
     * // Count the number of MatchTeamStats
     * const count = await prisma.matchTeamStats.count({
     *   where: {
     *     // ... the filter for the MatchTeamStats we want to count
     *   }
     * })
    **/
    count<T extends MatchTeamStatsCountArgs>(
      args?: Subset<T, MatchTeamStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchTeamStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchTeamStatsAggregateArgs>(args: Subset<T, MatchTeamStatsAggregateArgs>): Prisma.PrismaPromise<GetMatchTeamStatsAggregateType<T>>

    /**
     * Group by MatchTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchTeamStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchTeamStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchTeamStatsGroupByArgs['orderBy'] }
        : { orderBy?: MatchTeamStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchTeamStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchTeamStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchTeamStats model
   */
  readonly fields: MatchTeamStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchTeamStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchTeamStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchTeamStats model
   */
  interface MatchTeamStatsFieldRefs {
    readonly id: FieldRef<"MatchTeamStats", 'Int'>
    readonly matchId: FieldRef<"MatchTeamStats", 'Int'>
    readonly teamId: FieldRef<"MatchTeamStats", 'Int'>
    readonly teamSide: FieldRef<"MatchTeamStats", 'String'>
    readonly roundsWon: FieldRef<"MatchTeamStats", 'Int'>
    readonly roundsLost: FieldRef<"MatchTeamStats", 'Int'>
    readonly won: FieldRef<"MatchTeamStats", 'Boolean'>
    readonly createdAt: FieldRef<"MatchTeamStats", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchTeamStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchTeamStats findUnique
   */
  export type MatchTeamStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchTeamStats to fetch.
     */
    where: MatchTeamStatsWhereUniqueInput
  }

  /**
   * MatchTeamStats findUniqueOrThrow
   */
  export type MatchTeamStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchTeamStats to fetch.
     */
    where: MatchTeamStatsWhereUniqueInput
  }

  /**
   * MatchTeamStats findFirst
   */
  export type MatchTeamStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchTeamStats to fetch.
     */
    where?: MatchTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchTeamStats to fetch.
     */
    orderBy?: MatchTeamStatsOrderByWithRelationInput | MatchTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchTeamStats.
     */
    cursor?: MatchTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchTeamStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchTeamStats.
     */
    distinct?: MatchTeamStatsScalarFieldEnum | MatchTeamStatsScalarFieldEnum[]
  }

  /**
   * MatchTeamStats findFirstOrThrow
   */
  export type MatchTeamStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchTeamStats to fetch.
     */
    where?: MatchTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchTeamStats to fetch.
     */
    orderBy?: MatchTeamStatsOrderByWithRelationInput | MatchTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchTeamStats.
     */
    cursor?: MatchTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchTeamStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchTeamStats.
     */
    distinct?: MatchTeamStatsScalarFieldEnum | MatchTeamStatsScalarFieldEnum[]
  }

  /**
   * MatchTeamStats findMany
   */
  export type MatchTeamStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which MatchTeamStats to fetch.
     */
    where?: MatchTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchTeamStats to fetch.
     */
    orderBy?: MatchTeamStatsOrderByWithRelationInput | MatchTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchTeamStats.
     */
    cursor?: MatchTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchTeamStats.
     */
    skip?: number
    distinct?: MatchTeamStatsScalarFieldEnum | MatchTeamStatsScalarFieldEnum[]
  }

  /**
   * MatchTeamStats create
   */
  export type MatchTeamStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchTeamStats.
     */
    data: XOR<MatchTeamStatsCreateInput, MatchTeamStatsUncheckedCreateInput>
  }

  /**
   * MatchTeamStats createMany
   */
  export type MatchTeamStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchTeamStats.
     */
    data: MatchTeamStatsCreateManyInput | MatchTeamStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchTeamStats createManyAndReturn
   */
  export type MatchTeamStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * The data used to create many MatchTeamStats.
     */
    data: MatchTeamStatsCreateManyInput | MatchTeamStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchTeamStats update
   */
  export type MatchTeamStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchTeamStats.
     */
    data: XOR<MatchTeamStatsUpdateInput, MatchTeamStatsUncheckedUpdateInput>
    /**
     * Choose, which MatchTeamStats to update.
     */
    where: MatchTeamStatsWhereUniqueInput
  }

  /**
   * MatchTeamStats updateMany
   */
  export type MatchTeamStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchTeamStats.
     */
    data: XOR<MatchTeamStatsUpdateManyMutationInput, MatchTeamStatsUncheckedUpdateManyInput>
    /**
     * Filter which MatchTeamStats to update
     */
    where?: MatchTeamStatsWhereInput
    /**
     * Limit how many MatchTeamStats to update.
     */
    limit?: number
  }

  /**
   * MatchTeamStats updateManyAndReturn
   */
  export type MatchTeamStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * The data used to update MatchTeamStats.
     */
    data: XOR<MatchTeamStatsUpdateManyMutationInput, MatchTeamStatsUncheckedUpdateManyInput>
    /**
     * Filter which MatchTeamStats to update
     */
    where?: MatchTeamStatsWhereInput
    /**
     * Limit how many MatchTeamStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchTeamStats upsert
   */
  export type MatchTeamStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchTeamStats to update in case it exists.
     */
    where: MatchTeamStatsWhereUniqueInput
    /**
     * In case the MatchTeamStats found by the `where` argument doesn't exist, create a new MatchTeamStats with this data.
     */
    create: XOR<MatchTeamStatsCreateInput, MatchTeamStatsUncheckedCreateInput>
    /**
     * In case the MatchTeamStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchTeamStatsUpdateInput, MatchTeamStatsUncheckedUpdateInput>
  }

  /**
   * MatchTeamStats delete
   */
  export type MatchTeamStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
    /**
     * Filter which MatchTeamStats to delete.
     */
    where: MatchTeamStatsWhereUniqueInput
  }

  /**
   * MatchTeamStats deleteMany
   */
  export type MatchTeamStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchTeamStats to delete
     */
    where?: MatchTeamStatsWhereInput
    /**
     * Limit how many MatchTeamStats to delete.
     */
    limit?: number
  }

  /**
   * MatchTeamStats without action
   */
  export type MatchTeamStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchTeamStats
     */
    select?: MatchTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchTeamStats
     */
    omit?: MatchTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchTeamStatsInclude<ExtArgs> | null
  }


  /**
   * Model Round
   */

  export type AggregateRound = {
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  export type RoundAvgAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
  }

  export type RoundSumAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
  }

  export type RoundMinAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
    result: string | null
    winningTeam: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoundMaxAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
    result: string | null
    winningTeam: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoundCountAggregateOutputType = {
    id: number
    matchId: number
    roundNumber: number
    result: number
    winningTeam: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoundAvgAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
  }

  export type RoundSumAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
  }

  export type RoundMinAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    result?: true
    winningTeam?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoundMaxAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    result?: true
    winningTeam?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoundCountAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    result?: true
    winningTeam?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Round to aggregate.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rounds
    **/
    _count?: true | RoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundMaxAggregateInputType
  }

  export type GetRoundAggregateType<T extends RoundAggregateArgs> = {
        [P in keyof T & keyof AggregateRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRound[P]>
      : GetScalarType<T[P], AggregateRound[P]>
  }




  export type RoundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundWhereInput
    orderBy?: RoundOrderByWithAggregationInput | RoundOrderByWithAggregationInput[]
    by: RoundScalarFieldEnum[] | RoundScalarFieldEnum
    having?: RoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundCountAggregateInputType | true
    _avg?: RoundAvgAggregateInputType
    _sum?: RoundSumAggregateInputType
    _min?: RoundMinAggregateInputType
    _max?: RoundMaxAggregateInputType
  }

  export type RoundGroupByOutputType = {
    id: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt: Date
    updatedAt: Date
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  type GetRoundGroupByPayload<T extends RoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundGroupByOutputType[P]>
            : GetScalarType<T[P], RoundGroupByOutputType[P]>
        }
      >
    >


  export type RoundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    result?: boolean
    winningTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    plant?: boolean | Round$plantArgs<ExtArgs>
    defuse?: boolean | Round$defuseArgs<ExtArgs>
    playerStats?: boolean | Round$playerStatsArgs<ExtArgs>
    teamStats?: boolean | Round$teamStatsArgs<ExtArgs>
    _count?: boolean | RoundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["round"]>

  export type RoundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    result?: boolean
    winningTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["round"]>

  export type RoundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    result?: boolean
    winningTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["round"]>

  export type RoundSelectScalar = {
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    result?: boolean
    winningTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "roundNumber" | "result" | "winningTeam" | "createdAt" | "updatedAt", ExtArgs["result"]["round"]>
  export type RoundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    plant?: boolean | Round$plantArgs<ExtArgs>
    defuse?: boolean | Round$defuseArgs<ExtArgs>
    playerStats?: boolean | Round$playerStatsArgs<ExtArgs>
    teamStats?: boolean | Round$teamStatsArgs<ExtArgs>
    _count?: boolean | RoundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }
  export type RoundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }

  export type $RoundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Round"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      plant: Prisma.$PlantPayload<ExtArgs> | null
      defuse: Prisma.$DefusePayload<ExtArgs> | null
      playerStats: Prisma.$RoundPlayerStatsPayload<ExtArgs>[]
      teamStats: Prisma.$RoundTeamStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matchId: number
      roundNumber: number
      result: string
      winningTeam: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["round"]>
    composites: {}
  }

  type RoundGetPayload<S extends boolean | null | undefined | RoundDefaultArgs> = $Result.GetResult<Prisma.$RoundPayload, S>

  type RoundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoundCountAggregateInputType | true
    }

  export interface RoundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Round'], meta: { name: 'Round' } }
    /**
     * Find zero or one Round that matches the filter.
     * @param {RoundFindUniqueArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoundFindUniqueArgs>(args: SelectSubset<T, RoundFindUniqueArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Round that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoundFindUniqueOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoundFindUniqueOrThrowArgs>(args: SelectSubset<T, RoundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Round that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoundFindFirstArgs>(args?: SelectSubset<T, RoundFindFirstArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Round that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoundFindFirstOrThrowArgs>(args?: SelectSubset<T, RoundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rounds
     * const rounds = await prisma.round.findMany()
     * 
     * // Get first 10 Rounds
     * const rounds = await prisma.round.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundWithIdOnly = await prisma.round.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoundFindManyArgs>(args?: SelectSubset<T, RoundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Round.
     * @param {RoundCreateArgs} args - Arguments to create a Round.
     * @example
     * // Create one Round
     * const Round = await prisma.round.create({
     *   data: {
     *     // ... data to create a Round
     *   }
     * })
     * 
     */
    create<T extends RoundCreateArgs>(args: SelectSubset<T, RoundCreateArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rounds.
     * @param {RoundCreateManyArgs} args - Arguments to create many Rounds.
     * @example
     * // Create many Rounds
     * const round = await prisma.round.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoundCreateManyArgs>(args?: SelectSubset<T, RoundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rounds and returns the data saved in the database.
     * @param {RoundCreateManyAndReturnArgs} args - Arguments to create many Rounds.
     * @example
     * // Create many Rounds
     * const round = await prisma.round.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rounds and only return the `id`
     * const roundWithIdOnly = await prisma.round.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoundCreateManyAndReturnArgs>(args?: SelectSubset<T, RoundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Round.
     * @param {RoundDeleteArgs} args - Arguments to delete one Round.
     * @example
     * // Delete one Round
     * const Round = await prisma.round.delete({
     *   where: {
     *     // ... filter to delete one Round
     *   }
     * })
     * 
     */
    delete<T extends RoundDeleteArgs>(args: SelectSubset<T, RoundDeleteArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Round.
     * @param {RoundUpdateArgs} args - Arguments to update one Round.
     * @example
     * // Update one Round
     * const round = await prisma.round.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoundUpdateArgs>(args: SelectSubset<T, RoundUpdateArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rounds.
     * @param {RoundDeleteManyArgs} args - Arguments to filter Rounds to delete.
     * @example
     * // Delete a few Rounds
     * const { count } = await prisma.round.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoundDeleteManyArgs>(args?: SelectSubset<T, RoundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rounds
     * const round = await prisma.round.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoundUpdateManyArgs>(args: SelectSubset<T, RoundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rounds and returns the data updated in the database.
     * @param {RoundUpdateManyAndReturnArgs} args - Arguments to update many Rounds.
     * @example
     * // Update many Rounds
     * const round = await prisma.round.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rounds and only return the `id`
     * const roundWithIdOnly = await prisma.round.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoundUpdateManyAndReturnArgs>(args: SelectSubset<T, RoundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Round.
     * @param {RoundUpsertArgs} args - Arguments to update or create a Round.
     * @example
     * // Update or create a Round
     * const round = await prisma.round.upsert({
     *   create: {
     *     // ... data to create a Round
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Round we want to update
     *   }
     * })
     */
    upsert<T extends RoundUpsertArgs>(args: SelectSubset<T, RoundUpsertArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundCountArgs} args - Arguments to filter Rounds to count.
     * @example
     * // Count the number of Rounds
     * const count = await prisma.round.count({
     *   where: {
     *     // ... the filter for the Rounds we want to count
     *   }
     * })
    **/
    count<T extends RoundCountArgs>(
      args?: Subset<T, RoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundAggregateArgs>(args: Subset<T, RoundAggregateArgs>): Prisma.PrismaPromise<GetRoundAggregateType<T>>

    /**
     * Group by Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundGroupByArgs['orderBy'] }
        : { orderBy?: RoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Round model
   */
  readonly fields: RoundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Round.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plant<T extends Round$plantArgs<ExtArgs> = {}>(args?: Subset<T, Round$plantArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    defuse<T extends Round$defuseArgs<ExtArgs> = {}>(args?: Subset<T, Round$defuseArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playerStats<T extends Round$playerStatsArgs<ExtArgs> = {}>(args?: Subset<T, Round$playerStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamStats<T extends Round$teamStatsArgs<ExtArgs> = {}>(args?: Subset<T, Round$teamStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Round model
   */
  interface RoundFieldRefs {
    readonly id: FieldRef<"Round", 'Int'>
    readonly matchId: FieldRef<"Round", 'Int'>
    readonly roundNumber: FieldRef<"Round", 'Int'>
    readonly result: FieldRef<"Round", 'String'>
    readonly winningTeam: FieldRef<"Round", 'String'>
    readonly createdAt: FieldRef<"Round", 'DateTime'>
    readonly updatedAt: FieldRef<"Round", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Round findUnique
   */
  export type RoundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round findUniqueOrThrow
   */
  export type RoundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round findFirst
   */
  export type RoundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Round findFirstOrThrow
   */
  export type RoundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Round findMany
   */
  export type RoundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Rounds to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Round create
   */
  export type RoundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * The data needed to create a Round.
     */
    data: XOR<RoundCreateInput, RoundUncheckedCreateInput>
  }

  /**
   * Round createMany
   */
  export type RoundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rounds.
     */
    data: RoundCreateManyInput | RoundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Round createManyAndReturn
   */
  export type RoundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * The data used to create many Rounds.
     */
    data: RoundCreateManyInput | RoundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Round update
   */
  export type RoundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * The data needed to update a Round.
     */
    data: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
    /**
     * Choose, which Round to update.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round updateMany
   */
  export type RoundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rounds.
     */
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyInput>
    /**
     * Filter which Rounds to update
     */
    where?: RoundWhereInput
    /**
     * Limit how many Rounds to update.
     */
    limit?: number
  }

  /**
   * Round updateManyAndReturn
   */
  export type RoundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * The data used to update Rounds.
     */
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyInput>
    /**
     * Filter which Rounds to update
     */
    where?: RoundWhereInput
    /**
     * Limit how many Rounds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Round upsert
   */
  export type RoundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * The filter to search for the Round to update in case it exists.
     */
    where: RoundWhereUniqueInput
    /**
     * In case the Round found by the `where` argument doesn't exist, create a new Round with this data.
     */
    create: XOR<RoundCreateInput, RoundUncheckedCreateInput>
    /**
     * In case the Round was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
  }

  /**
   * Round delete
   */
  export type RoundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter which Round to delete.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round deleteMany
   */
  export type RoundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rounds to delete
     */
    where?: RoundWhereInput
    /**
     * Limit how many Rounds to delete.
     */
    limit?: number
  }

  /**
   * Round.plant
   */
  export type Round$plantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    where?: PlantWhereInput
  }

  /**
   * Round.defuse
   */
  export type Round$defuseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    where?: DefuseWhereInput
  }

  /**
   * Round.playerStats
   */
  export type Round$playerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    where?: RoundPlayerStatsWhereInput
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    cursor?: RoundPlayerStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundPlayerStatsScalarFieldEnum | RoundPlayerStatsScalarFieldEnum[]
  }

  /**
   * Round.teamStats
   */
  export type Round$teamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    where?: RoundTeamStatsWhereInput
    orderBy?: RoundTeamStatsOrderByWithRelationInput | RoundTeamStatsOrderByWithRelationInput[]
    cursor?: RoundTeamStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundTeamStatsScalarFieldEnum | RoundTeamStatsScalarFieldEnum[]
  }

  /**
   * Round without action
   */
  export type RoundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
  }


  /**
   * Model Plant
   */

  export type AggregatePlant = {
    _count: PlantCountAggregateOutputType | null
    _avg: PlantAvgAggregateOutputType | null
    _sum: PlantSumAggregateOutputType | null
    _min: PlantMinAggregateOutputType | null
    _max: PlantMaxAggregateOutputType | null
  }

  export type PlantAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    locationX: number | null
    locationY: number | null
  }

  export type PlantSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    locationX: number | null
    locationY: number | null
  }

  export type PlantMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    site: string | null
    locationX: number | null
    locationY: number | null
  }

  export type PlantMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    site: string | null
    locationX: number | null
    locationY: number | null
  }

  export type PlantCountAggregateOutputType = {
    id: number
    roundId: number
    playerId: number
    roundTimeMs: number
    site: number
    locationX: number
    locationY: number
    _all: number
  }


  export type PlantAvgAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
  }

  export type PlantSumAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
  }

  export type PlantMinAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    site?: true
    locationX?: true
    locationY?: true
  }

  export type PlantMaxAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    site?: true
    locationX?: true
    locationY?: true
  }

  export type PlantCountAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    site?: true
    locationX?: true
    locationY?: true
    _all?: true
  }

  export type PlantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plant to aggregate.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plants
    **/
    _count?: true | PlantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantMaxAggregateInputType
  }

  export type GetPlantAggregateType<T extends PlantAggregateArgs> = {
        [P in keyof T & keyof AggregatePlant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlant[P]>
      : GetScalarType<T[P], AggregatePlant[P]>
  }




  export type PlantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantWhereInput
    orderBy?: PlantOrderByWithAggregationInput | PlantOrderByWithAggregationInput[]
    by: PlantScalarFieldEnum[] | PlantScalarFieldEnum
    having?: PlantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantCountAggregateInputType | true
    _avg?: PlantAvgAggregateInputType
    _sum?: PlantSumAggregateInputType
    _min?: PlantMinAggregateInputType
    _max?: PlantMaxAggregateInputType
  }

  export type PlantGroupByOutputType = {
    id: number
    roundId: number
    playerId: number
    roundTimeMs: number
    site: string
    locationX: number | null
    locationY: number | null
    _count: PlantCountAggregateOutputType | null
    _avg: PlantAvgAggregateOutputType | null
    _sum: PlantSumAggregateOutputType | null
    _min: PlantMinAggregateOutputType | null
    _max: PlantMaxAggregateOutputType | null
  }

  type GetPlantGroupByPayload<T extends PlantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantGroupByOutputType[P]>
            : GetScalarType<T[P], PlantGroupByOutputType[P]>
        }
      >
    >


  export type PlantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    site?: boolean
    locationX?: boolean
    locationY?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    site?: boolean
    locationX?: boolean
    locationY?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    site?: boolean
    locationX?: boolean
    locationY?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectScalar = {
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    site?: boolean
    locationX?: boolean
    locationY?: boolean
  }

  export type PlantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roundId" | "playerId" | "roundTimeMs" | "site" | "locationX" | "locationY", ExtArgs["result"]["plant"]>
  export type PlantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PlantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plant"
    objects: {
      round: Prisma.$RoundPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundId: number
      playerId: number
      roundTimeMs: number
      site: string
      locationX: number | null
      locationY: number | null
    }, ExtArgs["result"]["plant"]>
    composites: {}
  }

  type PlantGetPayload<S extends boolean | null | undefined | PlantDefaultArgs> = $Result.GetResult<Prisma.$PlantPayload, S>

  type PlantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantCountAggregateInputType | true
    }

  export interface PlantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plant'], meta: { name: 'Plant' } }
    /**
     * Find zero or one Plant that matches the filter.
     * @param {PlantFindUniqueArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantFindUniqueArgs>(args: SelectSubset<T, PlantFindUniqueArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantFindUniqueOrThrowArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindFirstArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantFindFirstArgs>(args?: SelectSubset<T, PlantFindFirstArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindFirstOrThrowArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plants
     * const plants = await prisma.plant.findMany()
     * 
     * // Get first 10 Plants
     * const plants = await prisma.plant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantWithIdOnly = await prisma.plant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantFindManyArgs>(args?: SelectSubset<T, PlantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plant.
     * @param {PlantCreateArgs} args - Arguments to create a Plant.
     * @example
     * // Create one Plant
     * const Plant = await prisma.plant.create({
     *   data: {
     *     // ... data to create a Plant
     *   }
     * })
     * 
     */
    create<T extends PlantCreateArgs>(args: SelectSubset<T, PlantCreateArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plants.
     * @param {PlantCreateManyArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plant = await prisma.plant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantCreateManyArgs>(args?: SelectSubset<T, PlantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plants and returns the data saved in the database.
     * @param {PlantCreateManyAndReturnArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plant = await prisma.plant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plants and only return the `id`
     * const plantWithIdOnly = await prisma.plant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plant.
     * @param {PlantDeleteArgs} args - Arguments to delete one Plant.
     * @example
     * // Delete one Plant
     * const Plant = await prisma.plant.delete({
     *   where: {
     *     // ... filter to delete one Plant
     *   }
     * })
     * 
     */
    delete<T extends PlantDeleteArgs>(args: SelectSubset<T, PlantDeleteArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plant.
     * @param {PlantUpdateArgs} args - Arguments to update one Plant.
     * @example
     * // Update one Plant
     * const plant = await prisma.plant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantUpdateArgs>(args: SelectSubset<T, PlantUpdateArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plants.
     * @param {PlantDeleteManyArgs} args - Arguments to filter Plants to delete.
     * @example
     * // Delete a few Plants
     * const { count } = await prisma.plant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantDeleteManyArgs>(args?: SelectSubset<T, PlantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plants
     * const plant = await prisma.plant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantUpdateManyArgs>(args: SelectSubset<T, PlantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants and returns the data updated in the database.
     * @param {PlantUpdateManyAndReturnArgs} args - Arguments to update many Plants.
     * @example
     * // Update many Plants
     * const plant = await prisma.plant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plants and only return the `id`
     * const plantWithIdOnly = await prisma.plant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plant.
     * @param {PlantUpsertArgs} args - Arguments to update or create a Plant.
     * @example
     * // Update or create a Plant
     * const plant = await prisma.plant.upsert({
     *   create: {
     *     // ... data to create a Plant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plant we want to update
     *   }
     * })
     */
    upsert<T extends PlantUpsertArgs>(args: SelectSubset<T, PlantUpsertArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCountArgs} args - Arguments to filter Plants to count.
     * @example
     * // Count the number of Plants
     * const count = await prisma.plant.count({
     *   where: {
     *     // ... the filter for the Plants we want to count
     *   }
     * })
    **/
    count<T extends PlantCountArgs>(
      args?: Subset<T, PlantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantAggregateArgs>(args: Subset<T, PlantAggregateArgs>): Prisma.PrismaPromise<GetPlantAggregateType<T>>

    /**
     * Group by Plant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantGroupByArgs['orderBy'] }
        : { orderBy?: PlantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plant model
   */
  readonly fields: PlantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    round<T extends RoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundDefaultArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plant model
   */
  interface PlantFieldRefs {
    readonly id: FieldRef<"Plant", 'Int'>
    readonly roundId: FieldRef<"Plant", 'Int'>
    readonly playerId: FieldRef<"Plant", 'Int'>
    readonly roundTimeMs: FieldRef<"Plant", 'Int'>
    readonly site: FieldRef<"Plant", 'String'>
    readonly locationX: FieldRef<"Plant", 'Float'>
    readonly locationY: FieldRef<"Plant", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Plant findUnique
   */
  export type PlantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant findUniqueOrThrow
   */
  export type PlantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant findFirst
   */
  export type PlantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plants.
     */
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant findFirstOrThrow
   */
  export type PlantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plants.
     */
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant findMany
   */
  export type PlantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plants to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant create
   */
  export type PlantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The data needed to create a Plant.
     */
    data: XOR<PlantCreateInput, PlantUncheckedCreateInput>
  }

  /**
   * Plant createMany
   */
  export type PlantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plants.
     */
    data: PlantCreateManyInput | PlantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plant createManyAndReturn
   */
  export type PlantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * The data used to create many Plants.
     */
    data: PlantCreateManyInput | PlantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plant update
   */
  export type PlantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The data needed to update a Plant.
     */
    data: XOR<PlantUpdateInput, PlantUncheckedUpdateInput>
    /**
     * Choose, which Plant to update.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant updateMany
   */
  export type PlantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plants.
     */
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyInput>
    /**
     * Filter which Plants to update
     */
    where?: PlantWhereInput
    /**
     * Limit how many Plants to update.
     */
    limit?: number
  }

  /**
   * Plant updateManyAndReturn
   */
  export type PlantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * The data used to update Plants.
     */
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyInput>
    /**
     * Filter which Plants to update
     */
    where?: PlantWhereInput
    /**
     * Limit how many Plants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plant upsert
   */
  export type PlantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The filter to search for the Plant to update in case it exists.
     */
    where: PlantWhereUniqueInput
    /**
     * In case the Plant found by the `where` argument doesn't exist, create a new Plant with this data.
     */
    create: XOR<PlantCreateInput, PlantUncheckedCreateInput>
    /**
     * In case the Plant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantUpdateInput, PlantUncheckedUpdateInput>
  }

  /**
   * Plant delete
   */
  export type PlantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter which Plant to delete.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant deleteMany
   */
  export type PlantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plants to delete
     */
    where?: PlantWhereInput
    /**
     * Limit how many Plants to delete.
     */
    limit?: number
  }

  /**
   * Plant without action
   */
  export type PlantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
  }


  /**
   * Model Defuse
   */

  export type AggregateDefuse = {
    _count: DefuseCountAggregateOutputType | null
    _avg: DefuseAvgAggregateOutputType | null
    _sum: DefuseSumAggregateOutputType | null
    _min: DefuseMinAggregateOutputType | null
    _max: DefuseMaxAggregateOutputType | null
  }

  export type DefuseAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    locationX: number | null
    locationY: number | null
  }

  export type DefuseSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    locationX: number | null
    locationY: number | null
  }

  export type DefuseMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    locationX: number | null
    locationY: number | null
  }

  export type DefuseMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    playerId: number | null
    roundTimeMs: number | null
    locationX: number | null
    locationY: number | null
  }

  export type DefuseCountAggregateOutputType = {
    id: number
    roundId: number
    playerId: number
    roundTimeMs: number
    locationX: number
    locationY: number
    _all: number
  }


  export type DefuseAvgAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
  }

  export type DefuseSumAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
  }

  export type DefuseMinAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
  }

  export type DefuseMaxAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
  }

  export type DefuseCountAggregateInputType = {
    id?: true
    roundId?: true
    playerId?: true
    roundTimeMs?: true
    locationX?: true
    locationY?: true
    _all?: true
  }

  export type DefuseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defuse to aggregate.
     */
    where?: DefuseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defuses to fetch.
     */
    orderBy?: DefuseOrderByWithRelationInput | DefuseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefuseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Defuses
    **/
    _count?: true | DefuseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefuseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefuseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefuseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefuseMaxAggregateInputType
  }

  export type GetDefuseAggregateType<T extends DefuseAggregateArgs> = {
        [P in keyof T & keyof AggregateDefuse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefuse[P]>
      : GetScalarType<T[P], AggregateDefuse[P]>
  }




  export type DefuseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefuseWhereInput
    orderBy?: DefuseOrderByWithAggregationInput | DefuseOrderByWithAggregationInput[]
    by: DefuseScalarFieldEnum[] | DefuseScalarFieldEnum
    having?: DefuseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefuseCountAggregateInputType | true
    _avg?: DefuseAvgAggregateInputType
    _sum?: DefuseSumAggregateInputType
    _min?: DefuseMinAggregateInputType
    _max?: DefuseMaxAggregateInputType
  }

  export type DefuseGroupByOutputType = {
    id: number
    roundId: number
    playerId: number
    roundTimeMs: number
    locationX: number | null
    locationY: number | null
    _count: DefuseCountAggregateOutputType | null
    _avg: DefuseAvgAggregateOutputType | null
    _sum: DefuseSumAggregateOutputType | null
    _min: DefuseMinAggregateOutputType | null
    _max: DefuseMaxAggregateOutputType | null
  }

  type GetDefuseGroupByPayload<T extends DefuseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefuseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefuseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefuseGroupByOutputType[P]>
            : GetScalarType<T[P], DefuseGroupByOutputType[P]>
        }
      >
    >


  export type DefuseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    locationX?: boolean
    locationY?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defuse"]>

  export type DefuseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    locationX?: boolean
    locationY?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defuse"]>

  export type DefuseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    locationX?: boolean
    locationY?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defuse"]>

  export type DefuseSelectScalar = {
    id?: boolean
    roundId?: boolean
    playerId?: boolean
    roundTimeMs?: boolean
    locationX?: boolean
    locationY?: boolean
  }

  export type DefuseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roundId" | "playerId" | "roundTimeMs" | "locationX" | "locationY", ExtArgs["result"]["defuse"]>
  export type DefuseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type DefuseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type DefuseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $DefusePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Defuse"
    objects: {
      round: Prisma.$RoundPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundId: number
      playerId: number
      roundTimeMs: number
      locationX: number | null
      locationY: number | null
    }, ExtArgs["result"]["defuse"]>
    composites: {}
  }

  type DefuseGetPayload<S extends boolean | null | undefined | DefuseDefaultArgs> = $Result.GetResult<Prisma.$DefusePayload, S>

  type DefuseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefuseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefuseCountAggregateInputType | true
    }

  export interface DefuseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Defuse'], meta: { name: 'Defuse' } }
    /**
     * Find zero or one Defuse that matches the filter.
     * @param {DefuseFindUniqueArgs} args - Arguments to find a Defuse
     * @example
     * // Get one Defuse
     * const defuse = await prisma.defuse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefuseFindUniqueArgs>(args: SelectSubset<T, DefuseFindUniqueArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Defuse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefuseFindUniqueOrThrowArgs} args - Arguments to find a Defuse
     * @example
     * // Get one Defuse
     * const defuse = await prisma.defuse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefuseFindUniqueOrThrowArgs>(args: SelectSubset<T, DefuseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Defuse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseFindFirstArgs} args - Arguments to find a Defuse
     * @example
     * // Get one Defuse
     * const defuse = await prisma.defuse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefuseFindFirstArgs>(args?: SelectSubset<T, DefuseFindFirstArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Defuse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseFindFirstOrThrowArgs} args - Arguments to find a Defuse
     * @example
     * // Get one Defuse
     * const defuse = await prisma.defuse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefuseFindFirstOrThrowArgs>(args?: SelectSubset<T, DefuseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Defuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defuses
     * const defuses = await prisma.defuse.findMany()
     * 
     * // Get first 10 Defuses
     * const defuses = await prisma.defuse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defuseWithIdOnly = await prisma.defuse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefuseFindManyArgs>(args?: SelectSubset<T, DefuseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Defuse.
     * @param {DefuseCreateArgs} args - Arguments to create a Defuse.
     * @example
     * // Create one Defuse
     * const Defuse = await prisma.defuse.create({
     *   data: {
     *     // ... data to create a Defuse
     *   }
     * })
     * 
     */
    create<T extends DefuseCreateArgs>(args: SelectSubset<T, DefuseCreateArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Defuses.
     * @param {DefuseCreateManyArgs} args - Arguments to create many Defuses.
     * @example
     * // Create many Defuses
     * const defuse = await prisma.defuse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefuseCreateManyArgs>(args?: SelectSubset<T, DefuseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Defuses and returns the data saved in the database.
     * @param {DefuseCreateManyAndReturnArgs} args - Arguments to create many Defuses.
     * @example
     * // Create many Defuses
     * const defuse = await prisma.defuse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Defuses and only return the `id`
     * const defuseWithIdOnly = await prisma.defuse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefuseCreateManyAndReturnArgs>(args?: SelectSubset<T, DefuseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Defuse.
     * @param {DefuseDeleteArgs} args - Arguments to delete one Defuse.
     * @example
     * // Delete one Defuse
     * const Defuse = await prisma.defuse.delete({
     *   where: {
     *     // ... filter to delete one Defuse
     *   }
     * })
     * 
     */
    delete<T extends DefuseDeleteArgs>(args: SelectSubset<T, DefuseDeleteArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Defuse.
     * @param {DefuseUpdateArgs} args - Arguments to update one Defuse.
     * @example
     * // Update one Defuse
     * const defuse = await prisma.defuse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefuseUpdateArgs>(args: SelectSubset<T, DefuseUpdateArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Defuses.
     * @param {DefuseDeleteManyArgs} args - Arguments to filter Defuses to delete.
     * @example
     * // Delete a few Defuses
     * const { count } = await prisma.defuse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefuseDeleteManyArgs>(args?: SelectSubset<T, DefuseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defuses
     * const defuse = await prisma.defuse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefuseUpdateManyArgs>(args: SelectSubset<T, DefuseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defuses and returns the data updated in the database.
     * @param {DefuseUpdateManyAndReturnArgs} args - Arguments to update many Defuses.
     * @example
     * // Update many Defuses
     * const defuse = await prisma.defuse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Defuses and only return the `id`
     * const defuseWithIdOnly = await prisma.defuse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DefuseUpdateManyAndReturnArgs>(args: SelectSubset<T, DefuseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Defuse.
     * @param {DefuseUpsertArgs} args - Arguments to update or create a Defuse.
     * @example
     * // Update or create a Defuse
     * const defuse = await prisma.defuse.upsert({
     *   create: {
     *     // ... data to create a Defuse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defuse we want to update
     *   }
     * })
     */
    upsert<T extends DefuseUpsertArgs>(args: SelectSubset<T, DefuseUpsertArgs<ExtArgs>>): Prisma__DefuseClient<$Result.GetResult<Prisma.$DefusePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Defuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseCountArgs} args - Arguments to filter Defuses to count.
     * @example
     * // Count the number of Defuses
     * const count = await prisma.defuse.count({
     *   where: {
     *     // ... the filter for the Defuses we want to count
     *   }
     * })
    **/
    count<T extends DefuseCountArgs>(
      args?: Subset<T, DefuseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefuseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defuse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefuseAggregateArgs>(args: Subset<T, DefuseAggregateArgs>): Prisma.PrismaPromise<GetDefuseAggregateType<T>>

    /**
     * Group by Defuse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefuseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefuseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefuseGroupByArgs['orderBy'] }
        : { orderBy?: DefuseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefuseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefuseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Defuse model
   */
  readonly fields: DefuseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Defuse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefuseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    round<T extends RoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundDefaultArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Defuse model
   */
  interface DefuseFieldRefs {
    readonly id: FieldRef<"Defuse", 'Int'>
    readonly roundId: FieldRef<"Defuse", 'Int'>
    readonly playerId: FieldRef<"Defuse", 'Int'>
    readonly roundTimeMs: FieldRef<"Defuse", 'Int'>
    readonly locationX: FieldRef<"Defuse", 'Float'>
    readonly locationY: FieldRef<"Defuse", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Defuse findUnique
   */
  export type DefuseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * Filter, which Defuse to fetch.
     */
    where: DefuseWhereUniqueInput
  }

  /**
   * Defuse findUniqueOrThrow
   */
  export type DefuseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * Filter, which Defuse to fetch.
     */
    where: DefuseWhereUniqueInput
  }

  /**
   * Defuse findFirst
   */
  export type DefuseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * Filter, which Defuse to fetch.
     */
    where?: DefuseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defuses to fetch.
     */
    orderBy?: DefuseOrderByWithRelationInput | DefuseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defuses.
     */
    cursor?: DefuseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defuses.
     */
    distinct?: DefuseScalarFieldEnum | DefuseScalarFieldEnum[]
  }

  /**
   * Defuse findFirstOrThrow
   */
  export type DefuseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * Filter, which Defuse to fetch.
     */
    where?: DefuseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defuses to fetch.
     */
    orderBy?: DefuseOrderByWithRelationInput | DefuseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defuses.
     */
    cursor?: DefuseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defuses.
     */
    distinct?: DefuseScalarFieldEnum | DefuseScalarFieldEnum[]
  }

  /**
   * Defuse findMany
   */
  export type DefuseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * Filter, which Defuses to fetch.
     */
    where?: DefuseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defuses to fetch.
     */
    orderBy?: DefuseOrderByWithRelationInput | DefuseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Defuses.
     */
    cursor?: DefuseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defuses.
     */
    skip?: number
    distinct?: DefuseScalarFieldEnum | DefuseScalarFieldEnum[]
  }

  /**
   * Defuse create
   */
  export type DefuseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * The data needed to create a Defuse.
     */
    data: XOR<DefuseCreateInput, DefuseUncheckedCreateInput>
  }

  /**
   * Defuse createMany
   */
  export type DefuseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Defuses.
     */
    data: DefuseCreateManyInput | DefuseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Defuse createManyAndReturn
   */
  export type DefuseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * The data used to create many Defuses.
     */
    data: DefuseCreateManyInput | DefuseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Defuse update
   */
  export type DefuseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * The data needed to update a Defuse.
     */
    data: XOR<DefuseUpdateInput, DefuseUncheckedUpdateInput>
    /**
     * Choose, which Defuse to update.
     */
    where: DefuseWhereUniqueInput
  }

  /**
   * Defuse updateMany
   */
  export type DefuseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Defuses.
     */
    data: XOR<DefuseUpdateManyMutationInput, DefuseUncheckedUpdateManyInput>
    /**
     * Filter which Defuses to update
     */
    where?: DefuseWhereInput
    /**
     * Limit how many Defuses to update.
     */
    limit?: number
  }

  /**
   * Defuse updateManyAndReturn
   */
  export type DefuseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * The data used to update Defuses.
     */
    data: XOR<DefuseUpdateManyMutationInput, DefuseUncheckedUpdateManyInput>
    /**
     * Filter which Defuses to update
     */
    where?: DefuseWhereInput
    /**
     * Limit how many Defuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Defuse upsert
   */
  export type DefuseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * The filter to search for the Defuse to update in case it exists.
     */
    where: DefuseWhereUniqueInput
    /**
     * In case the Defuse found by the `where` argument doesn't exist, create a new Defuse with this data.
     */
    create: XOR<DefuseCreateInput, DefuseUncheckedCreateInput>
    /**
     * In case the Defuse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefuseUpdateInput, DefuseUncheckedUpdateInput>
  }

  /**
   * Defuse delete
   */
  export type DefuseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
    /**
     * Filter which Defuse to delete.
     */
    where: DefuseWhereUniqueInput
  }

  /**
   * Defuse deleteMany
   */
  export type DefuseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defuses to delete
     */
    where?: DefuseWhereInput
    /**
     * Limit how many Defuses to delete.
     */
    limit?: number
  }

  /**
   * Defuse without action
   */
  export type DefuseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defuse
     */
    select?: DefuseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Defuse
     */
    omit?: DefuseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefuseInclude<ExtArgs> | null
  }


  /**
   * Model RoundPlayerStats
   */

  export type AggregateRoundPlayerStats = {
    _count: RoundPlayerStatsCountAggregateOutputType | null
    _avg: RoundPlayerStatsAvgAggregateOutputType | null
    _sum: RoundPlayerStatsSumAggregateOutputType | null
    _min: RoundPlayerStatsMinAggregateOutputType | null
    _max: RoundPlayerStatsMaxAggregateOutputType | null
  }

  export type RoundPlayerStatsAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    matchParticipationId: number | null
    playerId: number | null
    score: number | null
    kills: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    loadoutValue: number | null
    creditsRemaining: number | null
  }

  export type RoundPlayerStatsSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    matchParticipationId: number | null
    playerId: number | null
    score: number | null
    kills: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    loadoutValue: number | null
    creditsRemaining: number | null
  }

  export type RoundPlayerStatsMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    matchParticipationId: number | null
    playerId: number | null
    score: number | null
    kills: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    loadoutValue: number | null
    creditsRemaining: number | null
    weaponId: string | null
    weaponName: string | null
    armorId: string | null
    armorName: string | null
    createdAt: Date | null
  }

  export type RoundPlayerStatsMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    matchParticipationId: number | null
    playerId: number | null
    score: number | null
    kills: number | null
    headshots: number | null
    bodyshots: number | null
    legshots: number | null
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    loadoutValue: number | null
    creditsRemaining: number | null
    weaponId: string | null
    weaponName: string | null
    armorId: string | null
    armorName: string | null
    createdAt: Date | null
  }

  export type RoundPlayerStatsCountAggregateOutputType = {
    id: number
    roundId: number
    matchParticipationId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts: number
    ability1Casts: number
    ability2Casts: number
    ultimateCasts: number
    loadoutValue: number
    creditsRemaining: number
    weaponId: number
    weaponName: number
    armorId: number
    armorName: number
    createdAt: number
    _all: number
  }


  export type RoundPlayerStatsAvgAggregateInputType = {
    id?: true
    roundId?: true
    matchParticipationId?: true
    playerId?: true
    score?: true
    kills?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    loadoutValue?: true
    creditsRemaining?: true
  }

  export type RoundPlayerStatsSumAggregateInputType = {
    id?: true
    roundId?: true
    matchParticipationId?: true
    playerId?: true
    score?: true
    kills?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    loadoutValue?: true
    creditsRemaining?: true
  }

  export type RoundPlayerStatsMinAggregateInputType = {
    id?: true
    roundId?: true
    matchParticipationId?: true
    playerId?: true
    score?: true
    kills?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    loadoutValue?: true
    creditsRemaining?: true
    weaponId?: true
    weaponName?: true
    armorId?: true
    armorName?: true
    createdAt?: true
  }

  export type RoundPlayerStatsMaxAggregateInputType = {
    id?: true
    roundId?: true
    matchParticipationId?: true
    playerId?: true
    score?: true
    kills?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    loadoutValue?: true
    creditsRemaining?: true
    weaponId?: true
    weaponName?: true
    armorId?: true
    armorName?: true
    createdAt?: true
  }

  export type RoundPlayerStatsCountAggregateInputType = {
    id?: true
    roundId?: true
    matchParticipationId?: true
    playerId?: true
    score?: true
    kills?: true
    headshots?: true
    bodyshots?: true
    legshots?: true
    grenadeCasts?: true
    ability1Casts?: true
    ability2Casts?: true
    ultimateCasts?: true
    loadoutValue?: true
    creditsRemaining?: true
    weaponId?: true
    weaponName?: true
    armorId?: true
    armorName?: true
    createdAt?: true
    _all?: true
  }

  export type RoundPlayerStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoundPlayerStats to aggregate.
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundPlayerStats to fetch.
     */
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundPlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoundPlayerStats
    **/
    _count?: true | RoundPlayerStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundPlayerStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundPlayerStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundPlayerStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundPlayerStatsMaxAggregateInputType
  }

  export type GetRoundPlayerStatsAggregateType<T extends RoundPlayerStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateRoundPlayerStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoundPlayerStats[P]>
      : GetScalarType<T[P], AggregateRoundPlayerStats[P]>
  }




  export type RoundPlayerStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundPlayerStatsWhereInput
    orderBy?: RoundPlayerStatsOrderByWithAggregationInput | RoundPlayerStatsOrderByWithAggregationInput[]
    by: RoundPlayerStatsScalarFieldEnum[] | RoundPlayerStatsScalarFieldEnum
    having?: RoundPlayerStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundPlayerStatsCountAggregateInputType | true
    _avg?: RoundPlayerStatsAvgAggregateInputType
    _sum?: RoundPlayerStatsSumAggregateInputType
    _min?: RoundPlayerStatsMinAggregateInputType
    _max?: RoundPlayerStatsMaxAggregateInputType
  }

  export type RoundPlayerStatsGroupByOutputType = {
    id: number
    roundId: number
    matchParticipationId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts: number | null
    ability1Casts: number | null
    ability2Casts: number | null
    ultimateCasts: number | null
    loadoutValue: number | null
    creditsRemaining: number | null
    weaponId: string | null
    weaponName: string | null
    armorId: string | null
    armorName: string | null
    createdAt: Date
    _count: RoundPlayerStatsCountAggregateOutputType | null
    _avg: RoundPlayerStatsAvgAggregateOutputType | null
    _sum: RoundPlayerStatsSumAggregateOutputType | null
    _min: RoundPlayerStatsMinAggregateOutputType | null
    _max: RoundPlayerStatsMaxAggregateOutputType | null
  }

  type GetRoundPlayerStatsGroupByPayload<T extends RoundPlayerStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoundPlayerStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundPlayerStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundPlayerStatsGroupByOutputType[P]>
            : GetScalarType<T[P], RoundPlayerStatsGroupByOutputType[P]>
        }
      >
    >


  export type RoundPlayerStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    matchParticipationId?: boolean
    playerId?: boolean
    score?: boolean
    kills?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    loadoutValue?: boolean
    creditsRemaining?: boolean
    weaponId?: boolean
    weaponName?: boolean
    armorId?: boolean
    armorName?: boolean
    createdAt?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundPlayerStats"]>

  export type RoundPlayerStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    matchParticipationId?: boolean
    playerId?: boolean
    score?: boolean
    kills?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    loadoutValue?: boolean
    creditsRemaining?: boolean
    weaponId?: boolean
    weaponName?: boolean
    armorId?: boolean
    armorName?: boolean
    createdAt?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundPlayerStats"]>

  export type RoundPlayerStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    matchParticipationId?: boolean
    playerId?: boolean
    score?: boolean
    kills?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    loadoutValue?: boolean
    creditsRemaining?: boolean
    weaponId?: boolean
    weaponName?: boolean
    armorId?: boolean
    armorName?: boolean
    createdAt?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundPlayerStats"]>

  export type RoundPlayerStatsSelectScalar = {
    id?: boolean
    roundId?: boolean
    matchParticipationId?: boolean
    playerId?: boolean
    score?: boolean
    kills?: boolean
    headshots?: boolean
    bodyshots?: boolean
    legshots?: boolean
    grenadeCasts?: boolean
    ability1Casts?: boolean
    ability2Casts?: boolean
    ultimateCasts?: boolean
    loadoutValue?: boolean
    creditsRemaining?: boolean
    weaponId?: boolean
    weaponName?: boolean
    armorId?: boolean
    armorName?: boolean
    createdAt?: boolean
  }

  export type RoundPlayerStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roundId" | "matchParticipationId" | "playerId" | "score" | "kills" | "headshots" | "bodyshots" | "legshots" | "grenadeCasts" | "ability1Casts" | "ability2Casts" | "ultimateCasts" | "loadoutValue" | "creditsRemaining" | "weaponId" | "weaponName" | "armorId" | "armorName" | "createdAt", ExtArgs["result"]["roundPlayerStats"]>
  export type RoundPlayerStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type RoundPlayerStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type RoundPlayerStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    matchParticipation?: boolean | MatchParticipationDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $RoundPlayerStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoundPlayerStats"
    objects: {
      round: Prisma.$RoundPayload<ExtArgs>
      matchParticipation: Prisma.$MatchParticipationPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundId: number
      matchParticipationId: number
      playerId: number
      score: number
      kills: number
      headshots: number
      bodyshots: number
      legshots: number
      grenadeCasts: number | null
      ability1Casts: number | null
      ability2Casts: number | null
      ultimateCasts: number | null
      loadoutValue: number | null
      creditsRemaining: number | null
      weaponId: string | null
      weaponName: string | null
      armorId: string | null
      armorName: string | null
      createdAt: Date
    }, ExtArgs["result"]["roundPlayerStats"]>
    composites: {}
  }

  type RoundPlayerStatsGetPayload<S extends boolean | null | undefined | RoundPlayerStatsDefaultArgs> = $Result.GetResult<Prisma.$RoundPlayerStatsPayload, S>

  type RoundPlayerStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoundPlayerStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoundPlayerStatsCountAggregateInputType | true
    }

  export interface RoundPlayerStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoundPlayerStats'], meta: { name: 'RoundPlayerStats' } }
    /**
     * Find zero or one RoundPlayerStats that matches the filter.
     * @param {RoundPlayerStatsFindUniqueArgs} args - Arguments to find a RoundPlayerStats
     * @example
     * // Get one RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoundPlayerStatsFindUniqueArgs>(args: SelectSubset<T, RoundPlayerStatsFindUniqueArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoundPlayerStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoundPlayerStatsFindUniqueOrThrowArgs} args - Arguments to find a RoundPlayerStats
     * @example
     * // Get one RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoundPlayerStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, RoundPlayerStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoundPlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsFindFirstArgs} args - Arguments to find a RoundPlayerStats
     * @example
     * // Get one RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoundPlayerStatsFindFirstArgs>(args?: SelectSubset<T, RoundPlayerStatsFindFirstArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoundPlayerStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsFindFirstOrThrowArgs} args - Arguments to find a RoundPlayerStats
     * @example
     * // Get one RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoundPlayerStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, RoundPlayerStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoundPlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.findMany()
     * 
     * // Get first 10 RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundPlayerStatsWithIdOnly = await prisma.roundPlayerStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoundPlayerStatsFindManyArgs>(args?: SelectSubset<T, RoundPlayerStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoundPlayerStats.
     * @param {RoundPlayerStatsCreateArgs} args - Arguments to create a RoundPlayerStats.
     * @example
     * // Create one RoundPlayerStats
     * const RoundPlayerStats = await prisma.roundPlayerStats.create({
     *   data: {
     *     // ... data to create a RoundPlayerStats
     *   }
     * })
     * 
     */
    create<T extends RoundPlayerStatsCreateArgs>(args: SelectSubset<T, RoundPlayerStatsCreateArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoundPlayerStats.
     * @param {RoundPlayerStatsCreateManyArgs} args - Arguments to create many RoundPlayerStats.
     * @example
     * // Create many RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoundPlayerStatsCreateManyArgs>(args?: SelectSubset<T, RoundPlayerStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoundPlayerStats and returns the data saved in the database.
     * @param {RoundPlayerStatsCreateManyAndReturnArgs} args - Arguments to create many RoundPlayerStats.
     * @example
     * // Create many RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoundPlayerStats and only return the `id`
     * const roundPlayerStatsWithIdOnly = await prisma.roundPlayerStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoundPlayerStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, RoundPlayerStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoundPlayerStats.
     * @param {RoundPlayerStatsDeleteArgs} args - Arguments to delete one RoundPlayerStats.
     * @example
     * // Delete one RoundPlayerStats
     * const RoundPlayerStats = await prisma.roundPlayerStats.delete({
     *   where: {
     *     // ... filter to delete one RoundPlayerStats
     *   }
     * })
     * 
     */
    delete<T extends RoundPlayerStatsDeleteArgs>(args: SelectSubset<T, RoundPlayerStatsDeleteArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoundPlayerStats.
     * @param {RoundPlayerStatsUpdateArgs} args - Arguments to update one RoundPlayerStats.
     * @example
     * // Update one RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoundPlayerStatsUpdateArgs>(args: SelectSubset<T, RoundPlayerStatsUpdateArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoundPlayerStats.
     * @param {RoundPlayerStatsDeleteManyArgs} args - Arguments to filter RoundPlayerStats to delete.
     * @example
     * // Delete a few RoundPlayerStats
     * const { count } = await prisma.roundPlayerStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoundPlayerStatsDeleteManyArgs>(args?: SelectSubset<T, RoundPlayerStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoundPlayerStatsUpdateManyArgs>(args: SelectSubset<T, RoundPlayerStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundPlayerStats and returns the data updated in the database.
     * @param {RoundPlayerStatsUpdateManyAndReturnArgs} args - Arguments to update many RoundPlayerStats.
     * @example
     * // Update many RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoundPlayerStats and only return the `id`
     * const roundPlayerStatsWithIdOnly = await prisma.roundPlayerStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoundPlayerStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, RoundPlayerStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoundPlayerStats.
     * @param {RoundPlayerStatsUpsertArgs} args - Arguments to update or create a RoundPlayerStats.
     * @example
     * // Update or create a RoundPlayerStats
     * const roundPlayerStats = await prisma.roundPlayerStats.upsert({
     *   create: {
     *     // ... data to create a RoundPlayerStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoundPlayerStats we want to update
     *   }
     * })
     */
    upsert<T extends RoundPlayerStatsUpsertArgs>(args: SelectSubset<T, RoundPlayerStatsUpsertArgs<ExtArgs>>): Prisma__RoundPlayerStatsClient<$Result.GetResult<Prisma.$RoundPlayerStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoundPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsCountArgs} args - Arguments to filter RoundPlayerStats to count.
     * @example
     * // Count the number of RoundPlayerStats
     * const count = await prisma.roundPlayerStats.count({
     *   where: {
     *     // ... the filter for the RoundPlayerStats we want to count
     *   }
     * })
    **/
    count<T extends RoundPlayerStatsCountArgs>(
      args?: Subset<T, RoundPlayerStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundPlayerStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoundPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundPlayerStatsAggregateArgs>(args: Subset<T, RoundPlayerStatsAggregateArgs>): Prisma.PrismaPromise<GetRoundPlayerStatsAggregateType<T>>

    /**
     * Group by RoundPlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundPlayerStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundPlayerStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundPlayerStatsGroupByArgs['orderBy'] }
        : { orderBy?: RoundPlayerStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundPlayerStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundPlayerStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoundPlayerStats model
   */
  readonly fields: RoundPlayerStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoundPlayerStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoundPlayerStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    round<T extends RoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundDefaultArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    matchParticipation<T extends MatchParticipationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchParticipationDefaultArgs<ExtArgs>>): Prisma__MatchParticipationClient<$Result.GetResult<Prisma.$MatchParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoundPlayerStats model
   */
  interface RoundPlayerStatsFieldRefs {
    readonly id: FieldRef<"RoundPlayerStats", 'Int'>
    readonly roundId: FieldRef<"RoundPlayerStats", 'Int'>
    readonly matchParticipationId: FieldRef<"RoundPlayerStats", 'Int'>
    readonly playerId: FieldRef<"RoundPlayerStats", 'Int'>
    readonly score: FieldRef<"RoundPlayerStats", 'Int'>
    readonly kills: FieldRef<"RoundPlayerStats", 'Int'>
    readonly headshots: FieldRef<"RoundPlayerStats", 'Int'>
    readonly bodyshots: FieldRef<"RoundPlayerStats", 'Int'>
    readonly legshots: FieldRef<"RoundPlayerStats", 'Int'>
    readonly grenadeCasts: FieldRef<"RoundPlayerStats", 'Int'>
    readonly ability1Casts: FieldRef<"RoundPlayerStats", 'Int'>
    readonly ability2Casts: FieldRef<"RoundPlayerStats", 'Int'>
    readonly ultimateCasts: FieldRef<"RoundPlayerStats", 'Int'>
    readonly loadoutValue: FieldRef<"RoundPlayerStats", 'Int'>
    readonly creditsRemaining: FieldRef<"RoundPlayerStats", 'Int'>
    readonly weaponId: FieldRef<"RoundPlayerStats", 'String'>
    readonly weaponName: FieldRef<"RoundPlayerStats", 'String'>
    readonly armorId: FieldRef<"RoundPlayerStats", 'String'>
    readonly armorName: FieldRef<"RoundPlayerStats", 'String'>
    readonly createdAt: FieldRef<"RoundPlayerStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoundPlayerStats findUnique
   */
  export type RoundPlayerStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundPlayerStats to fetch.
     */
    where: RoundPlayerStatsWhereUniqueInput
  }

  /**
   * RoundPlayerStats findUniqueOrThrow
   */
  export type RoundPlayerStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundPlayerStats to fetch.
     */
    where: RoundPlayerStatsWhereUniqueInput
  }

  /**
   * RoundPlayerStats findFirst
   */
  export type RoundPlayerStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundPlayerStats to fetch.
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundPlayerStats to fetch.
     */
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoundPlayerStats.
     */
    cursor?: RoundPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundPlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoundPlayerStats.
     */
    distinct?: RoundPlayerStatsScalarFieldEnum | RoundPlayerStatsScalarFieldEnum[]
  }

  /**
   * RoundPlayerStats findFirstOrThrow
   */
  export type RoundPlayerStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundPlayerStats to fetch.
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundPlayerStats to fetch.
     */
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoundPlayerStats.
     */
    cursor?: RoundPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundPlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoundPlayerStats.
     */
    distinct?: RoundPlayerStatsScalarFieldEnum | RoundPlayerStatsScalarFieldEnum[]
  }

  /**
   * RoundPlayerStats findMany
   */
  export type RoundPlayerStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundPlayerStats to fetch.
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundPlayerStats to fetch.
     */
    orderBy?: RoundPlayerStatsOrderByWithRelationInput | RoundPlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoundPlayerStats.
     */
    cursor?: RoundPlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundPlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundPlayerStats.
     */
    skip?: number
    distinct?: RoundPlayerStatsScalarFieldEnum | RoundPlayerStatsScalarFieldEnum[]
  }

  /**
   * RoundPlayerStats create
   */
  export type RoundPlayerStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a RoundPlayerStats.
     */
    data: XOR<RoundPlayerStatsCreateInput, RoundPlayerStatsUncheckedCreateInput>
  }

  /**
   * RoundPlayerStats createMany
   */
  export type RoundPlayerStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoundPlayerStats.
     */
    data: RoundPlayerStatsCreateManyInput | RoundPlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoundPlayerStats createManyAndReturn
   */
  export type RoundPlayerStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * The data used to create many RoundPlayerStats.
     */
    data: RoundPlayerStatsCreateManyInput | RoundPlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoundPlayerStats update
   */
  export type RoundPlayerStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a RoundPlayerStats.
     */
    data: XOR<RoundPlayerStatsUpdateInput, RoundPlayerStatsUncheckedUpdateInput>
    /**
     * Choose, which RoundPlayerStats to update.
     */
    where: RoundPlayerStatsWhereUniqueInput
  }

  /**
   * RoundPlayerStats updateMany
   */
  export type RoundPlayerStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoundPlayerStats.
     */
    data: XOR<RoundPlayerStatsUpdateManyMutationInput, RoundPlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which RoundPlayerStats to update
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * Limit how many RoundPlayerStats to update.
     */
    limit?: number
  }

  /**
   * RoundPlayerStats updateManyAndReturn
   */
  export type RoundPlayerStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * The data used to update RoundPlayerStats.
     */
    data: XOR<RoundPlayerStatsUpdateManyMutationInput, RoundPlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which RoundPlayerStats to update
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * Limit how many RoundPlayerStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoundPlayerStats upsert
   */
  export type RoundPlayerStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the RoundPlayerStats to update in case it exists.
     */
    where: RoundPlayerStatsWhereUniqueInput
    /**
     * In case the RoundPlayerStats found by the `where` argument doesn't exist, create a new RoundPlayerStats with this data.
     */
    create: XOR<RoundPlayerStatsCreateInput, RoundPlayerStatsUncheckedCreateInput>
    /**
     * In case the RoundPlayerStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundPlayerStatsUpdateInput, RoundPlayerStatsUncheckedUpdateInput>
  }

  /**
   * RoundPlayerStats delete
   */
  export type RoundPlayerStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
    /**
     * Filter which RoundPlayerStats to delete.
     */
    where: RoundPlayerStatsWhereUniqueInput
  }

  /**
   * RoundPlayerStats deleteMany
   */
  export type RoundPlayerStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoundPlayerStats to delete
     */
    where?: RoundPlayerStatsWhereInput
    /**
     * Limit how many RoundPlayerStats to delete.
     */
    limit?: number
  }

  /**
   * RoundPlayerStats without action
   */
  export type RoundPlayerStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundPlayerStats
     */
    select?: RoundPlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundPlayerStats
     */
    omit?: RoundPlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundPlayerStatsInclude<ExtArgs> | null
  }


  /**
   * Model RoundTeamStats
   */

  export type AggregateRoundTeamStats = {
    _count: RoundTeamStatsCountAggregateOutputType | null
    _avg: RoundTeamStatsAvgAggregateOutputType | null
    _sum: RoundTeamStatsSumAggregateOutputType | null
    _min: RoundTeamStatsMinAggregateOutputType | null
    _max: RoundTeamStatsMaxAggregateOutputType | null
  }

  export type RoundTeamStatsAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    teamId: number | null
  }

  export type RoundTeamStatsSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    teamId: number | null
  }

  export type RoundTeamStatsMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    teamId: number | null
    teamSide: string | null
    won: boolean | null
  }

  export type RoundTeamStatsMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    teamId: number | null
    teamSide: string | null
    won: boolean | null
  }

  export type RoundTeamStatsCountAggregateOutputType = {
    id: number
    roundId: number
    teamId: number
    teamSide: number
    won: number
    _all: number
  }


  export type RoundTeamStatsAvgAggregateInputType = {
    id?: true
    roundId?: true
    teamId?: true
  }

  export type RoundTeamStatsSumAggregateInputType = {
    id?: true
    roundId?: true
    teamId?: true
  }

  export type RoundTeamStatsMinAggregateInputType = {
    id?: true
    roundId?: true
    teamId?: true
    teamSide?: true
    won?: true
  }

  export type RoundTeamStatsMaxAggregateInputType = {
    id?: true
    roundId?: true
    teamId?: true
    teamSide?: true
    won?: true
  }

  export type RoundTeamStatsCountAggregateInputType = {
    id?: true
    roundId?: true
    teamId?: true
    teamSide?: true
    won?: true
    _all?: true
  }

  export type RoundTeamStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoundTeamStats to aggregate.
     */
    where?: RoundTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundTeamStats to fetch.
     */
    orderBy?: RoundTeamStatsOrderByWithRelationInput | RoundTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundTeamStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoundTeamStats
    **/
    _count?: true | RoundTeamStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundTeamStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundTeamStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundTeamStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundTeamStatsMaxAggregateInputType
  }

  export type GetRoundTeamStatsAggregateType<T extends RoundTeamStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateRoundTeamStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoundTeamStats[P]>
      : GetScalarType<T[P], AggregateRoundTeamStats[P]>
  }




  export type RoundTeamStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundTeamStatsWhereInput
    orderBy?: RoundTeamStatsOrderByWithAggregationInput | RoundTeamStatsOrderByWithAggregationInput[]
    by: RoundTeamStatsScalarFieldEnum[] | RoundTeamStatsScalarFieldEnum
    having?: RoundTeamStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundTeamStatsCountAggregateInputType | true
    _avg?: RoundTeamStatsAvgAggregateInputType
    _sum?: RoundTeamStatsSumAggregateInputType
    _min?: RoundTeamStatsMinAggregateInputType
    _max?: RoundTeamStatsMaxAggregateInputType
  }

  export type RoundTeamStatsGroupByOutputType = {
    id: number
    roundId: number
    teamId: number
    teamSide: string
    won: boolean
    _count: RoundTeamStatsCountAggregateOutputType | null
    _avg: RoundTeamStatsAvgAggregateOutputType | null
    _sum: RoundTeamStatsSumAggregateOutputType | null
    _min: RoundTeamStatsMinAggregateOutputType | null
    _max: RoundTeamStatsMaxAggregateOutputType | null
  }

  type GetRoundTeamStatsGroupByPayload<T extends RoundTeamStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoundTeamStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundTeamStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundTeamStatsGroupByOutputType[P]>
            : GetScalarType<T[P], RoundTeamStatsGroupByOutputType[P]>
        }
      >
    >


  export type RoundTeamStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    teamId?: boolean
    teamSide?: boolean
    won?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundTeamStats"]>

  export type RoundTeamStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    teamId?: boolean
    teamSide?: boolean
    won?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundTeamStats"]>

  export type RoundTeamStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    teamId?: boolean
    teamSide?: boolean
    won?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundTeamStats"]>

  export type RoundTeamStatsSelectScalar = {
    id?: boolean
    roundId?: boolean
    teamId?: boolean
    teamSide?: boolean
    won?: boolean
  }

  export type RoundTeamStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roundId" | "teamId" | "teamSide" | "won", ExtArgs["result"]["roundTeamStats"]>
  export type RoundTeamStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type RoundTeamStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type RoundTeamStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $RoundTeamStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoundTeamStats"
    objects: {
      round: Prisma.$RoundPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundId: number
      teamId: number
      teamSide: string
      won: boolean
    }, ExtArgs["result"]["roundTeamStats"]>
    composites: {}
  }

  type RoundTeamStatsGetPayload<S extends boolean | null | undefined | RoundTeamStatsDefaultArgs> = $Result.GetResult<Prisma.$RoundTeamStatsPayload, S>

  type RoundTeamStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoundTeamStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoundTeamStatsCountAggregateInputType | true
    }

  export interface RoundTeamStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoundTeamStats'], meta: { name: 'RoundTeamStats' } }
    /**
     * Find zero or one RoundTeamStats that matches the filter.
     * @param {RoundTeamStatsFindUniqueArgs} args - Arguments to find a RoundTeamStats
     * @example
     * // Get one RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoundTeamStatsFindUniqueArgs>(args: SelectSubset<T, RoundTeamStatsFindUniqueArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoundTeamStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoundTeamStatsFindUniqueOrThrowArgs} args - Arguments to find a RoundTeamStats
     * @example
     * // Get one RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoundTeamStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, RoundTeamStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoundTeamStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsFindFirstArgs} args - Arguments to find a RoundTeamStats
     * @example
     * // Get one RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoundTeamStatsFindFirstArgs>(args?: SelectSubset<T, RoundTeamStatsFindFirstArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoundTeamStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsFindFirstOrThrowArgs} args - Arguments to find a RoundTeamStats
     * @example
     * // Get one RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoundTeamStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, RoundTeamStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoundTeamStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.findMany()
     * 
     * // Get first 10 RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundTeamStatsWithIdOnly = await prisma.roundTeamStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoundTeamStatsFindManyArgs>(args?: SelectSubset<T, RoundTeamStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoundTeamStats.
     * @param {RoundTeamStatsCreateArgs} args - Arguments to create a RoundTeamStats.
     * @example
     * // Create one RoundTeamStats
     * const RoundTeamStats = await prisma.roundTeamStats.create({
     *   data: {
     *     // ... data to create a RoundTeamStats
     *   }
     * })
     * 
     */
    create<T extends RoundTeamStatsCreateArgs>(args: SelectSubset<T, RoundTeamStatsCreateArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoundTeamStats.
     * @param {RoundTeamStatsCreateManyArgs} args - Arguments to create many RoundTeamStats.
     * @example
     * // Create many RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoundTeamStatsCreateManyArgs>(args?: SelectSubset<T, RoundTeamStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoundTeamStats and returns the data saved in the database.
     * @param {RoundTeamStatsCreateManyAndReturnArgs} args - Arguments to create many RoundTeamStats.
     * @example
     * // Create many RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoundTeamStats and only return the `id`
     * const roundTeamStatsWithIdOnly = await prisma.roundTeamStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoundTeamStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, RoundTeamStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoundTeamStats.
     * @param {RoundTeamStatsDeleteArgs} args - Arguments to delete one RoundTeamStats.
     * @example
     * // Delete one RoundTeamStats
     * const RoundTeamStats = await prisma.roundTeamStats.delete({
     *   where: {
     *     // ... filter to delete one RoundTeamStats
     *   }
     * })
     * 
     */
    delete<T extends RoundTeamStatsDeleteArgs>(args: SelectSubset<T, RoundTeamStatsDeleteArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoundTeamStats.
     * @param {RoundTeamStatsUpdateArgs} args - Arguments to update one RoundTeamStats.
     * @example
     * // Update one RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoundTeamStatsUpdateArgs>(args: SelectSubset<T, RoundTeamStatsUpdateArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoundTeamStats.
     * @param {RoundTeamStatsDeleteManyArgs} args - Arguments to filter RoundTeamStats to delete.
     * @example
     * // Delete a few RoundTeamStats
     * const { count } = await prisma.roundTeamStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoundTeamStatsDeleteManyArgs>(args?: SelectSubset<T, RoundTeamStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoundTeamStatsUpdateManyArgs>(args: SelectSubset<T, RoundTeamStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundTeamStats and returns the data updated in the database.
     * @param {RoundTeamStatsUpdateManyAndReturnArgs} args - Arguments to update many RoundTeamStats.
     * @example
     * // Update many RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoundTeamStats and only return the `id`
     * const roundTeamStatsWithIdOnly = await prisma.roundTeamStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoundTeamStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, RoundTeamStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoundTeamStats.
     * @param {RoundTeamStatsUpsertArgs} args - Arguments to update or create a RoundTeamStats.
     * @example
     * // Update or create a RoundTeamStats
     * const roundTeamStats = await prisma.roundTeamStats.upsert({
     *   create: {
     *     // ... data to create a RoundTeamStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoundTeamStats we want to update
     *   }
     * })
     */
    upsert<T extends RoundTeamStatsUpsertArgs>(args: SelectSubset<T, RoundTeamStatsUpsertArgs<ExtArgs>>): Prisma__RoundTeamStatsClient<$Result.GetResult<Prisma.$RoundTeamStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoundTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsCountArgs} args - Arguments to filter RoundTeamStats to count.
     * @example
     * // Count the number of RoundTeamStats
     * const count = await prisma.roundTeamStats.count({
     *   where: {
     *     // ... the filter for the RoundTeamStats we want to count
     *   }
     * })
    **/
    count<T extends RoundTeamStatsCountArgs>(
      args?: Subset<T, RoundTeamStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundTeamStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoundTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundTeamStatsAggregateArgs>(args: Subset<T, RoundTeamStatsAggregateArgs>): Prisma.PrismaPromise<GetRoundTeamStatsAggregateType<T>>

    /**
     * Group by RoundTeamStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTeamStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundTeamStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundTeamStatsGroupByArgs['orderBy'] }
        : { orderBy?: RoundTeamStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundTeamStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundTeamStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoundTeamStats model
   */
  readonly fields: RoundTeamStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoundTeamStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoundTeamStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    round<T extends RoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundDefaultArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoundTeamStats model
   */
  interface RoundTeamStatsFieldRefs {
    readonly id: FieldRef<"RoundTeamStats", 'Int'>
    readonly roundId: FieldRef<"RoundTeamStats", 'Int'>
    readonly teamId: FieldRef<"RoundTeamStats", 'Int'>
    readonly teamSide: FieldRef<"RoundTeamStats", 'String'>
    readonly won: FieldRef<"RoundTeamStats", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RoundTeamStats findUnique
   */
  export type RoundTeamStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundTeamStats to fetch.
     */
    where: RoundTeamStatsWhereUniqueInput
  }

  /**
   * RoundTeamStats findUniqueOrThrow
   */
  export type RoundTeamStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundTeamStats to fetch.
     */
    where: RoundTeamStatsWhereUniqueInput
  }

  /**
   * RoundTeamStats findFirst
   */
  export type RoundTeamStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundTeamStats to fetch.
     */
    where?: RoundTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundTeamStats to fetch.
     */
    orderBy?: RoundTeamStatsOrderByWithRelationInput | RoundTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoundTeamStats.
     */
    cursor?: RoundTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundTeamStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoundTeamStats.
     */
    distinct?: RoundTeamStatsScalarFieldEnum | RoundTeamStatsScalarFieldEnum[]
  }

  /**
   * RoundTeamStats findFirstOrThrow
   */
  export type RoundTeamStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundTeamStats to fetch.
     */
    where?: RoundTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundTeamStats to fetch.
     */
    orderBy?: RoundTeamStatsOrderByWithRelationInput | RoundTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoundTeamStats.
     */
    cursor?: RoundTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundTeamStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoundTeamStats.
     */
    distinct?: RoundTeamStatsScalarFieldEnum | RoundTeamStatsScalarFieldEnum[]
  }

  /**
   * RoundTeamStats findMany
   */
  export type RoundTeamStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * Filter, which RoundTeamStats to fetch.
     */
    where?: RoundTeamStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundTeamStats to fetch.
     */
    orderBy?: RoundTeamStatsOrderByWithRelationInput | RoundTeamStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoundTeamStats.
     */
    cursor?: RoundTeamStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundTeamStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundTeamStats.
     */
    skip?: number
    distinct?: RoundTeamStatsScalarFieldEnum | RoundTeamStatsScalarFieldEnum[]
  }

  /**
   * RoundTeamStats create
   */
  export type RoundTeamStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a RoundTeamStats.
     */
    data: XOR<RoundTeamStatsCreateInput, RoundTeamStatsUncheckedCreateInput>
  }

  /**
   * RoundTeamStats createMany
   */
  export type RoundTeamStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoundTeamStats.
     */
    data: RoundTeamStatsCreateManyInput | RoundTeamStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoundTeamStats createManyAndReturn
   */
  export type RoundTeamStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * The data used to create many RoundTeamStats.
     */
    data: RoundTeamStatsCreateManyInput | RoundTeamStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoundTeamStats update
   */
  export type RoundTeamStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a RoundTeamStats.
     */
    data: XOR<RoundTeamStatsUpdateInput, RoundTeamStatsUncheckedUpdateInput>
    /**
     * Choose, which RoundTeamStats to update.
     */
    where: RoundTeamStatsWhereUniqueInput
  }

  /**
   * RoundTeamStats updateMany
   */
  export type RoundTeamStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoundTeamStats.
     */
    data: XOR<RoundTeamStatsUpdateManyMutationInput, RoundTeamStatsUncheckedUpdateManyInput>
    /**
     * Filter which RoundTeamStats to update
     */
    where?: RoundTeamStatsWhereInput
    /**
     * Limit how many RoundTeamStats to update.
     */
    limit?: number
  }

  /**
   * RoundTeamStats updateManyAndReturn
   */
  export type RoundTeamStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * The data used to update RoundTeamStats.
     */
    data: XOR<RoundTeamStatsUpdateManyMutationInput, RoundTeamStatsUncheckedUpdateManyInput>
    /**
     * Filter which RoundTeamStats to update
     */
    where?: RoundTeamStatsWhereInput
    /**
     * Limit how many RoundTeamStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoundTeamStats upsert
   */
  export type RoundTeamStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the RoundTeamStats to update in case it exists.
     */
    where: RoundTeamStatsWhereUniqueInput
    /**
     * In case the RoundTeamStats found by the `where` argument doesn't exist, create a new RoundTeamStats with this data.
     */
    create: XOR<RoundTeamStatsCreateInput, RoundTeamStatsUncheckedCreateInput>
    /**
     * In case the RoundTeamStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundTeamStatsUpdateInput, RoundTeamStatsUncheckedUpdateInput>
  }

  /**
   * RoundTeamStats delete
   */
  export type RoundTeamStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
    /**
     * Filter which RoundTeamStats to delete.
     */
    where: RoundTeamStatsWhereUniqueInput
  }

  /**
   * RoundTeamStats deleteMany
   */
  export type RoundTeamStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoundTeamStats to delete
     */
    where?: RoundTeamStatsWhereInput
    /**
     * Limit how many RoundTeamStats to delete.
     */
    limit?: number
  }

  /**
   * RoundTeamStats without action
   */
  export type RoundTeamStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundTeamStats
     */
    select?: RoundTeamStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundTeamStats
     */
    omit?: RoundTeamStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundTeamStatsInclude<ExtArgs> | null
  }


  /**
   * Model Kill
   */

  export type AggregateKill = {
    _count: KillCountAggregateOutputType | null
    _avg: KillAvgAggregateOutputType | null
    _sum: KillSumAggregateOutputType | null
    _min: KillMinAggregateOutputType | null
    _max: KillMaxAggregateOutputType | null
  }

  export type KillAvgAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
    timeInRoundMs: number | null
    timeInMatchMs: number | null
    killerId: number | null
    victimId: number | null
    locationX: number | null
    locationY: number | null
  }

  export type KillSumAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
    timeInRoundMs: number | null
    timeInMatchMs: number | null
    killerId: number | null
    victimId: number | null
    locationX: number | null
    locationY: number | null
  }

  export type KillMinAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
    timeInRoundMs: number | null
    timeInMatchMs: number | null
    killerId: number | null
    victimId: number | null
    locationX: number | null
    locationY: number | null
    weaponId: string | null
    weaponName: string | null
    weaponType: string | null
    secondaryFireMode: boolean | null
    createdAt: Date | null
  }

  export type KillMaxAggregateOutputType = {
    id: number | null
    matchId: number | null
    roundNumber: number | null
    timeInRoundMs: number | null
    timeInMatchMs: number | null
    killerId: number | null
    victimId: number | null
    locationX: number | null
    locationY: number | null
    weaponId: string | null
    weaponName: string | null
    weaponType: string | null
    secondaryFireMode: boolean | null
    createdAt: Date | null
  }

  export type KillCountAggregateOutputType = {
    id: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX: number
    locationY: number
    weaponId: number
    weaponName: number
    weaponType: number
    secondaryFireMode: number
    createdAt: number
    _all: number
  }


  export type KillAvgAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    timeInRoundMs?: true
    timeInMatchMs?: true
    killerId?: true
    victimId?: true
    locationX?: true
    locationY?: true
  }

  export type KillSumAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    timeInRoundMs?: true
    timeInMatchMs?: true
    killerId?: true
    victimId?: true
    locationX?: true
    locationY?: true
  }

  export type KillMinAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    timeInRoundMs?: true
    timeInMatchMs?: true
    killerId?: true
    victimId?: true
    locationX?: true
    locationY?: true
    weaponId?: true
    weaponName?: true
    weaponType?: true
    secondaryFireMode?: true
    createdAt?: true
  }

  export type KillMaxAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    timeInRoundMs?: true
    timeInMatchMs?: true
    killerId?: true
    victimId?: true
    locationX?: true
    locationY?: true
    weaponId?: true
    weaponName?: true
    weaponType?: true
    secondaryFireMode?: true
    createdAt?: true
  }

  export type KillCountAggregateInputType = {
    id?: true
    matchId?: true
    roundNumber?: true
    timeInRoundMs?: true
    timeInMatchMs?: true
    killerId?: true
    victimId?: true
    locationX?: true
    locationY?: true
    weaponId?: true
    weaponName?: true
    weaponType?: true
    secondaryFireMode?: true
    createdAt?: true
    _all?: true
  }

  export type KillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kill to aggregate.
     */
    where?: KillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kills to fetch.
     */
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kills
    **/
    _count?: true | KillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KillMaxAggregateInputType
  }

  export type GetKillAggregateType<T extends KillAggregateArgs> = {
        [P in keyof T & keyof AggregateKill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKill[P]>
      : GetScalarType<T[P], AggregateKill[P]>
  }




  export type KillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KillWhereInput
    orderBy?: KillOrderByWithAggregationInput | KillOrderByWithAggregationInput[]
    by: KillScalarFieldEnum[] | KillScalarFieldEnum
    having?: KillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KillCountAggregateInputType | true
    _avg?: KillAvgAggregateInputType
    _sum?: KillSumAggregateInputType
    _min?: KillMinAggregateInputType
    _max?: KillMaxAggregateInputType
  }

  export type KillGroupByOutputType = {
    id: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX: number | null
    locationY: number | null
    weaponId: string | null
    weaponName: string | null
    weaponType: string | null
    secondaryFireMode: boolean
    createdAt: Date
    _count: KillCountAggregateOutputType | null
    _avg: KillAvgAggregateOutputType | null
    _sum: KillSumAggregateOutputType | null
    _min: KillMinAggregateOutputType | null
    _max: KillMaxAggregateOutputType | null
  }

  type GetKillGroupByPayload<T extends KillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KillGroupByOutputType[P]>
            : GetScalarType<T[P], KillGroupByOutputType[P]>
        }
      >
    >


  export type KillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    timeInRoundMs?: boolean
    timeInMatchMs?: boolean
    killerId?: boolean
    victimId?: boolean
    locationX?: boolean
    locationY?: boolean
    weaponId?: boolean
    weaponName?: boolean
    weaponType?: boolean
    secondaryFireMode?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    killer?: boolean | PlayerDefaultArgs<ExtArgs>
    victim?: boolean | PlayerDefaultArgs<ExtArgs>
    assistants?: boolean | Kill$assistantsArgs<ExtArgs>
    _count?: boolean | KillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kill"]>

  export type KillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    timeInRoundMs?: boolean
    timeInMatchMs?: boolean
    killerId?: boolean
    victimId?: boolean
    locationX?: boolean
    locationY?: boolean
    weaponId?: boolean
    weaponName?: boolean
    weaponType?: boolean
    secondaryFireMode?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    killer?: boolean | PlayerDefaultArgs<ExtArgs>
    victim?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kill"]>

  export type KillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    timeInRoundMs?: boolean
    timeInMatchMs?: boolean
    killerId?: boolean
    victimId?: boolean
    locationX?: boolean
    locationY?: boolean
    weaponId?: boolean
    weaponName?: boolean
    weaponType?: boolean
    secondaryFireMode?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    killer?: boolean | PlayerDefaultArgs<ExtArgs>
    victim?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kill"]>

  export type KillSelectScalar = {
    id?: boolean
    matchId?: boolean
    roundNumber?: boolean
    timeInRoundMs?: boolean
    timeInMatchMs?: boolean
    killerId?: boolean
    victimId?: boolean
    locationX?: boolean
    locationY?: boolean
    weaponId?: boolean
    weaponName?: boolean
    weaponType?: boolean
    secondaryFireMode?: boolean
    createdAt?: boolean
  }

  export type KillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "roundNumber" | "timeInRoundMs" | "timeInMatchMs" | "killerId" | "victimId" | "locationX" | "locationY" | "weaponId" | "weaponName" | "weaponType" | "secondaryFireMode" | "createdAt", ExtArgs["result"]["kill"]>
  export type KillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    killer?: boolean | PlayerDefaultArgs<ExtArgs>
    victim?: boolean | PlayerDefaultArgs<ExtArgs>
    assistants?: boolean | Kill$assistantsArgs<ExtArgs>
    _count?: boolean | KillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    killer?: boolean | PlayerDefaultArgs<ExtArgs>
    victim?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type KillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    killer?: boolean | PlayerDefaultArgs<ExtArgs>
    victim?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $KillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kill"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      killer: Prisma.$PlayerPayload<ExtArgs>
      victim: Prisma.$PlayerPayload<ExtArgs>
      assistants: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matchId: number
      roundNumber: number
      timeInRoundMs: number
      timeInMatchMs: number
      killerId: number
      victimId: number
      locationX: number | null
      locationY: number | null
      weaponId: string | null
      weaponName: string | null
      weaponType: string | null
      secondaryFireMode: boolean
      createdAt: Date
    }, ExtArgs["result"]["kill"]>
    composites: {}
  }

  type KillGetPayload<S extends boolean | null | undefined | KillDefaultArgs> = $Result.GetResult<Prisma.$KillPayload, S>

  type KillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KillCountAggregateInputType | true
    }

  export interface KillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kill'], meta: { name: 'Kill' } }
    /**
     * Find zero or one Kill that matches the filter.
     * @param {KillFindUniqueArgs} args - Arguments to find a Kill
     * @example
     * // Get one Kill
     * const kill = await prisma.kill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KillFindUniqueArgs>(args: SelectSubset<T, KillFindUniqueArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KillFindUniqueOrThrowArgs} args - Arguments to find a Kill
     * @example
     * // Get one Kill
     * const kill = await prisma.kill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KillFindUniqueOrThrowArgs>(args: SelectSubset<T, KillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillFindFirstArgs} args - Arguments to find a Kill
     * @example
     * // Get one Kill
     * const kill = await prisma.kill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KillFindFirstArgs>(args?: SelectSubset<T, KillFindFirstArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillFindFirstOrThrowArgs} args - Arguments to find a Kill
     * @example
     * // Get one Kill
     * const kill = await prisma.kill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KillFindFirstOrThrowArgs>(args?: SelectSubset<T, KillFindFirstOrThrowArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kills
     * const kills = await prisma.kill.findMany()
     * 
     * // Get first 10 Kills
     * const kills = await prisma.kill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const killWithIdOnly = await prisma.kill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KillFindManyArgs>(args?: SelectSubset<T, KillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kill.
     * @param {KillCreateArgs} args - Arguments to create a Kill.
     * @example
     * // Create one Kill
     * const Kill = await prisma.kill.create({
     *   data: {
     *     // ... data to create a Kill
     *   }
     * })
     * 
     */
    create<T extends KillCreateArgs>(args: SelectSubset<T, KillCreateArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kills.
     * @param {KillCreateManyArgs} args - Arguments to create many Kills.
     * @example
     * // Create many Kills
     * const kill = await prisma.kill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KillCreateManyArgs>(args?: SelectSubset<T, KillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kills and returns the data saved in the database.
     * @param {KillCreateManyAndReturnArgs} args - Arguments to create many Kills.
     * @example
     * // Create many Kills
     * const kill = await prisma.kill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kills and only return the `id`
     * const killWithIdOnly = await prisma.kill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KillCreateManyAndReturnArgs>(args?: SelectSubset<T, KillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kill.
     * @param {KillDeleteArgs} args - Arguments to delete one Kill.
     * @example
     * // Delete one Kill
     * const Kill = await prisma.kill.delete({
     *   where: {
     *     // ... filter to delete one Kill
     *   }
     * })
     * 
     */
    delete<T extends KillDeleteArgs>(args: SelectSubset<T, KillDeleteArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kill.
     * @param {KillUpdateArgs} args - Arguments to update one Kill.
     * @example
     * // Update one Kill
     * const kill = await prisma.kill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KillUpdateArgs>(args: SelectSubset<T, KillUpdateArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kills.
     * @param {KillDeleteManyArgs} args - Arguments to filter Kills to delete.
     * @example
     * // Delete a few Kills
     * const { count } = await prisma.kill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KillDeleteManyArgs>(args?: SelectSubset<T, KillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kills
     * const kill = await prisma.kill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KillUpdateManyArgs>(args: SelectSubset<T, KillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kills and returns the data updated in the database.
     * @param {KillUpdateManyAndReturnArgs} args - Arguments to update many Kills.
     * @example
     * // Update many Kills
     * const kill = await prisma.kill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kills and only return the `id`
     * const killWithIdOnly = await prisma.kill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KillUpdateManyAndReturnArgs>(args: SelectSubset<T, KillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kill.
     * @param {KillUpsertArgs} args - Arguments to update or create a Kill.
     * @example
     * // Update or create a Kill
     * const kill = await prisma.kill.upsert({
     *   create: {
     *     // ... data to create a Kill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kill we want to update
     *   }
     * })
     */
    upsert<T extends KillUpsertArgs>(args: SelectSubset<T, KillUpsertArgs<ExtArgs>>): Prisma__KillClient<$Result.GetResult<Prisma.$KillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillCountArgs} args - Arguments to filter Kills to count.
     * @example
     * // Count the number of Kills
     * const count = await prisma.kill.count({
     *   where: {
     *     // ... the filter for the Kills we want to count
     *   }
     * })
    **/
    count<T extends KillCountArgs>(
      args?: Subset<T, KillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KillAggregateArgs>(args: Subset<T, KillAggregateArgs>): Prisma.PrismaPromise<GetKillAggregateType<T>>

    /**
     * Group by Kill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KillGroupByArgs['orderBy'] }
        : { orderBy?: KillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kill model
   */
  readonly fields: KillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    killer<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    victim<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assistants<T extends Kill$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, Kill$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kill model
   */
  interface KillFieldRefs {
    readonly id: FieldRef<"Kill", 'Int'>
    readonly matchId: FieldRef<"Kill", 'Int'>
    readonly roundNumber: FieldRef<"Kill", 'Int'>
    readonly timeInRoundMs: FieldRef<"Kill", 'Int'>
    readonly timeInMatchMs: FieldRef<"Kill", 'Int'>
    readonly killerId: FieldRef<"Kill", 'Int'>
    readonly victimId: FieldRef<"Kill", 'Int'>
    readonly locationX: FieldRef<"Kill", 'Float'>
    readonly locationY: FieldRef<"Kill", 'Float'>
    readonly weaponId: FieldRef<"Kill", 'String'>
    readonly weaponName: FieldRef<"Kill", 'String'>
    readonly weaponType: FieldRef<"Kill", 'String'>
    readonly secondaryFireMode: FieldRef<"Kill", 'Boolean'>
    readonly createdAt: FieldRef<"Kill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kill findUnique
   */
  export type KillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * Filter, which Kill to fetch.
     */
    where: KillWhereUniqueInput
  }

  /**
   * Kill findUniqueOrThrow
   */
  export type KillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * Filter, which Kill to fetch.
     */
    where: KillWhereUniqueInput
  }

  /**
   * Kill findFirst
   */
  export type KillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * Filter, which Kill to fetch.
     */
    where?: KillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kills to fetch.
     */
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kills.
     */
    cursor?: KillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kills.
     */
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Kill findFirstOrThrow
   */
  export type KillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * Filter, which Kill to fetch.
     */
    where?: KillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kills to fetch.
     */
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kills.
     */
    cursor?: KillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kills.
     */
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Kill findMany
   */
  export type KillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * Filter, which Kills to fetch.
     */
    where?: KillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kills to fetch.
     */
    orderBy?: KillOrderByWithRelationInput | KillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kills.
     */
    cursor?: KillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kills.
     */
    skip?: number
    distinct?: KillScalarFieldEnum | KillScalarFieldEnum[]
  }

  /**
   * Kill create
   */
  export type KillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * The data needed to create a Kill.
     */
    data: XOR<KillCreateInput, KillUncheckedCreateInput>
  }

  /**
   * Kill createMany
   */
  export type KillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kills.
     */
    data: KillCreateManyInput | KillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kill createManyAndReturn
   */
  export type KillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * The data used to create many Kills.
     */
    data: KillCreateManyInput | KillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kill update
   */
  export type KillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * The data needed to update a Kill.
     */
    data: XOR<KillUpdateInput, KillUncheckedUpdateInput>
    /**
     * Choose, which Kill to update.
     */
    where: KillWhereUniqueInput
  }

  /**
   * Kill updateMany
   */
  export type KillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kills.
     */
    data: XOR<KillUpdateManyMutationInput, KillUncheckedUpdateManyInput>
    /**
     * Filter which Kills to update
     */
    where?: KillWhereInput
    /**
     * Limit how many Kills to update.
     */
    limit?: number
  }

  /**
   * Kill updateManyAndReturn
   */
  export type KillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * The data used to update Kills.
     */
    data: XOR<KillUpdateManyMutationInput, KillUncheckedUpdateManyInput>
    /**
     * Filter which Kills to update
     */
    where?: KillWhereInput
    /**
     * Limit how many Kills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kill upsert
   */
  export type KillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * The filter to search for the Kill to update in case it exists.
     */
    where: KillWhereUniqueInput
    /**
     * In case the Kill found by the `where` argument doesn't exist, create a new Kill with this data.
     */
    create: XOR<KillCreateInput, KillUncheckedCreateInput>
    /**
     * In case the Kill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KillUpdateInput, KillUncheckedUpdateInput>
  }

  /**
   * Kill delete
   */
  export type KillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
    /**
     * Filter which Kill to delete.
     */
    where: KillWhereUniqueInput
  }

  /**
   * Kill deleteMany
   */
  export type KillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kills to delete
     */
    where?: KillWhereInput
    /**
     * Limit how many Kills to delete.
     */
    limit?: number
  }

  /**
   * Kill.assistants
   */
  export type Kill$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Kill without action
   */
  export type KillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kill
     */
    select?: KillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kill
     */
    omit?: KillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KillInclude<ExtArgs> | null
  }


  /**
   * Model TeamRoster
   */

  export type AggregateTeamRoster = {
    _count: TeamRosterCountAggregateOutputType | null
    _avg: TeamRosterAvgAggregateOutputType | null
    _sum: TeamRosterSumAggregateOutputType | null
    _min: TeamRosterMinAggregateOutputType | null
    _max: TeamRosterMaxAggregateOutputType | null
  }

  export type TeamRosterAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    seasonId: number | null
  }

  export type TeamRosterSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    seasonId: number | null
  }

  export type TeamRosterMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    seasonId: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamRosterMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    seasonId: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamRosterCountAggregateOutputType = {
    id: number
    teamId: number
    playerId: number
    seasonId: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamRosterAvgAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    seasonId?: true
  }

  export type TeamRosterSumAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    seasonId?: true
  }

  export type TeamRosterMinAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    seasonId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamRosterMaxAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    seasonId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamRosterCountAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    seasonId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamRosterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamRoster to aggregate.
     */
    where?: TeamRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamRosters to fetch.
     */
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamRosters
    **/
    _count?: true | TeamRosterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamRosterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamRosterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamRosterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamRosterMaxAggregateInputType
  }

  export type GetTeamRosterAggregateType<T extends TeamRosterAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamRoster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamRoster[P]>
      : GetScalarType<T[P], AggregateTeamRoster[P]>
  }




  export type TeamRosterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamRosterWhereInput
    orderBy?: TeamRosterOrderByWithAggregationInput | TeamRosterOrderByWithAggregationInput[]
    by: TeamRosterScalarFieldEnum[] | TeamRosterScalarFieldEnum
    having?: TeamRosterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamRosterCountAggregateInputType | true
    _avg?: TeamRosterAvgAggregateInputType
    _sum?: TeamRosterSumAggregateInputType
    _min?: TeamRosterMinAggregateInputType
    _max?: TeamRosterMaxAggregateInputType
  }

  export type TeamRosterGroupByOutputType = {
    id: number
    teamId: number
    playerId: number
    seasonId: number
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TeamRosterCountAggregateOutputType | null
    _avg: TeamRosterAvgAggregateOutputType | null
    _sum: TeamRosterSumAggregateOutputType | null
    _min: TeamRosterMinAggregateOutputType | null
    _max: TeamRosterMaxAggregateOutputType | null
  }

  type GetTeamRosterGroupByPayload<T extends TeamRosterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamRosterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamRosterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamRosterGroupByOutputType[P]>
            : GetScalarType<T[P], TeamRosterGroupByOutputType[P]>
        }
      >
    >


  export type TeamRosterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    seasonId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamRoster"]>

  export type TeamRosterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    seasonId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamRoster"]>

  export type TeamRosterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    seasonId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamRoster"]>

  export type TeamRosterSelectScalar = {
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    seasonId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamRosterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "playerId" | "seasonId" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["teamRoster"]>
  export type TeamRosterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }
  export type TeamRosterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }
  export type TeamRosterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }

  export type $TeamRosterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamRoster"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      playerId: number
      seasonId: number
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamRoster"]>
    composites: {}
  }

  type TeamRosterGetPayload<S extends boolean | null | undefined | TeamRosterDefaultArgs> = $Result.GetResult<Prisma.$TeamRosterPayload, S>

  type TeamRosterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamRosterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamRosterCountAggregateInputType | true
    }

  export interface TeamRosterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamRoster'], meta: { name: 'TeamRoster' } }
    /**
     * Find zero or one TeamRoster that matches the filter.
     * @param {TeamRosterFindUniqueArgs} args - Arguments to find a TeamRoster
     * @example
     * // Get one TeamRoster
     * const teamRoster = await prisma.teamRoster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamRosterFindUniqueArgs>(args: SelectSubset<T, TeamRosterFindUniqueArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamRoster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamRosterFindUniqueOrThrowArgs} args - Arguments to find a TeamRoster
     * @example
     * // Get one TeamRoster
     * const teamRoster = await prisma.teamRoster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamRosterFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamRosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamRoster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterFindFirstArgs} args - Arguments to find a TeamRoster
     * @example
     * // Get one TeamRoster
     * const teamRoster = await prisma.teamRoster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamRosterFindFirstArgs>(args?: SelectSubset<T, TeamRosterFindFirstArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamRoster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterFindFirstOrThrowArgs} args - Arguments to find a TeamRoster
     * @example
     * // Get one TeamRoster
     * const teamRoster = await prisma.teamRoster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamRosterFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamRosterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamRosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamRosters
     * const teamRosters = await prisma.teamRoster.findMany()
     * 
     * // Get first 10 TeamRosters
     * const teamRosters = await prisma.teamRoster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamRosterWithIdOnly = await prisma.teamRoster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamRosterFindManyArgs>(args?: SelectSubset<T, TeamRosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamRoster.
     * @param {TeamRosterCreateArgs} args - Arguments to create a TeamRoster.
     * @example
     * // Create one TeamRoster
     * const TeamRoster = await prisma.teamRoster.create({
     *   data: {
     *     // ... data to create a TeamRoster
     *   }
     * })
     * 
     */
    create<T extends TeamRosterCreateArgs>(args: SelectSubset<T, TeamRosterCreateArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamRosters.
     * @param {TeamRosterCreateManyArgs} args - Arguments to create many TeamRosters.
     * @example
     * // Create many TeamRosters
     * const teamRoster = await prisma.teamRoster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamRosterCreateManyArgs>(args?: SelectSubset<T, TeamRosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamRosters and returns the data saved in the database.
     * @param {TeamRosterCreateManyAndReturnArgs} args - Arguments to create many TeamRosters.
     * @example
     * // Create many TeamRosters
     * const teamRoster = await prisma.teamRoster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamRosters and only return the `id`
     * const teamRosterWithIdOnly = await prisma.teamRoster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamRosterCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamRosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamRoster.
     * @param {TeamRosterDeleteArgs} args - Arguments to delete one TeamRoster.
     * @example
     * // Delete one TeamRoster
     * const TeamRoster = await prisma.teamRoster.delete({
     *   where: {
     *     // ... filter to delete one TeamRoster
     *   }
     * })
     * 
     */
    delete<T extends TeamRosterDeleteArgs>(args: SelectSubset<T, TeamRosterDeleteArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamRoster.
     * @param {TeamRosterUpdateArgs} args - Arguments to update one TeamRoster.
     * @example
     * // Update one TeamRoster
     * const teamRoster = await prisma.teamRoster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamRosterUpdateArgs>(args: SelectSubset<T, TeamRosterUpdateArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamRosters.
     * @param {TeamRosterDeleteManyArgs} args - Arguments to filter TeamRosters to delete.
     * @example
     * // Delete a few TeamRosters
     * const { count } = await prisma.teamRoster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamRosterDeleteManyArgs>(args?: SelectSubset<T, TeamRosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamRosters
     * const teamRoster = await prisma.teamRoster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamRosterUpdateManyArgs>(args: SelectSubset<T, TeamRosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamRosters and returns the data updated in the database.
     * @param {TeamRosterUpdateManyAndReturnArgs} args - Arguments to update many TeamRosters.
     * @example
     * // Update many TeamRosters
     * const teamRoster = await prisma.teamRoster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamRosters and only return the `id`
     * const teamRosterWithIdOnly = await prisma.teamRoster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamRosterUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamRosterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamRoster.
     * @param {TeamRosterUpsertArgs} args - Arguments to update or create a TeamRoster.
     * @example
     * // Update or create a TeamRoster
     * const teamRoster = await prisma.teamRoster.upsert({
     *   create: {
     *     // ... data to create a TeamRoster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamRoster we want to update
     *   }
     * })
     */
    upsert<T extends TeamRosterUpsertArgs>(args: SelectSubset<T, TeamRosterUpsertArgs<ExtArgs>>): Prisma__TeamRosterClient<$Result.GetResult<Prisma.$TeamRosterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterCountArgs} args - Arguments to filter TeamRosters to count.
     * @example
     * // Count the number of TeamRosters
     * const count = await prisma.teamRoster.count({
     *   where: {
     *     // ... the filter for the TeamRosters we want to count
     *   }
     * })
    **/
    count<T extends TeamRosterCountArgs>(
      args?: Subset<T, TeamRosterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamRosterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamRosterAggregateArgs>(args: Subset<T, TeamRosterAggregateArgs>): Prisma.PrismaPromise<GetTeamRosterAggregateType<T>>

    /**
     * Group by TeamRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamRosterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamRosterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamRosterGroupByArgs['orderBy'] }
        : { orderBy?: TeamRosterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamRosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamRosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamRoster model
   */
  readonly fields: TeamRosterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamRoster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamRosterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamRoster model
   */
  interface TeamRosterFieldRefs {
    readonly id: FieldRef<"TeamRoster", 'Int'>
    readonly teamId: FieldRef<"TeamRoster", 'Int'>
    readonly playerId: FieldRef<"TeamRoster", 'Int'>
    readonly seasonId: FieldRef<"TeamRoster", 'Int'>
    readonly startDate: FieldRef<"TeamRoster", 'DateTime'>
    readonly endDate: FieldRef<"TeamRoster", 'DateTime'>
    readonly createdAt: FieldRef<"TeamRoster", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamRoster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamRoster findUnique
   */
  export type TeamRosterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * Filter, which TeamRoster to fetch.
     */
    where: TeamRosterWhereUniqueInput
  }

  /**
   * TeamRoster findUniqueOrThrow
   */
  export type TeamRosterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * Filter, which TeamRoster to fetch.
     */
    where: TeamRosterWhereUniqueInput
  }

  /**
   * TeamRoster findFirst
   */
  export type TeamRosterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * Filter, which TeamRoster to fetch.
     */
    where?: TeamRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamRosters to fetch.
     */
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamRosters.
     */
    cursor?: TeamRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamRosters.
     */
    distinct?: TeamRosterScalarFieldEnum | TeamRosterScalarFieldEnum[]
  }

  /**
   * TeamRoster findFirstOrThrow
   */
  export type TeamRosterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * Filter, which TeamRoster to fetch.
     */
    where?: TeamRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamRosters to fetch.
     */
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamRosters.
     */
    cursor?: TeamRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamRosters.
     */
    distinct?: TeamRosterScalarFieldEnum | TeamRosterScalarFieldEnum[]
  }

  /**
   * TeamRoster findMany
   */
  export type TeamRosterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * Filter, which TeamRosters to fetch.
     */
    where?: TeamRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamRosters to fetch.
     */
    orderBy?: TeamRosterOrderByWithRelationInput | TeamRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamRosters.
     */
    cursor?: TeamRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamRosters.
     */
    skip?: number
    distinct?: TeamRosterScalarFieldEnum | TeamRosterScalarFieldEnum[]
  }

  /**
   * TeamRoster create
   */
  export type TeamRosterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamRoster.
     */
    data: XOR<TeamRosterCreateInput, TeamRosterUncheckedCreateInput>
  }

  /**
   * TeamRoster createMany
   */
  export type TeamRosterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamRosters.
     */
    data: TeamRosterCreateManyInput | TeamRosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamRoster createManyAndReturn
   */
  export type TeamRosterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * The data used to create many TeamRosters.
     */
    data: TeamRosterCreateManyInput | TeamRosterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamRoster update
   */
  export type TeamRosterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamRoster.
     */
    data: XOR<TeamRosterUpdateInput, TeamRosterUncheckedUpdateInput>
    /**
     * Choose, which TeamRoster to update.
     */
    where: TeamRosterWhereUniqueInput
  }

  /**
   * TeamRoster updateMany
   */
  export type TeamRosterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamRosters.
     */
    data: XOR<TeamRosterUpdateManyMutationInput, TeamRosterUncheckedUpdateManyInput>
    /**
     * Filter which TeamRosters to update
     */
    where?: TeamRosterWhereInput
    /**
     * Limit how many TeamRosters to update.
     */
    limit?: number
  }

  /**
   * TeamRoster updateManyAndReturn
   */
  export type TeamRosterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * The data used to update TeamRosters.
     */
    data: XOR<TeamRosterUpdateManyMutationInput, TeamRosterUncheckedUpdateManyInput>
    /**
     * Filter which TeamRosters to update
     */
    where?: TeamRosterWhereInput
    /**
     * Limit how many TeamRosters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamRoster upsert
   */
  export type TeamRosterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamRoster to update in case it exists.
     */
    where: TeamRosterWhereUniqueInput
    /**
     * In case the TeamRoster found by the `where` argument doesn't exist, create a new TeamRoster with this data.
     */
    create: XOR<TeamRosterCreateInput, TeamRosterUncheckedCreateInput>
    /**
     * In case the TeamRoster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamRosterUpdateInput, TeamRosterUncheckedUpdateInput>
  }

  /**
   * TeamRoster delete
   */
  export type TeamRosterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
    /**
     * Filter which TeamRoster to delete.
     */
    where: TeamRosterWhereUniqueInput
  }

  /**
   * TeamRoster deleteMany
   */
  export type TeamRosterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamRosters to delete
     */
    where?: TeamRosterWhereInput
    /**
     * Limit how many TeamRosters to delete.
     */
    limit?: number
  }

  /**
   * TeamRoster without action
   */
  export type TeamRosterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamRoster
     */
    select?: TeamRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamRoster
     */
    omit?: TeamRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamRosterInclude<ExtArgs> | null
  }


  /**
   * Model Substitution
   */

  export type AggregateSubstitution = {
    _count: SubstitutionCountAggregateOutputType | null
    _avg: SubstitutionAvgAggregateOutputType | null
    _sum: SubstitutionSumAggregateOutputType | null
    _min: SubstitutionMinAggregateOutputType | null
    _max: SubstitutionMaxAggregateOutputType | null
  }

  export type SubstitutionAvgAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    substitutedInId: number | null
    substitutedOutId: number | null
  }

  export type SubstitutionSumAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    substitutedInId: number | null
    substitutedOutId: number | null
  }

  export type SubstitutionMinAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    substitutedInId: number | null
    substitutedOutId: number | null
    timestamp: Date | null
  }

  export type SubstitutionMaxAggregateOutputType = {
    id: number | null
    matchId: number | null
    teamId: number | null
    substitutedInId: number | null
    substitutedOutId: number | null
    timestamp: Date | null
  }

  export type SubstitutionCountAggregateOutputType = {
    id: number
    matchId: number
    teamId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp: number
    _all: number
  }


  export type SubstitutionAvgAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    substitutedInId?: true
    substitutedOutId?: true
  }

  export type SubstitutionSumAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    substitutedInId?: true
    substitutedOutId?: true
  }

  export type SubstitutionMinAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    substitutedInId?: true
    substitutedOutId?: true
    timestamp?: true
  }

  export type SubstitutionMaxAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    substitutedInId?: true
    substitutedOutId?: true
    timestamp?: true
  }

  export type SubstitutionCountAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    substitutedInId?: true
    substitutedOutId?: true
    timestamp?: true
    _all?: true
  }

  export type SubstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Substitution to aggregate.
     */
    where?: SubstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Substitutions to fetch.
     */
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Substitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Substitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Substitutions
    **/
    _count?: true | SubstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubstitutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubstitutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubstitutionMaxAggregateInputType
  }

  export type GetSubstitutionAggregateType<T extends SubstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubstitution[P]>
      : GetScalarType<T[P], AggregateSubstitution[P]>
  }




  export type SubstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubstitutionWhereInput
    orderBy?: SubstitutionOrderByWithAggregationInput | SubstitutionOrderByWithAggregationInput[]
    by: SubstitutionScalarFieldEnum[] | SubstitutionScalarFieldEnum
    having?: SubstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubstitutionCountAggregateInputType | true
    _avg?: SubstitutionAvgAggregateInputType
    _sum?: SubstitutionSumAggregateInputType
    _min?: SubstitutionMinAggregateInputType
    _max?: SubstitutionMaxAggregateInputType
  }

  export type SubstitutionGroupByOutputType = {
    id: number
    matchId: number
    teamId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp: Date
    _count: SubstitutionCountAggregateOutputType | null
    _avg: SubstitutionAvgAggregateOutputType | null
    _sum: SubstitutionSumAggregateOutputType | null
    _min: SubstitutionMinAggregateOutputType | null
    _max: SubstitutionMaxAggregateOutputType | null
  }

  type GetSubstitutionGroupByPayload<T extends SubstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], SubstitutionGroupByOutputType[P]>
        }
      >
    >


  export type SubstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    substitutedInId?: boolean
    substitutedOutId?: boolean
    timestamp?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    substitutedIn?: boolean | PlayerDefaultArgs<ExtArgs>
    substitutedOut?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["substitution"]>

  export type SubstitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    substitutedInId?: boolean
    substitutedOutId?: boolean
    timestamp?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    substitutedIn?: boolean | PlayerDefaultArgs<ExtArgs>
    substitutedOut?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["substitution"]>

  export type SubstitutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    substitutedInId?: boolean
    substitutedOutId?: boolean
    timestamp?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    substitutedIn?: boolean | PlayerDefaultArgs<ExtArgs>
    substitutedOut?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["substitution"]>

  export type SubstitutionSelectScalar = {
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    substitutedInId?: boolean
    substitutedOutId?: boolean
    timestamp?: boolean
  }

  export type SubstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "teamId" | "substitutedInId" | "substitutedOutId" | "timestamp", ExtArgs["result"]["substitution"]>
  export type SubstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    substitutedIn?: boolean | PlayerDefaultArgs<ExtArgs>
    substitutedOut?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type SubstitutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    substitutedIn?: boolean | PlayerDefaultArgs<ExtArgs>
    substitutedOut?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type SubstitutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    substitutedIn?: boolean | PlayerDefaultArgs<ExtArgs>
    substitutedOut?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $SubstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Substitution"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      substitutedIn: Prisma.$PlayerPayload<ExtArgs>
      substitutedOut: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matchId: number
      teamId: number
      substitutedInId: number
      substitutedOutId: number
      timestamp: Date
    }, ExtArgs["result"]["substitution"]>
    composites: {}
  }

  type SubstitutionGetPayload<S extends boolean | null | undefined | SubstitutionDefaultArgs> = $Result.GetResult<Prisma.$SubstitutionPayload, S>

  type SubstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubstitutionCountAggregateInputType | true
    }

  export interface SubstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Substitution'], meta: { name: 'Substitution' } }
    /**
     * Find zero or one Substitution that matches the filter.
     * @param {SubstitutionFindUniqueArgs} args - Arguments to find a Substitution
     * @example
     * // Get one Substitution
     * const substitution = await prisma.substitution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubstitutionFindUniqueArgs>(args: SelectSubset<T, SubstitutionFindUniqueArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Substitution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubstitutionFindUniqueOrThrowArgs} args - Arguments to find a Substitution
     * @example
     * // Get one Substitution
     * const substitution = await prisma.substitution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Substitution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionFindFirstArgs} args - Arguments to find a Substitution
     * @example
     * // Get one Substitution
     * const substitution = await prisma.substitution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubstitutionFindFirstArgs>(args?: SelectSubset<T, SubstitutionFindFirstArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Substitution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionFindFirstOrThrowArgs} args - Arguments to find a Substitution
     * @example
     * // Get one Substitution
     * const substitution = await prisma.substitution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Substitutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Substitutions
     * const substitutions = await prisma.substitution.findMany()
     * 
     * // Get first 10 Substitutions
     * const substitutions = await prisma.substitution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const substitutionWithIdOnly = await prisma.substitution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubstitutionFindManyArgs>(args?: SelectSubset<T, SubstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Substitution.
     * @param {SubstitutionCreateArgs} args - Arguments to create a Substitution.
     * @example
     * // Create one Substitution
     * const Substitution = await prisma.substitution.create({
     *   data: {
     *     // ... data to create a Substitution
     *   }
     * })
     * 
     */
    create<T extends SubstitutionCreateArgs>(args: SelectSubset<T, SubstitutionCreateArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Substitutions.
     * @param {SubstitutionCreateManyArgs} args - Arguments to create many Substitutions.
     * @example
     * // Create many Substitutions
     * const substitution = await prisma.substitution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubstitutionCreateManyArgs>(args?: SelectSubset<T, SubstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Substitutions and returns the data saved in the database.
     * @param {SubstitutionCreateManyAndReturnArgs} args - Arguments to create many Substitutions.
     * @example
     * // Create many Substitutions
     * const substitution = await prisma.substitution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Substitutions and only return the `id`
     * const substitutionWithIdOnly = await prisma.substitution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubstitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubstitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Substitution.
     * @param {SubstitutionDeleteArgs} args - Arguments to delete one Substitution.
     * @example
     * // Delete one Substitution
     * const Substitution = await prisma.substitution.delete({
     *   where: {
     *     // ... filter to delete one Substitution
     *   }
     * })
     * 
     */
    delete<T extends SubstitutionDeleteArgs>(args: SelectSubset<T, SubstitutionDeleteArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Substitution.
     * @param {SubstitutionUpdateArgs} args - Arguments to update one Substitution.
     * @example
     * // Update one Substitution
     * const substitution = await prisma.substitution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubstitutionUpdateArgs>(args: SelectSubset<T, SubstitutionUpdateArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Substitutions.
     * @param {SubstitutionDeleteManyArgs} args - Arguments to filter Substitutions to delete.
     * @example
     * // Delete a few Substitutions
     * const { count } = await prisma.substitution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubstitutionDeleteManyArgs>(args?: SelectSubset<T, SubstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Substitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Substitutions
     * const substitution = await prisma.substitution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubstitutionUpdateManyArgs>(args: SelectSubset<T, SubstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Substitutions and returns the data updated in the database.
     * @param {SubstitutionUpdateManyAndReturnArgs} args - Arguments to update many Substitutions.
     * @example
     * // Update many Substitutions
     * const substitution = await prisma.substitution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Substitutions and only return the `id`
     * const substitutionWithIdOnly = await prisma.substitution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubstitutionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubstitutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Substitution.
     * @param {SubstitutionUpsertArgs} args - Arguments to update or create a Substitution.
     * @example
     * // Update or create a Substitution
     * const substitution = await prisma.substitution.upsert({
     *   create: {
     *     // ... data to create a Substitution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Substitution we want to update
     *   }
     * })
     */
    upsert<T extends SubstitutionUpsertArgs>(args: SelectSubset<T, SubstitutionUpsertArgs<ExtArgs>>): Prisma__SubstitutionClient<$Result.GetResult<Prisma.$SubstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Substitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionCountArgs} args - Arguments to filter Substitutions to count.
     * @example
     * // Count the number of Substitutions
     * const count = await prisma.substitution.count({
     *   where: {
     *     // ... the filter for the Substitutions we want to count
     *   }
     * })
    **/
    count<T extends SubstitutionCountArgs>(
      args?: Subset<T, SubstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Substitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubstitutionAggregateArgs>(args: Subset<T, SubstitutionAggregateArgs>): Prisma.PrismaPromise<GetSubstitutionAggregateType<T>>

    /**
     * Group by Substitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubstitutionGroupByArgs['orderBy'] }
        : { orderBy?: SubstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Substitution model
   */
  readonly fields: SubstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Substitution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    substitutedIn<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    substitutedOut<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Substitution model
   */
  interface SubstitutionFieldRefs {
    readonly id: FieldRef<"Substitution", 'Int'>
    readonly matchId: FieldRef<"Substitution", 'Int'>
    readonly teamId: FieldRef<"Substitution", 'Int'>
    readonly substitutedInId: FieldRef<"Substitution", 'Int'>
    readonly substitutedOutId: FieldRef<"Substitution", 'Int'>
    readonly timestamp: FieldRef<"Substitution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Substitution findUnique
   */
  export type SubstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Substitution to fetch.
     */
    where: SubstitutionWhereUniqueInput
  }

  /**
   * Substitution findUniqueOrThrow
   */
  export type SubstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Substitution to fetch.
     */
    where: SubstitutionWhereUniqueInput
  }

  /**
   * Substitution findFirst
   */
  export type SubstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Substitution to fetch.
     */
    where?: SubstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Substitutions to fetch.
     */
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Substitutions.
     */
    cursor?: SubstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Substitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Substitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Substitutions.
     */
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Substitution findFirstOrThrow
   */
  export type SubstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Substitution to fetch.
     */
    where?: SubstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Substitutions to fetch.
     */
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Substitutions.
     */
    cursor?: SubstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Substitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Substitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Substitutions.
     */
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Substitution findMany
   */
  export type SubstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Substitutions to fetch.
     */
    where?: SubstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Substitutions to fetch.
     */
    orderBy?: SubstitutionOrderByWithRelationInput | SubstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Substitutions.
     */
    cursor?: SubstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Substitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Substitutions.
     */
    skip?: number
    distinct?: SubstitutionScalarFieldEnum | SubstitutionScalarFieldEnum[]
  }

  /**
   * Substitution create
   */
  export type SubstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Substitution.
     */
    data: XOR<SubstitutionCreateInput, SubstitutionUncheckedCreateInput>
  }

  /**
   * Substitution createMany
   */
  export type SubstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Substitutions.
     */
    data: SubstitutionCreateManyInput | SubstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Substitution createManyAndReturn
   */
  export type SubstitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * The data used to create many Substitutions.
     */
    data: SubstitutionCreateManyInput | SubstitutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Substitution update
   */
  export type SubstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Substitution.
     */
    data: XOR<SubstitutionUpdateInput, SubstitutionUncheckedUpdateInput>
    /**
     * Choose, which Substitution to update.
     */
    where: SubstitutionWhereUniqueInput
  }

  /**
   * Substitution updateMany
   */
  export type SubstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Substitutions.
     */
    data: XOR<SubstitutionUpdateManyMutationInput, SubstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Substitutions to update
     */
    where?: SubstitutionWhereInput
    /**
     * Limit how many Substitutions to update.
     */
    limit?: number
  }

  /**
   * Substitution updateManyAndReturn
   */
  export type SubstitutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * The data used to update Substitutions.
     */
    data: XOR<SubstitutionUpdateManyMutationInput, SubstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Substitutions to update
     */
    where?: SubstitutionWhereInput
    /**
     * Limit how many Substitutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Substitution upsert
   */
  export type SubstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Substitution to update in case it exists.
     */
    where: SubstitutionWhereUniqueInput
    /**
     * In case the Substitution found by the `where` argument doesn't exist, create a new Substitution with this data.
     */
    create: XOR<SubstitutionCreateInput, SubstitutionUncheckedCreateInput>
    /**
     * In case the Substitution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubstitutionUpdateInput, SubstitutionUncheckedUpdateInput>
  }

  /**
   * Substitution delete
   */
  export type SubstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
    /**
     * Filter which Substitution to delete.
     */
    where: SubstitutionWhereUniqueInput
  }

  /**
   * Substitution deleteMany
   */
  export type SubstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Substitutions to delete
     */
    where?: SubstitutionWhereInput
    /**
     * Limit how many Substitutions to delete.
     */
    limit?: number
  }

  /**
   * Substitution without action
   */
  export type SubstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Substitution
     */
    select?: SubstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Substitution
     */
    omit?: SubstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubstitutionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const MapScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MapScalarFieldEnum = (typeof MapScalarFieldEnum)[keyof typeof MapScalarFieldEnum]


  export const LeagueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeagueScalarFieldEnum = (typeof LeagueScalarFieldEnum)[keyof typeof LeagueScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tag: 'tag',
    puuid: 'puuid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const SeriesScalarFieldEnum: {
    id: 'id',
    seasonId: 'seasonId',
    redTeamId: 'redTeamId',
    blueTeamId: 'blueTeamId',
    bestOf: 'bestOf',
    winnerTeamId: 'winnerTeamId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeriesScalarFieldEnum = (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    seriesId: 'seriesId',
    matchNumber: 'matchNumber',
    riotMatchId: 'riotMatchId',
    mapId: 'mapId',
    gameLengthMs: 'gameLengthMs',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    isCompleted: 'isCompleted',
    status: 'status',
    winnerTeamSide: 'winnerTeamSide',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const MatchParticipationScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    playerId: 'playerId',
    teamId: 'teamId',
    teamSide: 'teamSide',
    agentId: 'agentId',
    createdAt: 'createdAt'
  };

  export type MatchParticipationScalarFieldEnum = (typeof MatchParticipationScalarFieldEnum)[keyof typeof MatchParticipationScalarFieldEnum]


  export const MatchPlayerStatsScalarFieldEnum: {
    id: 'id',
    matchParticipationId: 'matchParticipationId',
    matchId: 'matchId',
    playerId: 'playerId',
    agentId: 'agentId',
    agentName: 'agentName',
    score: 'score',
    kills: 'kills',
    deaths: 'deaths',
    assists: 'assists',
    headshots: 'headshots',
    bodyshots: 'bodyshots',
    legshots: 'legshots',
    damageDealt: 'damageDealt',
    damageReceived: 'damageReceived',
    adr: 'adr',
    acs: 'acs',
    kd: 'kd',
    hsPercent: 'hsPercent',
    kast: 'kast',
    firstKills: 'firstKills',
    firstDeaths: 'firstDeaths',
    grenadeCasts: 'grenadeCasts',
    ability1Casts: 'ability1Casts',
    ability2Casts: 'ability2Casts',
    ultimateCasts: 'ultimateCasts',
    spentOverall: 'spentOverall',
    spentAverage: 'spentAverage',
    loadoutOverall: 'loadoutOverall',
    loadoutAverage: 'loadoutAverage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchPlayerStatsScalarFieldEnum = (typeof MatchPlayerStatsScalarFieldEnum)[keyof typeof MatchPlayerStatsScalarFieldEnum]


  export const MatchTeamStatsScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    teamId: 'teamId',
    teamSide: 'teamSide',
    roundsWon: 'roundsWon',
    roundsLost: 'roundsLost',
    won: 'won',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchTeamStatsScalarFieldEnum = (typeof MatchTeamStatsScalarFieldEnum)[keyof typeof MatchTeamStatsScalarFieldEnum]


  export const RoundScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    roundNumber: 'roundNumber',
    result: 'result',
    winningTeam: 'winningTeam',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoundScalarFieldEnum = (typeof RoundScalarFieldEnum)[keyof typeof RoundScalarFieldEnum]


  export const PlantScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    playerId: 'playerId',
    roundTimeMs: 'roundTimeMs',
    site: 'site',
    locationX: 'locationX',
    locationY: 'locationY'
  };

  export type PlantScalarFieldEnum = (typeof PlantScalarFieldEnum)[keyof typeof PlantScalarFieldEnum]


  export const DefuseScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    playerId: 'playerId',
    roundTimeMs: 'roundTimeMs',
    locationX: 'locationX',
    locationY: 'locationY'
  };

  export type DefuseScalarFieldEnum = (typeof DefuseScalarFieldEnum)[keyof typeof DefuseScalarFieldEnum]


  export const RoundPlayerStatsScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    matchParticipationId: 'matchParticipationId',
    playerId: 'playerId',
    score: 'score',
    kills: 'kills',
    headshots: 'headshots',
    bodyshots: 'bodyshots',
    legshots: 'legshots',
    grenadeCasts: 'grenadeCasts',
    ability1Casts: 'ability1Casts',
    ability2Casts: 'ability2Casts',
    ultimateCasts: 'ultimateCasts',
    loadoutValue: 'loadoutValue',
    creditsRemaining: 'creditsRemaining',
    weaponId: 'weaponId',
    weaponName: 'weaponName',
    armorId: 'armorId',
    armorName: 'armorName',
    createdAt: 'createdAt'
  };

  export type RoundPlayerStatsScalarFieldEnum = (typeof RoundPlayerStatsScalarFieldEnum)[keyof typeof RoundPlayerStatsScalarFieldEnum]


  export const RoundTeamStatsScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    teamId: 'teamId',
    teamSide: 'teamSide',
    won: 'won'
  };

  export type RoundTeamStatsScalarFieldEnum = (typeof RoundTeamStatsScalarFieldEnum)[keyof typeof RoundTeamStatsScalarFieldEnum]


  export const KillScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    roundNumber: 'roundNumber',
    timeInRoundMs: 'timeInRoundMs',
    timeInMatchMs: 'timeInMatchMs',
    killerId: 'killerId',
    victimId: 'victimId',
    locationX: 'locationX',
    locationY: 'locationY',
    weaponId: 'weaponId',
    weaponName: 'weaponName',
    weaponType: 'weaponType',
    secondaryFireMode: 'secondaryFireMode',
    createdAt: 'createdAt'
  };

  export type KillScalarFieldEnum = (typeof KillScalarFieldEnum)[keyof typeof KillScalarFieldEnum]


  export const TeamRosterScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    playerId: 'playerId',
    seasonId: 'seasonId',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamRosterScalarFieldEnum = (typeof TeamRosterScalarFieldEnum)[keyof typeof TeamRosterScalarFieldEnum]


  export const SubstitutionScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    teamId: 'teamId',
    substitutedInId: 'substitutedInId',
    substitutedOutId: 'substitutedOutId',
    timestamp: 'timestamp'
  };

  export type SubstitutionScalarFieldEnum = (typeof SubstitutionScalarFieldEnum)[keyof typeof SubstitutionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    role?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    matchParticipations?: MatchParticipationListRelationFilter
    matchPlayerStats?: MatchPlayerStatsListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchParticipations?: MatchParticipationOrderByRelationAggregateInput
    matchPlayerStats?: MatchPlayerStatsOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    role?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    matchParticipations?: MatchParticipationListRelationFilter
    matchPlayerStats?: MatchPlayerStatsListRelationFilter
  }, "id" | "name">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    role?: StringWithAggregatesFilter<"Agent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type MapWhereInput = {
    AND?: MapWhereInput | MapWhereInput[]
    OR?: MapWhereInput[]
    NOT?: MapWhereInput | MapWhereInput[]
    id?: StringFilter<"Map"> | string
    name?: StringFilter<"Map"> | string
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    matches?: MatchListRelationFilter
  }

  export type MapOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matches?: MatchOrderByRelationAggregateInput
  }

  export type MapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MapWhereInput | MapWhereInput[]
    OR?: MapWhereInput[]
    NOT?: MapWhereInput | MapWhereInput[]
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    matches?: MatchListRelationFilter
  }, "id" | "name">

  export type MapOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MapCountOrderByAggregateInput
    _max?: MapMaxOrderByAggregateInput
    _min?: MapMinOrderByAggregateInput
  }

  export type MapScalarWhereWithAggregatesInput = {
    AND?: MapScalarWhereWithAggregatesInput | MapScalarWhereWithAggregatesInput[]
    OR?: MapScalarWhereWithAggregatesInput[]
    NOT?: MapScalarWhereWithAggregatesInput | MapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Map"> | string
    name?: StringWithAggregatesFilter<"Map"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Map"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Map"> | Date | string
  }

  export type LeagueWhereInput = {
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    id?: IntFilter<"League"> | number
    name?: StringFilter<"League"> | string
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
    seasons?: SeasonListRelationFilter
  }

  export type LeagueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasons?: SeasonOrderByRelationAggregateInput
  }

  export type LeagueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
    seasons?: SeasonListRelationFilter
  }, "id" | "name">

  export type LeagueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeagueCountOrderByAggregateInput
    _avg?: LeagueAvgOrderByAggregateInput
    _max?: LeagueMaxOrderByAggregateInput
    _min?: LeagueMinOrderByAggregateInput
    _sum?: LeagueSumOrderByAggregateInput
  }

  export type LeagueScalarWhereWithAggregatesInput = {
    AND?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    OR?: LeagueScalarWhereWithAggregatesInput[]
    NOT?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"League"> | number
    name?: StringWithAggregatesFilter<"League"> | string
    createdAt?: DateTimeWithAggregatesFilter<"League"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"League"> | Date | string
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: IntFilter<"Season"> | number
    leagueId?: IntFilter<"Season"> | number
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeNullableFilter<"Season"> | Date | string | null
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    series?: SeriesListRelationFilter
    teamRosters?: TeamRosterListRelationFilter
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    series?: SeriesOrderByRelationAggregateInput
    teamRosters?: TeamRosterOrderByRelationAggregateInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    leagueId_name?: SeasonLeagueIdNameCompoundUniqueInput
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    leagueId?: IntFilter<"Season"> | number
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeNullableFilter<"Season"> | Date | string | null
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    series?: SeriesListRelationFilter
    teamRosters?: TeamRosterListRelationFilter
  }, "id" | "leagueId_name">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Season"> | number
    leagueId?: IntWithAggregatesFilter<"Season"> | number
    name?: StringWithAggregatesFilter<"Season"> | string
    startDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Season"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    rosters?: TeamRosterListRelationFilter
    redSeries?: SeriesListRelationFilter
    blueSeries?: SeriesListRelationFilter
    teamStats?: MatchTeamStatsListRelationFilter
    substitutions?: SubstitutionListRelationFilter
    roundStats?: RoundTeamStatsListRelationFilter
    matchParticipations?: MatchParticipationListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rosters?: TeamRosterOrderByRelationAggregateInput
    redSeries?: SeriesOrderByRelationAggregateInput
    blueSeries?: SeriesOrderByRelationAggregateInput
    teamStats?: MatchTeamStatsOrderByRelationAggregateInput
    substitutions?: SubstitutionOrderByRelationAggregateInput
    roundStats?: RoundTeamStatsOrderByRelationAggregateInput
    matchParticipations?: MatchParticipationOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    rosters?: TeamRosterListRelationFilter
    redSeries?: SeriesListRelationFilter
    blueSeries?: SeriesListRelationFilter
    teamStats?: MatchTeamStatsListRelationFilter
    substitutions?: SubstitutionListRelationFilter
    roundStats?: RoundTeamStatsListRelationFilter
    matchParticipations?: MatchParticipationListRelationFilter
  }, "id" | "name">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: IntFilter<"Player"> | number
    name?: StringFilter<"Player"> | string
    tag?: StringFilter<"Player"> | string
    puuid?: StringFilter<"Player"> | string
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    rosters?: TeamRosterListRelationFilter
    subIns?: SubstitutionListRelationFilter
    subOuts?: SubstitutionListRelationFilter
    plants?: PlantListRelationFilter
    defuses?: DefuseListRelationFilter
    roundStats?: RoundPlayerStatsListRelationFilter
    matchStats?: MatchPlayerStatsListRelationFilter
    kills?: KillListRelationFilter
    deaths?: KillListRelationFilter
    killAssists?: KillListRelationFilter
    matchParticipations?: MatchParticipationListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    puuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rosters?: TeamRosterOrderByRelationAggregateInput
    subIns?: SubstitutionOrderByRelationAggregateInput
    subOuts?: SubstitutionOrderByRelationAggregateInput
    plants?: PlantOrderByRelationAggregateInput
    defuses?: DefuseOrderByRelationAggregateInput
    roundStats?: RoundPlayerStatsOrderByRelationAggregateInput
    matchStats?: MatchPlayerStatsOrderByRelationAggregateInput
    kills?: KillOrderByRelationAggregateInput
    deaths?: KillOrderByRelationAggregateInput
    killAssists?: KillOrderByRelationAggregateInput
    matchParticipations?: MatchParticipationOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    puuid?: string
    name_tag?: PlayerNameTagCompoundUniqueInput
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    name?: StringFilter<"Player"> | string
    tag?: StringFilter<"Player"> | string
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    rosters?: TeamRosterListRelationFilter
    subIns?: SubstitutionListRelationFilter
    subOuts?: SubstitutionListRelationFilter
    plants?: PlantListRelationFilter
    defuses?: DefuseListRelationFilter
    roundStats?: RoundPlayerStatsListRelationFilter
    matchStats?: MatchPlayerStatsListRelationFilter
    kills?: KillListRelationFilter
    deaths?: KillListRelationFilter
    killAssists?: KillListRelationFilter
    matchParticipations?: MatchParticipationListRelationFilter
  }, "id" | "puuid" | "name_tag">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    puuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Player"> | number
    name?: StringWithAggregatesFilter<"Player"> | string
    tag?: StringWithAggregatesFilter<"Player"> | string
    puuid?: StringWithAggregatesFilter<"Player"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type SeriesWhereInput = {
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    id?: IntFilter<"Series"> | number
    seasonId?: IntFilter<"Series"> | number
    redTeamId?: IntFilter<"Series"> | number
    blueTeamId?: IntFilter<"Series"> | number
    bestOf?: IntFilter<"Series"> | number
    winnerTeamId?: IntNullableFilter<"Series"> | number | null
    status?: StringFilter<"Series"> | string
    startDate?: DateTimeFilter<"Series"> | Date | string
    endDate?: DateTimeNullableFilter<"Series"> | Date | string | null
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    redTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    blueTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    matches?: MatchListRelationFilter
  }

  export type SeriesOrderByWithRelationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    season?: SeasonOrderByWithRelationInput
    redTeam?: TeamOrderByWithRelationInput
    blueTeam?: TeamOrderByWithRelationInput
    matches?: MatchOrderByRelationAggregateInput
  }

  export type SeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    seasonId?: IntFilter<"Series"> | number
    redTeamId?: IntFilter<"Series"> | number
    blueTeamId?: IntFilter<"Series"> | number
    bestOf?: IntFilter<"Series"> | number
    winnerTeamId?: IntNullableFilter<"Series"> | number | null
    status?: StringFilter<"Series"> | string
    startDate?: DateTimeFilter<"Series"> | Date | string
    endDate?: DateTimeNullableFilter<"Series"> | Date | string | null
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    redTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    blueTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    matches?: MatchListRelationFilter
  }, "id">

  export type SeriesOrderByWithAggregationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeriesCountOrderByAggregateInput
    _avg?: SeriesAvgOrderByAggregateInput
    _max?: SeriesMaxOrderByAggregateInput
    _min?: SeriesMinOrderByAggregateInput
    _sum?: SeriesSumOrderByAggregateInput
  }

  export type SeriesScalarWhereWithAggregatesInput = {
    AND?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    OR?: SeriesScalarWhereWithAggregatesInput[]
    NOT?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Series"> | number
    seasonId?: IntWithAggregatesFilter<"Series"> | number
    redTeamId?: IntWithAggregatesFilter<"Series"> | number
    blueTeamId?: IntWithAggregatesFilter<"Series"> | number
    bestOf?: IntWithAggregatesFilter<"Series"> | number
    winnerTeamId?: IntNullableWithAggregatesFilter<"Series"> | number | null
    status?: StringWithAggregatesFilter<"Series"> | string
    startDate?: DateTimeWithAggregatesFilter<"Series"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Series"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: IntFilter<"Match"> | number
    seriesId?: IntFilter<"Match"> | number
    matchNumber?: IntFilter<"Match"> | number
    riotMatchId?: StringNullableFilter<"Match"> | string | null
    mapId?: StringFilter<"Match"> | string
    gameLengthMs?: IntNullableFilter<"Match"> | number | null
    startedAt?: DateTimeFilter<"Match"> | Date | string
    completedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    isCompleted?: BoolFilter<"Match"> | boolean
    status?: StringFilter<"Match"> | string
    winnerTeamSide?: StringNullableFilter<"Match"> | string | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
    map?: XOR<MapScalarRelationFilter, MapWhereInput>
    rounds?: RoundListRelationFilter
    matchPlayerStats?: MatchPlayerStatsListRelationFilter
    matchTeamStats?: MatchTeamStatsListRelationFilter
    substitutions?: SubstitutionListRelationFilter
    kills?: KillListRelationFilter
    participations?: MatchParticipationListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    riotMatchId?: SortOrderInput | SortOrder
    mapId?: SortOrder
    gameLengthMs?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    status?: SortOrder
    winnerTeamSide?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    series?: SeriesOrderByWithRelationInput
    map?: MapOrderByWithRelationInput
    rounds?: RoundOrderByRelationAggregateInput
    matchPlayerStats?: MatchPlayerStatsOrderByRelationAggregateInput
    matchTeamStats?: MatchTeamStatsOrderByRelationAggregateInput
    substitutions?: SubstitutionOrderByRelationAggregateInput
    kills?: KillOrderByRelationAggregateInput
    participations?: MatchParticipationOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    riotMatchId?: string
    seriesId_matchNumber?: MatchSeriesIdMatchNumberCompoundUniqueInput
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    seriesId?: IntFilter<"Match"> | number
    matchNumber?: IntFilter<"Match"> | number
    mapId?: StringFilter<"Match"> | string
    gameLengthMs?: IntNullableFilter<"Match"> | number | null
    startedAt?: DateTimeFilter<"Match"> | Date | string
    completedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    isCompleted?: BoolFilter<"Match"> | boolean
    status?: StringFilter<"Match"> | string
    winnerTeamSide?: StringNullableFilter<"Match"> | string | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
    map?: XOR<MapScalarRelationFilter, MapWhereInput>
    rounds?: RoundListRelationFilter
    matchPlayerStats?: MatchPlayerStatsListRelationFilter
    matchTeamStats?: MatchTeamStatsListRelationFilter
    substitutions?: SubstitutionListRelationFilter
    kills?: KillListRelationFilter
    participations?: MatchParticipationListRelationFilter
  }, "id" | "riotMatchId" | "seriesId_matchNumber">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    riotMatchId?: SortOrderInput | SortOrder
    mapId?: SortOrder
    gameLengthMs?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    status?: SortOrder
    winnerTeamSide?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Match"> | number
    seriesId?: IntWithAggregatesFilter<"Match"> | number
    matchNumber?: IntWithAggregatesFilter<"Match"> | number
    riotMatchId?: StringNullableWithAggregatesFilter<"Match"> | string | null
    mapId?: StringWithAggregatesFilter<"Match"> | string
    gameLengthMs?: IntNullableWithAggregatesFilter<"Match"> | number | null
    startedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Match"> | Date | string | null
    isCompleted?: BoolWithAggregatesFilter<"Match"> | boolean
    status?: StringWithAggregatesFilter<"Match"> | string
    winnerTeamSide?: StringNullableWithAggregatesFilter<"Match"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type MatchParticipationWhereInput = {
    AND?: MatchParticipationWhereInput | MatchParticipationWhereInput[]
    OR?: MatchParticipationWhereInput[]
    NOT?: MatchParticipationWhereInput | MatchParticipationWhereInput[]
    id?: IntFilter<"MatchParticipation"> | number
    matchId?: IntFilter<"MatchParticipation"> | number
    playerId?: IntFilter<"MatchParticipation"> | number
    teamId?: IntFilter<"MatchParticipation"> | number
    teamSide?: StringFilter<"MatchParticipation"> | string
    agentId?: StringNullableFilter<"MatchParticipation"> | string | null
    createdAt?: DateTimeFilter<"MatchParticipation"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    matchStats?: XOR<MatchPlayerStatsNullableScalarRelationFilter, MatchPlayerStatsWhereInput> | null
    roundStats?: RoundPlayerStatsListRelationFilter
  }

  export type MatchParticipationOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    match?: MatchOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    matchStats?: MatchPlayerStatsOrderByWithRelationInput
    roundStats?: RoundPlayerStatsOrderByRelationAggregateInput
  }

  export type MatchParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matchId_playerId?: MatchParticipationMatchIdPlayerIdCompoundUniqueInput
    AND?: MatchParticipationWhereInput | MatchParticipationWhereInput[]
    OR?: MatchParticipationWhereInput[]
    NOT?: MatchParticipationWhereInput | MatchParticipationWhereInput[]
    matchId?: IntFilter<"MatchParticipation"> | number
    playerId?: IntFilter<"MatchParticipation"> | number
    teamId?: IntFilter<"MatchParticipation"> | number
    teamSide?: StringFilter<"MatchParticipation"> | string
    agentId?: StringNullableFilter<"MatchParticipation"> | string | null
    createdAt?: DateTimeFilter<"MatchParticipation"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    matchStats?: XOR<MatchPlayerStatsNullableScalarRelationFilter, MatchPlayerStatsWhereInput> | null
    roundStats?: RoundPlayerStatsListRelationFilter
  }, "id" | "matchId_playerId">

  export type MatchParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MatchParticipationCountOrderByAggregateInput
    _avg?: MatchParticipationAvgOrderByAggregateInput
    _max?: MatchParticipationMaxOrderByAggregateInput
    _min?: MatchParticipationMinOrderByAggregateInput
    _sum?: MatchParticipationSumOrderByAggregateInput
  }

  export type MatchParticipationScalarWhereWithAggregatesInput = {
    AND?: MatchParticipationScalarWhereWithAggregatesInput | MatchParticipationScalarWhereWithAggregatesInput[]
    OR?: MatchParticipationScalarWhereWithAggregatesInput[]
    NOT?: MatchParticipationScalarWhereWithAggregatesInput | MatchParticipationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchParticipation"> | number
    matchId?: IntWithAggregatesFilter<"MatchParticipation"> | number
    playerId?: IntWithAggregatesFilter<"MatchParticipation"> | number
    teamId?: IntWithAggregatesFilter<"MatchParticipation"> | number
    teamSide?: StringWithAggregatesFilter<"MatchParticipation"> | string
    agentId?: StringNullableWithAggregatesFilter<"MatchParticipation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MatchParticipation"> | Date | string
  }

  export type MatchPlayerStatsWhereInput = {
    AND?: MatchPlayerStatsWhereInput | MatchPlayerStatsWhereInput[]
    OR?: MatchPlayerStatsWhereInput[]
    NOT?: MatchPlayerStatsWhereInput | MatchPlayerStatsWhereInput[]
    id?: IntFilter<"MatchPlayerStats"> | number
    matchParticipationId?: IntFilter<"MatchPlayerStats"> | number
    matchId?: IntFilter<"MatchPlayerStats"> | number
    playerId?: IntFilter<"MatchPlayerStats"> | number
    agentId?: StringNullableFilter<"MatchPlayerStats"> | string | null
    agentName?: StringNullableFilter<"MatchPlayerStats"> | string | null
    score?: IntFilter<"MatchPlayerStats"> | number
    kills?: IntFilter<"MatchPlayerStats"> | number
    deaths?: IntFilter<"MatchPlayerStats"> | number
    assists?: IntFilter<"MatchPlayerStats"> | number
    headshots?: IntFilter<"MatchPlayerStats"> | number
    bodyshots?: IntFilter<"MatchPlayerStats"> | number
    legshots?: IntFilter<"MatchPlayerStats"> | number
    damageDealt?: IntFilter<"MatchPlayerStats"> | number
    damageReceived?: IntFilter<"MatchPlayerStats"> | number
    adr?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    acs?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    kd?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    hsPercent?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    kast?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    firstKills?: IntNullableFilter<"MatchPlayerStats"> | number | null
    firstDeaths?: IntNullableFilter<"MatchPlayerStats"> | number | null
    grenadeCasts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ability1Casts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ability2Casts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ultimateCasts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    spentOverall?: IntNullableFilter<"MatchPlayerStats"> | number | null
    spentAverage?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    loadoutOverall?: IntNullableFilter<"MatchPlayerStats"> | number | null
    loadoutAverage?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    createdAt?: DateTimeFilter<"MatchPlayerStats"> | Date | string
    updatedAt?: DateTimeFilter<"MatchPlayerStats"> | Date | string
    matchParticipation?: XOR<MatchParticipationScalarRelationFilter, MatchParticipationWhereInput>
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    Agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type MatchPlayerStatsOrderByWithRelationInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrderInput | SortOrder
    acs?: SortOrderInput | SortOrder
    kd?: SortOrderInput | SortOrder
    hsPercent?: SortOrderInput | SortOrder
    kast?: SortOrderInput | SortOrder
    firstKills?: SortOrderInput | SortOrder
    firstDeaths?: SortOrderInput | SortOrder
    grenadeCasts?: SortOrderInput | SortOrder
    ability1Casts?: SortOrderInput | SortOrder
    ability2Casts?: SortOrderInput | SortOrder
    ultimateCasts?: SortOrderInput | SortOrder
    spentOverall?: SortOrderInput | SortOrder
    spentAverage?: SortOrderInput | SortOrder
    loadoutOverall?: SortOrderInput | SortOrder
    loadoutAverage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchParticipation?: MatchParticipationOrderByWithRelationInput
    match?: MatchOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
    Agent?: AgentOrderByWithRelationInput
  }

  export type MatchPlayerStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matchParticipationId?: number
    AND?: MatchPlayerStatsWhereInput | MatchPlayerStatsWhereInput[]
    OR?: MatchPlayerStatsWhereInput[]
    NOT?: MatchPlayerStatsWhereInput | MatchPlayerStatsWhereInput[]
    matchId?: IntFilter<"MatchPlayerStats"> | number
    playerId?: IntFilter<"MatchPlayerStats"> | number
    agentId?: StringNullableFilter<"MatchPlayerStats"> | string | null
    agentName?: StringNullableFilter<"MatchPlayerStats"> | string | null
    score?: IntFilter<"MatchPlayerStats"> | number
    kills?: IntFilter<"MatchPlayerStats"> | number
    deaths?: IntFilter<"MatchPlayerStats"> | number
    assists?: IntFilter<"MatchPlayerStats"> | number
    headshots?: IntFilter<"MatchPlayerStats"> | number
    bodyshots?: IntFilter<"MatchPlayerStats"> | number
    legshots?: IntFilter<"MatchPlayerStats"> | number
    damageDealt?: IntFilter<"MatchPlayerStats"> | number
    damageReceived?: IntFilter<"MatchPlayerStats"> | number
    adr?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    acs?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    kd?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    hsPercent?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    kast?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    firstKills?: IntNullableFilter<"MatchPlayerStats"> | number | null
    firstDeaths?: IntNullableFilter<"MatchPlayerStats"> | number | null
    grenadeCasts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ability1Casts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ability2Casts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ultimateCasts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    spentOverall?: IntNullableFilter<"MatchPlayerStats"> | number | null
    spentAverage?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    loadoutOverall?: IntNullableFilter<"MatchPlayerStats"> | number | null
    loadoutAverage?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    createdAt?: DateTimeFilter<"MatchPlayerStats"> | Date | string
    updatedAt?: DateTimeFilter<"MatchPlayerStats"> | Date | string
    matchParticipation?: XOR<MatchParticipationScalarRelationFilter, MatchParticipationWhereInput>
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    Agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id" | "matchParticipationId">

  export type MatchPlayerStatsOrderByWithAggregationInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrderInput | SortOrder
    acs?: SortOrderInput | SortOrder
    kd?: SortOrderInput | SortOrder
    hsPercent?: SortOrderInput | SortOrder
    kast?: SortOrderInput | SortOrder
    firstKills?: SortOrderInput | SortOrder
    firstDeaths?: SortOrderInput | SortOrder
    grenadeCasts?: SortOrderInput | SortOrder
    ability1Casts?: SortOrderInput | SortOrder
    ability2Casts?: SortOrderInput | SortOrder
    ultimateCasts?: SortOrderInput | SortOrder
    spentOverall?: SortOrderInput | SortOrder
    spentAverage?: SortOrderInput | SortOrder
    loadoutOverall?: SortOrderInput | SortOrder
    loadoutAverage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchPlayerStatsCountOrderByAggregateInput
    _avg?: MatchPlayerStatsAvgOrderByAggregateInput
    _max?: MatchPlayerStatsMaxOrderByAggregateInput
    _min?: MatchPlayerStatsMinOrderByAggregateInput
    _sum?: MatchPlayerStatsSumOrderByAggregateInput
  }

  export type MatchPlayerStatsScalarWhereWithAggregatesInput = {
    AND?: MatchPlayerStatsScalarWhereWithAggregatesInput | MatchPlayerStatsScalarWhereWithAggregatesInput[]
    OR?: MatchPlayerStatsScalarWhereWithAggregatesInput[]
    NOT?: MatchPlayerStatsScalarWhereWithAggregatesInput | MatchPlayerStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    matchParticipationId?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    matchId?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    playerId?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    agentId?: StringNullableWithAggregatesFilter<"MatchPlayerStats"> | string | null
    agentName?: StringNullableWithAggregatesFilter<"MatchPlayerStats"> | string | null
    score?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    kills?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    deaths?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    assists?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    headshots?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    bodyshots?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    legshots?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    damageDealt?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    damageReceived?: IntWithAggregatesFilter<"MatchPlayerStats"> | number
    adr?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    acs?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    kd?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    hsPercent?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    kast?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    firstKills?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    firstDeaths?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    grenadeCasts?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    ability1Casts?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    ability2Casts?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    ultimateCasts?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    spentOverall?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    spentAverage?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    loadoutOverall?: IntNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    loadoutAverage?: FloatNullableWithAggregatesFilter<"MatchPlayerStats"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MatchPlayerStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatchPlayerStats"> | Date | string
  }

  export type MatchTeamStatsWhereInput = {
    AND?: MatchTeamStatsWhereInput | MatchTeamStatsWhereInput[]
    OR?: MatchTeamStatsWhereInput[]
    NOT?: MatchTeamStatsWhereInput | MatchTeamStatsWhereInput[]
    id?: IntFilter<"MatchTeamStats"> | number
    matchId?: IntFilter<"MatchTeamStats"> | number
    teamId?: IntFilter<"MatchTeamStats"> | number
    teamSide?: StringFilter<"MatchTeamStats"> | string
    roundsWon?: IntFilter<"MatchTeamStats"> | number
    roundsLost?: IntFilter<"MatchTeamStats"> | number
    won?: BoolFilter<"MatchTeamStats"> | boolean
    createdAt?: DateTimeFilter<"MatchTeamStats"> | Date | string
    updatedAt?: DateTimeFilter<"MatchTeamStats"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type MatchTeamStatsOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
    won?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    match?: MatchOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type MatchTeamStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matchId_teamId?: MatchTeamStatsMatchIdTeamIdCompoundUniqueInput
    AND?: MatchTeamStatsWhereInput | MatchTeamStatsWhereInput[]
    OR?: MatchTeamStatsWhereInput[]
    NOT?: MatchTeamStatsWhereInput | MatchTeamStatsWhereInput[]
    matchId?: IntFilter<"MatchTeamStats"> | number
    teamId?: IntFilter<"MatchTeamStats"> | number
    teamSide?: StringFilter<"MatchTeamStats"> | string
    roundsWon?: IntFilter<"MatchTeamStats"> | number
    roundsLost?: IntFilter<"MatchTeamStats"> | number
    won?: BoolFilter<"MatchTeamStats"> | boolean
    createdAt?: DateTimeFilter<"MatchTeamStats"> | Date | string
    updatedAt?: DateTimeFilter<"MatchTeamStats"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "matchId_teamId">

  export type MatchTeamStatsOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
    won?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchTeamStatsCountOrderByAggregateInput
    _avg?: MatchTeamStatsAvgOrderByAggregateInput
    _max?: MatchTeamStatsMaxOrderByAggregateInput
    _min?: MatchTeamStatsMinOrderByAggregateInput
    _sum?: MatchTeamStatsSumOrderByAggregateInput
  }

  export type MatchTeamStatsScalarWhereWithAggregatesInput = {
    AND?: MatchTeamStatsScalarWhereWithAggregatesInput | MatchTeamStatsScalarWhereWithAggregatesInput[]
    OR?: MatchTeamStatsScalarWhereWithAggregatesInput[]
    NOT?: MatchTeamStatsScalarWhereWithAggregatesInput | MatchTeamStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchTeamStats"> | number
    matchId?: IntWithAggregatesFilter<"MatchTeamStats"> | number
    teamId?: IntWithAggregatesFilter<"MatchTeamStats"> | number
    teamSide?: StringWithAggregatesFilter<"MatchTeamStats"> | string
    roundsWon?: IntWithAggregatesFilter<"MatchTeamStats"> | number
    roundsLost?: IntWithAggregatesFilter<"MatchTeamStats"> | number
    won?: BoolWithAggregatesFilter<"MatchTeamStats"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MatchTeamStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatchTeamStats"> | Date | string
  }

  export type RoundWhereInput = {
    AND?: RoundWhereInput | RoundWhereInput[]
    OR?: RoundWhereInput[]
    NOT?: RoundWhereInput | RoundWhereInput[]
    id?: IntFilter<"Round"> | number
    matchId?: IntFilter<"Round"> | number
    roundNumber?: IntFilter<"Round"> | number
    result?: StringFilter<"Round"> | string
    winningTeam?: StringFilter<"Round"> | string
    createdAt?: DateTimeFilter<"Round"> | Date | string
    updatedAt?: DateTimeFilter<"Round"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    plant?: XOR<PlantNullableScalarRelationFilter, PlantWhereInput> | null
    defuse?: XOR<DefuseNullableScalarRelationFilter, DefuseWhereInput> | null
    playerStats?: RoundPlayerStatsListRelationFilter
    teamStats?: RoundTeamStatsListRelationFilter
  }

  export type RoundOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    match?: MatchOrderByWithRelationInput
    plant?: PlantOrderByWithRelationInput
    defuse?: DefuseOrderByWithRelationInput
    playerStats?: RoundPlayerStatsOrderByRelationAggregateInput
    teamStats?: RoundTeamStatsOrderByRelationAggregateInput
  }

  export type RoundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matchId_roundNumber?: RoundMatchIdRoundNumberCompoundUniqueInput
    AND?: RoundWhereInput | RoundWhereInput[]
    OR?: RoundWhereInput[]
    NOT?: RoundWhereInput | RoundWhereInput[]
    matchId?: IntFilter<"Round"> | number
    roundNumber?: IntFilter<"Round"> | number
    result?: StringFilter<"Round"> | string
    winningTeam?: StringFilter<"Round"> | string
    createdAt?: DateTimeFilter<"Round"> | Date | string
    updatedAt?: DateTimeFilter<"Round"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    plant?: XOR<PlantNullableScalarRelationFilter, PlantWhereInput> | null
    defuse?: XOR<DefuseNullableScalarRelationFilter, DefuseWhereInput> | null
    playerStats?: RoundPlayerStatsListRelationFilter
    teamStats?: RoundTeamStatsListRelationFilter
  }, "id" | "matchId_roundNumber">

  export type RoundOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoundCountOrderByAggregateInput
    _avg?: RoundAvgOrderByAggregateInput
    _max?: RoundMaxOrderByAggregateInput
    _min?: RoundMinOrderByAggregateInput
    _sum?: RoundSumOrderByAggregateInput
  }

  export type RoundScalarWhereWithAggregatesInput = {
    AND?: RoundScalarWhereWithAggregatesInput | RoundScalarWhereWithAggregatesInput[]
    OR?: RoundScalarWhereWithAggregatesInput[]
    NOT?: RoundScalarWhereWithAggregatesInput | RoundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Round"> | number
    matchId?: IntWithAggregatesFilter<"Round"> | number
    roundNumber?: IntWithAggregatesFilter<"Round"> | number
    result?: StringWithAggregatesFilter<"Round"> | string
    winningTeam?: StringWithAggregatesFilter<"Round"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Round"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Round"> | Date | string
  }

  export type PlantWhereInput = {
    AND?: PlantWhereInput | PlantWhereInput[]
    OR?: PlantWhereInput[]
    NOT?: PlantWhereInput | PlantWhereInput[]
    id?: IntFilter<"Plant"> | number
    roundId?: IntFilter<"Plant"> | number
    playerId?: IntFilter<"Plant"> | number
    roundTimeMs?: IntFilter<"Plant"> | number
    site?: StringFilter<"Plant"> | string
    locationX?: FloatNullableFilter<"Plant"> | number | null
    locationY?: FloatNullableFilter<"Plant"> | number | null
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type PlantOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    site?: SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    round?: RoundOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type PlantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roundId?: number
    AND?: PlantWhereInput | PlantWhereInput[]
    OR?: PlantWhereInput[]
    NOT?: PlantWhereInput | PlantWhereInput[]
    playerId?: IntFilter<"Plant"> | number
    roundTimeMs?: IntFilter<"Plant"> | number
    site?: StringFilter<"Plant"> | string
    locationX?: FloatNullableFilter<"Plant"> | number | null
    locationY?: FloatNullableFilter<"Plant"> | number | null
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "roundId">

  export type PlantOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    site?: SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    _count?: PlantCountOrderByAggregateInput
    _avg?: PlantAvgOrderByAggregateInput
    _max?: PlantMaxOrderByAggregateInput
    _min?: PlantMinOrderByAggregateInput
    _sum?: PlantSumOrderByAggregateInput
  }

  export type PlantScalarWhereWithAggregatesInput = {
    AND?: PlantScalarWhereWithAggregatesInput | PlantScalarWhereWithAggregatesInput[]
    OR?: PlantScalarWhereWithAggregatesInput[]
    NOT?: PlantScalarWhereWithAggregatesInput | PlantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plant"> | number
    roundId?: IntWithAggregatesFilter<"Plant"> | number
    playerId?: IntWithAggregatesFilter<"Plant"> | number
    roundTimeMs?: IntWithAggregatesFilter<"Plant"> | number
    site?: StringWithAggregatesFilter<"Plant"> | string
    locationX?: FloatNullableWithAggregatesFilter<"Plant"> | number | null
    locationY?: FloatNullableWithAggregatesFilter<"Plant"> | number | null
  }

  export type DefuseWhereInput = {
    AND?: DefuseWhereInput | DefuseWhereInput[]
    OR?: DefuseWhereInput[]
    NOT?: DefuseWhereInput | DefuseWhereInput[]
    id?: IntFilter<"Defuse"> | number
    roundId?: IntFilter<"Defuse"> | number
    playerId?: IntFilter<"Defuse"> | number
    roundTimeMs?: IntFilter<"Defuse"> | number
    locationX?: FloatNullableFilter<"Defuse"> | number | null
    locationY?: FloatNullableFilter<"Defuse"> | number | null
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type DefuseOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    round?: RoundOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type DefuseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roundId?: number
    AND?: DefuseWhereInput | DefuseWhereInput[]
    OR?: DefuseWhereInput[]
    NOT?: DefuseWhereInput | DefuseWhereInput[]
    playerId?: IntFilter<"Defuse"> | number
    roundTimeMs?: IntFilter<"Defuse"> | number
    locationX?: FloatNullableFilter<"Defuse"> | number | null
    locationY?: FloatNullableFilter<"Defuse"> | number | null
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "roundId">

  export type DefuseOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    _count?: DefuseCountOrderByAggregateInput
    _avg?: DefuseAvgOrderByAggregateInput
    _max?: DefuseMaxOrderByAggregateInput
    _min?: DefuseMinOrderByAggregateInput
    _sum?: DefuseSumOrderByAggregateInput
  }

  export type DefuseScalarWhereWithAggregatesInput = {
    AND?: DefuseScalarWhereWithAggregatesInput | DefuseScalarWhereWithAggregatesInput[]
    OR?: DefuseScalarWhereWithAggregatesInput[]
    NOT?: DefuseScalarWhereWithAggregatesInput | DefuseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Defuse"> | number
    roundId?: IntWithAggregatesFilter<"Defuse"> | number
    playerId?: IntWithAggregatesFilter<"Defuse"> | number
    roundTimeMs?: IntWithAggregatesFilter<"Defuse"> | number
    locationX?: FloatNullableWithAggregatesFilter<"Defuse"> | number | null
    locationY?: FloatNullableWithAggregatesFilter<"Defuse"> | number | null
  }

  export type RoundPlayerStatsWhereInput = {
    AND?: RoundPlayerStatsWhereInput | RoundPlayerStatsWhereInput[]
    OR?: RoundPlayerStatsWhereInput[]
    NOT?: RoundPlayerStatsWhereInput | RoundPlayerStatsWhereInput[]
    id?: IntFilter<"RoundPlayerStats"> | number
    roundId?: IntFilter<"RoundPlayerStats"> | number
    matchParticipationId?: IntFilter<"RoundPlayerStats"> | number
    playerId?: IntFilter<"RoundPlayerStats"> | number
    score?: IntFilter<"RoundPlayerStats"> | number
    kills?: IntFilter<"RoundPlayerStats"> | number
    headshots?: IntFilter<"RoundPlayerStats"> | number
    bodyshots?: IntFilter<"RoundPlayerStats"> | number
    legshots?: IntFilter<"RoundPlayerStats"> | number
    grenadeCasts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ability1Casts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ability2Casts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ultimateCasts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    loadoutValue?: IntNullableFilter<"RoundPlayerStats"> | number | null
    creditsRemaining?: IntNullableFilter<"RoundPlayerStats"> | number | null
    weaponId?: StringNullableFilter<"RoundPlayerStats"> | string | null
    weaponName?: StringNullableFilter<"RoundPlayerStats"> | string | null
    armorId?: StringNullableFilter<"RoundPlayerStats"> | string | null
    armorName?: StringNullableFilter<"RoundPlayerStats"> | string | null
    createdAt?: DateTimeFilter<"RoundPlayerStats"> | Date | string
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    matchParticipation?: XOR<MatchParticipationScalarRelationFilter, MatchParticipationWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type RoundPlayerStatsOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrderInput | SortOrder
    ability1Casts?: SortOrderInput | SortOrder
    ability2Casts?: SortOrderInput | SortOrder
    ultimateCasts?: SortOrderInput | SortOrder
    loadoutValue?: SortOrderInput | SortOrder
    creditsRemaining?: SortOrderInput | SortOrder
    weaponId?: SortOrderInput | SortOrder
    weaponName?: SortOrderInput | SortOrder
    armorId?: SortOrderInput | SortOrder
    armorName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    round?: RoundOrderByWithRelationInput
    matchParticipation?: MatchParticipationOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type RoundPlayerStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roundId_matchParticipationId?: RoundPlayerStatsRoundIdMatchParticipationIdCompoundUniqueInput
    AND?: RoundPlayerStatsWhereInput | RoundPlayerStatsWhereInput[]
    OR?: RoundPlayerStatsWhereInput[]
    NOT?: RoundPlayerStatsWhereInput | RoundPlayerStatsWhereInput[]
    roundId?: IntFilter<"RoundPlayerStats"> | number
    matchParticipationId?: IntFilter<"RoundPlayerStats"> | number
    playerId?: IntFilter<"RoundPlayerStats"> | number
    score?: IntFilter<"RoundPlayerStats"> | number
    kills?: IntFilter<"RoundPlayerStats"> | number
    headshots?: IntFilter<"RoundPlayerStats"> | number
    bodyshots?: IntFilter<"RoundPlayerStats"> | number
    legshots?: IntFilter<"RoundPlayerStats"> | number
    grenadeCasts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ability1Casts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ability2Casts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ultimateCasts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    loadoutValue?: IntNullableFilter<"RoundPlayerStats"> | number | null
    creditsRemaining?: IntNullableFilter<"RoundPlayerStats"> | number | null
    weaponId?: StringNullableFilter<"RoundPlayerStats"> | string | null
    weaponName?: StringNullableFilter<"RoundPlayerStats"> | string | null
    armorId?: StringNullableFilter<"RoundPlayerStats"> | string | null
    armorName?: StringNullableFilter<"RoundPlayerStats"> | string | null
    createdAt?: DateTimeFilter<"RoundPlayerStats"> | Date | string
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    matchParticipation?: XOR<MatchParticipationScalarRelationFilter, MatchParticipationWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "roundId_matchParticipationId">

  export type RoundPlayerStatsOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrderInput | SortOrder
    ability1Casts?: SortOrderInput | SortOrder
    ability2Casts?: SortOrderInput | SortOrder
    ultimateCasts?: SortOrderInput | SortOrder
    loadoutValue?: SortOrderInput | SortOrder
    creditsRemaining?: SortOrderInput | SortOrder
    weaponId?: SortOrderInput | SortOrder
    weaponName?: SortOrderInput | SortOrder
    armorId?: SortOrderInput | SortOrder
    armorName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoundPlayerStatsCountOrderByAggregateInput
    _avg?: RoundPlayerStatsAvgOrderByAggregateInput
    _max?: RoundPlayerStatsMaxOrderByAggregateInput
    _min?: RoundPlayerStatsMinOrderByAggregateInput
    _sum?: RoundPlayerStatsSumOrderByAggregateInput
  }

  export type RoundPlayerStatsScalarWhereWithAggregatesInput = {
    AND?: RoundPlayerStatsScalarWhereWithAggregatesInput | RoundPlayerStatsScalarWhereWithAggregatesInput[]
    OR?: RoundPlayerStatsScalarWhereWithAggregatesInput[]
    NOT?: RoundPlayerStatsScalarWhereWithAggregatesInput | RoundPlayerStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    roundId?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    matchParticipationId?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    playerId?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    score?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    kills?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    headshots?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    bodyshots?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    legshots?: IntWithAggregatesFilter<"RoundPlayerStats"> | number
    grenadeCasts?: IntNullableWithAggregatesFilter<"RoundPlayerStats"> | number | null
    ability1Casts?: IntNullableWithAggregatesFilter<"RoundPlayerStats"> | number | null
    ability2Casts?: IntNullableWithAggregatesFilter<"RoundPlayerStats"> | number | null
    ultimateCasts?: IntNullableWithAggregatesFilter<"RoundPlayerStats"> | number | null
    loadoutValue?: IntNullableWithAggregatesFilter<"RoundPlayerStats"> | number | null
    creditsRemaining?: IntNullableWithAggregatesFilter<"RoundPlayerStats"> | number | null
    weaponId?: StringNullableWithAggregatesFilter<"RoundPlayerStats"> | string | null
    weaponName?: StringNullableWithAggregatesFilter<"RoundPlayerStats"> | string | null
    armorId?: StringNullableWithAggregatesFilter<"RoundPlayerStats"> | string | null
    armorName?: StringNullableWithAggregatesFilter<"RoundPlayerStats"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoundPlayerStats"> | Date | string
  }

  export type RoundTeamStatsWhereInput = {
    AND?: RoundTeamStatsWhereInput | RoundTeamStatsWhereInput[]
    OR?: RoundTeamStatsWhereInput[]
    NOT?: RoundTeamStatsWhereInput | RoundTeamStatsWhereInput[]
    id?: IntFilter<"RoundTeamStats"> | number
    roundId?: IntFilter<"RoundTeamStats"> | number
    teamId?: IntFilter<"RoundTeamStats"> | number
    teamSide?: StringFilter<"RoundTeamStats"> | string
    won?: BoolFilter<"RoundTeamStats"> | boolean
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type RoundTeamStatsOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    won?: SortOrder
    round?: RoundOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type RoundTeamStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roundId_teamId?: RoundTeamStatsRoundIdTeamIdCompoundUniqueInput
    AND?: RoundTeamStatsWhereInput | RoundTeamStatsWhereInput[]
    OR?: RoundTeamStatsWhereInput[]
    NOT?: RoundTeamStatsWhereInput | RoundTeamStatsWhereInput[]
    roundId?: IntFilter<"RoundTeamStats"> | number
    teamId?: IntFilter<"RoundTeamStats"> | number
    teamSide?: StringFilter<"RoundTeamStats"> | string
    won?: BoolFilter<"RoundTeamStats"> | boolean
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "roundId_teamId">

  export type RoundTeamStatsOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    won?: SortOrder
    _count?: RoundTeamStatsCountOrderByAggregateInput
    _avg?: RoundTeamStatsAvgOrderByAggregateInput
    _max?: RoundTeamStatsMaxOrderByAggregateInput
    _min?: RoundTeamStatsMinOrderByAggregateInput
    _sum?: RoundTeamStatsSumOrderByAggregateInput
  }

  export type RoundTeamStatsScalarWhereWithAggregatesInput = {
    AND?: RoundTeamStatsScalarWhereWithAggregatesInput | RoundTeamStatsScalarWhereWithAggregatesInput[]
    OR?: RoundTeamStatsScalarWhereWithAggregatesInput[]
    NOT?: RoundTeamStatsScalarWhereWithAggregatesInput | RoundTeamStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoundTeamStats"> | number
    roundId?: IntWithAggregatesFilter<"RoundTeamStats"> | number
    teamId?: IntWithAggregatesFilter<"RoundTeamStats"> | number
    teamSide?: StringWithAggregatesFilter<"RoundTeamStats"> | string
    won?: BoolWithAggregatesFilter<"RoundTeamStats"> | boolean
  }

  export type KillWhereInput = {
    AND?: KillWhereInput | KillWhereInput[]
    OR?: KillWhereInput[]
    NOT?: KillWhereInput | KillWhereInput[]
    id?: IntFilter<"Kill"> | number
    matchId?: IntFilter<"Kill"> | number
    roundNumber?: IntFilter<"Kill"> | number
    timeInRoundMs?: IntFilter<"Kill"> | number
    timeInMatchMs?: IntFilter<"Kill"> | number
    killerId?: IntFilter<"Kill"> | number
    victimId?: IntFilter<"Kill"> | number
    locationX?: FloatNullableFilter<"Kill"> | number | null
    locationY?: FloatNullableFilter<"Kill"> | number | null
    weaponId?: StringNullableFilter<"Kill"> | string | null
    weaponName?: StringNullableFilter<"Kill"> | string | null
    weaponType?: StringNullableFilter<"Kill"> | string | null
    secondaryFireMode?: BoolFilter<"Kill"> | boolean
    createdAt?: DateTimeFilter<"Kill"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    killer?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    victim?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    assistants?: PlayerListRelationFilter
  }

  export type KillOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    weaponId?: SortOrderInput | SortOrder
    weaponName?: SortOrderInput | SortOrder
    weaponType?: SortOrderInput | SortOrder
    secondaryFireMode?: SortOrder
    createdAt?: SortOrder
    match?: MatchOrderByWithRelationInput
    killer?: PlayerOrderByWithRelationInput
    victim?: PlayerOrderByWithRelationInput
    assistants?: PlayerOrderByRelationAggregateInput
  }

  export type KillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KillWhereInput | KillWhereInput[]
    OR?: KillWhereInput[]
    NOT?: KillWhereInput | KillWhereInput[]
    matchId?: IntFilter<"Kill"> | number
    roundNumber?: IntFilter<"Kill"> | number
    timeInRoundMs?: IntFilter<"Kill"> | number
    timeInMatchMs?: IntFilter<"Kill"> | number
    killerId?: IntFilter<"Kill"> | number
    victimId?: IntFilter<"Kill"> | number
    locationX?: FloatNullableFilter<"Kill"> | number | null
    locationY?: FloatNullableFilter<"Kill"> | number | null
    weaponId?: StringNullableFilter<"Kill"> | string | null
    weaponName?: StringNullableFilter<"Kill"> | string | null
    weaponType?: StringNullableFilter<"Kill"> | string | null
    secondaryFireMode?: BoolFilter<"Kill"> | boolean
    createdAt?: DateTimeFilter<"Kill"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    killer?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    victim?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    assistants?: PlayerListRelationFilter
  }, "id">

  export type KillOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    weaponId?: SortOrderInput | SortOrder
    weaponName?: SortOrderInput | SortOrder
    weaponType?: SortOrderInput | SortOrder
    secondaryFireMode?: SortOrder
    createdAt?: SortOrder
    _count?: KillCountOrderByAggregateInput
    _avg?: KillAvgOrderByAggregateInput
    _max?: KillMaxOrderByAggregateInput
    _min?: KillMinOrderByAggregateInput
    _sum?: KillSumOrderByAggregateInput
  }

  export type KillScalarWhereWithAggregatesInput = {
    AND?: KillScalarWhereWithAggregatesInput | KillScalarWhereWithAggregatesInput[]
    OR?: KillScalarWhereWithAggregatesInput[]
    NOT?: KillScalarWhereWithAggregatesInput | KillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Kill"> | number
    matchId?: IntWithAggregatesFilter<"Kill"> | number
    roundNumber?: IntWithAggregatesFilter<"Kill"> | number
    timeInRoundMs?: IntWithAggregatesFilter<"Kill"> | number
    timeInMatchMs?: IntWithAggregatesFilter<"Kill"> | number
    killerId?: IntWithAggregatesFilter<"Kill"> | number
    victimId?: IntWithAggregatesFilter<"Kill"> | number
    locationX?: FloatNullableWithAggregatesFilter<"Kill"> | number | null
    locationY?: FloatNullableWithAggregatesFilter<"Kill"> | number | null
    weaponId?: StringNullableWithAggregatesFilter<"Kill"> | string | null
    weaponName?: StringNullableWithAggregatesFilter<"Kill"> | string | null
    weaponType?: StringNullableWithAggregatesFilter<"Kill"> | string | null
    secondaryFireMode?: BoolWithAggregatesFilter<"Kill"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Kill"> | Date | string
  }

  export type TeamRosterWhereInput = {
    AND?: TeamRosterWhereInput | TeamRosterWhereInput[]
    OR?: TeamRosterWhereInput[]
    NOT?: TeamRosterWhereInput | TeamRosterWhereInput[]
    id?: IntFilter<"TeamRoster"> | number
    teamId?: IntFilter<"TeamRoster"> | number
    playerId?: IntFilter<"TeamRoster"> | number
    seasonId?: IntFilter<"TeamRoster"> | number
    startDate?: DateTimeFilter<"TeamRoster"> | Date | string
    endDate?: DateTimeNullableFilter<"TeamRoster"> | Date | string | null
    createdAt?: DateTimeFilter<"TeamRoster"> | Date | string
    updatedAt?: DateTimeFilter<"TeamRoster"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
  }

  export type TeamRosterOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
  }

  export type TeamRosterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerId_teamId_seasonId?: TeamRosterPlayerIdTeamIdSeasonIdCompoundUniqueInput
    AND?: TeamRosterWhereInput | TeamRosterWhereInput[]
    OR?: TeamRosterWhereInput[]
    NOT?: TeamRosterWhereInput | TeamRosterWhereInput[]
    teamId?: IntFilter<"TeamRoster"> | number
    playerId?: IntFilter<"TeamRoster"> | number
    seasonId?: IntFilter<"TeamRoster"> | number
    startDate?: DateTimeFilter<"TeamRoster"> | Date | string
    endDate?: DateTimeNullableFilter<"TeamRoster"> | Date | string | null
    createdAt?: DateTimeFilter<"TeamRoster"> | Date | string
    updatedAt?: DateTimeFilter<"TeamRoster"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
  }, "id" | "playerId_teamId_seasonId">

  export type TeamRosterOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamRosterCountOrderByAggregateInput
    _avg?: TeamRosterAvgOrderByAggregateInput
    _max?: TeamRosterMaxOrderByAggregateInput
    _min?: TeamRosterMinOrderByAggregateInput
    _sum?: TeamRosterSumOrderByAggregateInput
  }

  export type TeamRosterScalarWhereWithAggregatesInput = {
    AND?: TeamRosterScalarWhereWithAggregatesInput | TeamRosterScalarWhereWithAggregatesInput[]
    OR?: TeamRosterScalarWhereWithAggregatesInput[]
    NOT?: TeamRosterScalarWhereWithAggregatesInput | TeamRosterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamRoster"> | number
    teamId?: IntWithAggregatesFilter<"TeamRoster"> | number
    playerId?: IntWithAggregatesFilter<"TeamRoster"> | number
    seasonId?: IntWithAggregatesFilter<"TeamRoster"> | number
    startDate?: DateTimeWithAggregatesFilter<"TeamRoster"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"TeamRoster"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TeamRoster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamRoster"> | Date | string
  }

  export type SubstitutionWhereInput = {
    AND?: SubstitutionWhereInput | SubstitutionWhereInput[]
    OR?: SubstitutionWhereInput[]
    NOT?: SubstitutionWhereInput | SubstitutionWhereInput[]
    id?: IntFilter<"Substitution"> | number
    matchId?: IntFilter<"Substitution"> | number
    teamId?: IntFilter<"Substitution"> | number
    substitutedInId?: IntFilter<"Substitution"> | number
    substitutedOutId?: IntFilter<"Substitution"> | number
    timestamp?: DateTimeFilter<"Substitution"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    substitutedIn?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    substitutedOut?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type SubstitutionOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
    timestamp?: SortOrder
    match?: MatchOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    substitutedIn?: PlayerOrderByWithRelationInput
    substitutedOut?: PlayerOrderByWithRelationInput
  }

  export type SubstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubstitutionWhereInput | SubstitutionWhereInput[]
    OR?: SubstitutionWhereInput[]
    NOT?: SubstitutionWhereInput | SubstitutionWhereInput[]
    matchId?: IntFilter<"Substitution"> | number
    teamId?: IntFilter<"Substitution"> | number
    substitutedInId?: IntFilter<"Substitution"> | number
    substitutedOutId?: IntFilter<"Substitution"> | number
    timestamp?: DateTimeFilter<"Substitution"> | Date | string
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    substitutedIn?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    substitutedOut?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id">

  export type SubstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
    timestamp?: SortOrder
    _count?: SubstitutionCountOrderByAggregateInput
    _avg?: SubstitutionAvgOrderByAggregateInput
    _max?: SubstitutionMaxOrderByAggregateInput
    _min?: SubstitutionMinOrderByAggregateInput
    _sum?: SubstitutionSumOrderByAggregateInput
  }

  export type SubstitutionScalarWhereWithAggregatesInput = {
    AND?: SubstitutionScalarWhereWithAggregatesInput | SubstitutionScalarWhereWithAggregatesInput[]
    OR?: SubstitutionScalarWhereWithAggregatesInput[]
    NOT?: SubstitutionScalarWhereWithAggregatesInput | SubstitutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Substitution"> | number
    matchId?: IntWithAggregatesFilter<"Substitution"> | number
    teamId?: IntWithAggregatesFilter<"Substitution"> | number
    substitutedInId?: IntWithAggregatesFilter<"Substitution"> | number
    substitutedOutId?: IntWithAggregatesFilter<"Substitution"> | number
    timestamp?: DateTimeWithAggregatesFilter<"Substitution"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipations?: MatchParticipationCreateNestedManyWithoutAgentInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutAgentInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipations?: MatchParticipationUpdateManyWithoutAgentNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutAgentNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchCreateNestedManyWithoutMapInput
  }

  export type MapUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutMapInput
  }

  export type MapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutMapNestedInput
  }

  export type MapCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateInput = {
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutSeasonsInput
    series?: SeriesCreateNestedManyWithoutSeasonInput
    teamRosters?: TeamRosterCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: number
    leagueId: number
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutSeasonInput
    teamRosters?: TeamRosterUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutSeasonsNestedInput
    series?: SeriesUpdateManyWithoutSeasonNestedInput
    teamRosters?: TeamRosterUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutSeasonNestedInput
    teamRosters?: TeamRosterUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonCreateManyInput = {
    id?: number
    leagueId: number
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesCreateInput = {
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season: SeasonCreateNestedOneWithoutSeriesInput
    redTeam: TeamCreateNestedOneWithoutRedSeriesInput
    blueTeam: TeamCreateNestedOneWithoutBlueSeriesInput
    matches?: MatchCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateInput = {
    id?: number
    seasonId: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUpdateInput = {
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneRequiredWithoutSeriesNestedInput
    redTeam?: TeamUpdateOneRequiredWithoutRedSeriesNestedInput
    blueTeam?: TeamUpdateOneRequiredWithoutBlueSeriesNestedInput
    matches?: MatchUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesCreateManyInput = {
    id?: number
    seasonId: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesUpdateManyMutationInput = {
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchParticipationCreateInput = {
    teamSide: string
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutParticipationsInput
    player: PlayerCreateNestedOneWithoutMatchParticipationsInput
    team: TeamCreateNestedOneWithoutMatchParticipationsInput
    agent?: AgentCreateNestedOneWithoutMatchParticipationsInput
    matchStats?: MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateInput = {
    id?: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
    matchStats?: MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUpdateInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutParticipationsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput
    agent?: AgentUpdateOneWithoutMatchParticipationsNestedInput
    matchStats?: MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchStats?: MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationCreateManyInput = {
    id?: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
  }

  export type MatchParticipationUpdateManyMutationInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchParticipationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsCreateInput = {
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipation: MatchParticipationCreateNestedOneWithoutMatchStatsInput
    match: MatchCreateNestedOneWithoutMatchPlayerStatsInput
    player: PlayerCreateNestedOneWithoutMatchStatsInput
    Agent?: AgentCreateNestedOneWithoutMatchPlayerStatsInput
  }

  export type MatchPlayerStatsUncheckedCreateInput = {
    id?: number
    matchParticipationId: number
    matchId: number
    playerId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsUpdateInput = {
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutMatchStatsNestedInput
    match?: MatchUpdateOneRequiredWithoutMatchPlayerStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchStatsNestedInput
    Agent?: AgentUpdateOneWithoutMatchPlayerStatsNestedInput
  }

  export type MatchPlayerStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsCreateManyInput = {
    id?: number
    matchParticipationId: number
    matchId: number
    playerId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsUpdateManyMutationInput = {
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsCreateInput = {
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutMatchTeamStatsInput
    team: TeamCreateNestedOneWithoutTeamStatsInput
  }

  export type MatchTeamStatsUncheckedCreateInput = {
    id?: number
    matchId: number
    teamId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchTeamStatsUpdateInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutMatchTeamStatsNestedInput
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
  }

  export type MatchTeamStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsCreateManyInput = {
    id?: number
    matchId: number
    teamId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchTeamStatsUpdateManyMutationInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundCreateInput = {
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutRoundsInput
    plant?: PlantCreateNestedOneWithoutRoundInput
    defuse?: DefuseCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateInput = {
    id?: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plant?: PlantUncheckedCreateNestedOneWithoutRoundInput
    defuse?: DefuseUncheckedCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundUpdateInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutRoundsNestedInput
    plant?: PlantUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantUncheckedUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUncheckedUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUncheckedUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type RoundCreateManyInput = {
    id?: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUpdateManyMutationInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantCreateInput = {
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
    round: RoundCreateNestedOneWithoutPlantInput
    player: PlayerCreateNestedOneWithoutPlantsInput
  }

  export type PlantUncheckedCreateInput = {
    id?: number
    roundId: number
    playerId: number
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
  }

  export type PlantUpdateInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    round?: RoundUpdateOneRequiredWithoutPlantNestedInput
    player?: PlayerUpdateOneRequiredWithoutPlantsNestedInput
  }

  export type PlantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PlantCreateManyInput = {
    id?: number
    roundId: number
    playerId: number
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
  }

  export type PlantUpdateManyMutationInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PlantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefuseCreateInput = {
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
    round: RoundCreateNestedOneWithoutDefuseInput
    player: PlayerCreateNestedOneWithoutDefusesInput
  }

  export type DefuseUncheckedCreateInput = {
    id?: number
    roundId: number
    playerId: number
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
  }

  export type DefuseUpdateInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    round?: RoundUpdateOneRequiredWithoutDefuseNestedInput
    player?: PlayerUpdateOneRequiredWithoutDefusesNestedInput
  }

  export type DefuseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefuseCreateManyInput = {
    id?: number
    roundId: number
    playerId: number
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
  }

  export type DefuseUpdateManyMutationInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefuseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RoundPlayerStatsCreateInput = {
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
    round: RoundCreateNestedOneWithoutPlayerStatsInput
    matchParticipation: MatchParticipationCreateNestedOneWithoutRoundStatsInput
    player: PlayerCreateNestedOneWithoutRoundStatsInput
  }

  export type RoundPlayerStatsUncheckedCreateInput = {
    id?: number
    roundId: number
    matchParticipationId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundPlayerStatsUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: RoundUpdateOneRequiredWithoutPlayerStatsNestedInput
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutRoundStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutRoundStatsNestedInput
  }

  export type RoundPlayerStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsCreateManyInput = {
    id?: number
    roundId: number
    matchParticipationId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundPlayerStatsUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundTeamStatsCreateInput = {
    teamSide: string
    won: boolean
    round: RoundCreateNestedOneWithoutTeamStatsInput
    team: TeamCreateNestedOneWithoutRoundStatsInput
  }

  export type RoundTeamStatsUncheckedCreateInput = {
    id?: number
    roundId: number
    teamId: number
    teamSide: string
    won: boolean
  }

  export type RoundTeamStatsUpdateInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
    round?: RoundUpdateOneRequiredWithoutTeamStatsNestedInput
    team?: TeamUpdateOneRequiredWithoutRoundStatsNestedInput
  }

  export type RoundTeamStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoundTeamStatsCreateManyInput = {
    id?: number
    roundId: number
    teamId: number
    teamSide: string
    won: boolean
  }

  export type RoundTeamStatsUpdateManyMutationInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoundTeamStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KillCreateInput = {
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutKillsInput
    killer: PlayerCreateNestedOneWithoutKillsInput
    victim: PlayerCreateNestedOneWithoutDeathsInput
    assistants?: PlayerCreateNestedManyWithoutKillAssistsInput
  }

  export type KillUncheckedCreateInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    assistants?: PlayerUncheckedCreateNestedManyWithoutKillAssistsInput
  }

  export type KillUpdateInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutKillsNestedInput
    killer?: PlayerUpdateOneRequiredWithoutKillsNestedInput
    victim?: PlayerUpdateOneRequiredWithoutDeathsNestedInput
    assistants?: PlayerUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: PlayerUncheckedUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillCreateManyInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
  }

  export type KillUpdateManyMutationInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterCreateInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutRostersInput
    player: PlayerCreateNestedOneWithoutRostersInput
    season: SeasonCreateNestedOneWithoutTeamRostersInput
  }

  export type TeamRosterUncheckedCreateInput = {
    id?: number
    teamId: number
    playerId: number
    seasonId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamRosterUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutRostersNestedInput
    player?: PlayerUpdateOneRequiredWithoutRostersNestedInput
    season?: SeasonUpdateOneRequiredWithoutTeamRostersNestedInput
  }

  export type TeamRosterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterCreateManyInput = {
    id?: number
    teamId: number
    playerId: number
    seasonId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamRosterUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionCreateInput = {
    timestamp?: Date | string
    match: MatchCreateNestedOneWithoutSubstitutionsInput
    team: TeamCreateNestedOneWithoutSubstitutionsInput
    substitutedIn: PlayerCreateNestedOneWithoutSubInsInput
    substitutedOut: PlayerCreateNestedOneWithoutSubOutsInput
  }

  export type SubstitutionUncheckedCreateInput = {
    id?: number
    matchId: number
    teamId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type SubstitutionUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutSubstitutionsNestedInput
    team?: TeamUpdateOneRequiredWithoutSubstitutionsNestedInput
    substitutedIn?: PlayerUpdateOneRequiredWithoutSubInsNestedInput
    substitutedOut?: PlayerUpdateOneRequiredWithoutSubOutsNestedInput
  }

  export type SubstitutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionCreateManyInput = {
    id?: number
    matchId: number
    teamId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type SubstitutionUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MatchParticipationListRelationFilter = {
    every?: MatchParticipationWhereInput
    some?: MatchParticipationWhereInput
    none?: MatchParticipationWhereInput
  }

  export type MatchPlayerStatsListRelationFilter = {
    every?: MatchPlayerStatsWhereInput
    some?: MatchPlayerStatsWhereInput
    none?: MatchPlayerStatsWhereInput
  }

  export type MatchParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchPlayerStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonListRelationFilter = {
    every?: SeasonWhereInput
    some?: SeasonWhereInput
    none?: SeasonWhereInput
  }

  export type SeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeagueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeagueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LeagueScalarRelationFilter = {
    is?: LeagueWhereInput
    isNot?: LeagueWhereInput
  }

  export type SeriesListRelationFilter = {
    every?: SeriesWhereInput
    some?: SeriesWhereInput
    none?: SeriesWhereInput
  }

  export type TeamRosterListRelationFilter = {
    every?: TeamRosterWhereInput
    some?: TeamRosterWhereInput
    none?: TeamRosterWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SeriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamRosterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonLeagueIdNameCompoundUniqueInput = {
    leagueId: number
    name: string
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MatchTeamStatsListRelationFilter = {
    every?: MatchTeamStatsWhereInput
    some?: MatchTeamStatsWhereInput
    none?: MatchTeamStatsWhereInput
  }

  export type SubstitutionListRelationFilter = {
    every?: SubstitutionWhereInput
    some?: SubstitutionWhereInput
    none?: SubstitutionWhereInput
  }

  export type RoundTeamStatsListRelationFilter = {
    every?: RoundTeamStatsWhereInput
    some?: RoundTeamStatsWhereInput
    none?: RoundTeamStatsWhereInput
  }

  export type MatchTeamStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoundTeamStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlantListRelationFilter = {
    every?: PlantWhereInput
    some?: PlantWhereInput
    none?: PlantWhereInput
  }

  export type DefuseListRelationFilter = {
    every?: DefuseWhereInput
    some?: DefuseWhereInput
    none?: DefuseWhereInput
  }

  export type RoundPlayerStatsListRelationFilter = {
    every?: RoundPlayerStatsWhereInput
    some?: RoundPlayerStatsWhereInput
    none?: RoundPlayerStatsWhereInput
  }

  export type KillListRelationFilter = {
    every?: KillWhereInput
    some?: KillWhereInput
    none?: KillWhereInput
  }

  export type PlantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefuseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoundPlayerStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerNameTagCompoundUniqueInput = {
    name: string
    tag: string
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    puuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    puuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    puuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SeasonScalarRelationFilter = {
    is?: SeasonWhereInput
    isNot?: SeasonWhereInput
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type SeriesCountOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesAvgOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrder
  }

  export type SeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesMinOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesSumOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    redTeamId?: SortOrder
    blueTeamId?: SortOrder
    bestOf?: SortOrder
    winnerTeamId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SeriesScalarRelationFilter = {
    is?: SeriesWhereInput
    isNot?: SeriesWhereInput
  }

  export type MapScalarRelationFilter = {
    is?: MapWhereInput
    isNot?: MapWhereInput
  }

  export type RoundListRelationFilter = {
    every?: RoundWhereInput
    some?: RoundWhereInput
    none?: RoundWhereInput
  }

  export type RoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchSeriesIdMatchNumberCompoundUniqueInput = {
    seriesId: number
    matchNumber: number
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    riotMatchId?: SortOrder
    mapId?: SortOrder
    gameLengthMs?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    isCompleted?: SortOrder
    status?: SortOrder
    winnerTeamSide?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    gameLengthMs?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    riotMatchId?: SortOrder
    mapId?: SortOrder
    gameLengthMs?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    isCompleted?: SortOrder
    status?: SortOrder
    winnerTeamSide?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    riotMatchId?: SortOrder
    mapId?: SortOrder
    gameLengthMs?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    isCompleted?: SortOrder
    status?: SortOrder
    winnerTeamSide?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    matchNumber?: SortOrder
    gameLengthMs?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MatchScalarRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type PlayerScalarRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type MatchPlayerStatsNullableScalarRelationFilter = {
    is?: MatchPlayerStatsWhereInput | null
    isNot?: MatchPlayerStatsWhereInput | null
  }

  export type MatchParticipationMatchIdPlayerIdCompoundUniqueInput = {
    matchId: number
    playerId: number
  }

  export type MatchParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchParticipationAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
  }

  export type MatchParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchParticipationSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MatchParticipationScalarRelationFilter = {
    is?: MatchParticipationWhereInput
    isNot?: MatchParticipationWhereInput
  }

  export type MatchPlayerStatsCountOrderByAggregateInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    agentId?: SortOrder
    agentName?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrder
    acs?: SortOrder
    kd?: SortOrder
    hsPercent?: SortOrder
    kast?: SortOrder
    firstKills?: SortOrder
    firstDeaths?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    spentOverall?: SortOrder
    spentAverage?: SortOrder
    loadoutOverall?: SortOrder
    loadoutAverage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchPlayerStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrder
    acs?: SortOrder
    kd?: SortOrder
    hsPercent?: SortOrder
    kast?: SortOrder
    firstKills?: SortOrder
    firstDeaths?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    spentOverall?: SortOrder
    spentAverage?: SortOrder
    loadoutOverall?: SortOrder
    loadoutAverage?: SortOrder
  }

  export type MatchPlayerStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    agentId?: SortOrder
    agentName?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrder
    acs?: SortOrder
    kd?: SortOrder
    hsPercent?: SortOrder
    kast?: SortOrder
    firstKills?: SortOrder
    firstDeaths?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    spentOverall?: SortOrder
    spentAverage?: SortOrder
    loadoutOverall?: SortOrder
    loadoutAverage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchPlayerStatsMinOrderByAggregateInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    agentId?: SortOrder
    agentName?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrder
    acs?: SortOrder
    kd?: SortOrder
    hsPercent?: SortOrder
    kast?: SortOrder
    firstKills?: SortOrder
    firstDeaths?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    spentOverall?: SortOrder
    spentAverage?: SortOrder
    loadoutOverall?: SortOrder
    loadoutAverage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchPlayerStatsSumOrderByAggregateInput = {
    id?: SortOrder
    matchParticipationId?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    adr?: SortOrder
    acs?: SortOrder
    kd?: SortOrder
    hsPercent?: SortOrder
    kast?: SortOrder
    firstKills?: SortOrder
    firstDeaths?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    spentOverall?: SortOrder
    spentAverage?: SortOrder
    loadoutOverall?: SortOrder
    loadoutAverage?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MatchTeamStatsMatchIdTeamIdCompoundUniqueInput = {
    matchId: number
    teamId: number
  }

  export type MatchTeamStatsCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
    won?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchTeamStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
  }

  export type MatchTeamStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
    won?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchTeamStatsMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
    won?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchTeamStatsSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    roundsWon?: SortOrder
    roundsLost?: SortOrder
  }

  export type PlantNullableScalarRelationFilter = {
    is?: PlantWhereInput | null
    isNot?: PlantWhereInput | null
  }

  export type DefuseNullableScalarRelationFilter = {
    is?: DefuseWhereInput | null
    isNot?: DefuseWhereInput | null
  }

  export type RoundMatchIdRoundNumberCompoundUniqueInput = {
    matchId: number
    roundNumber: number
  }

  export type RoundCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
  }

  export type RoundMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
  }

  export type RoundScalarRelationFilter = {
    is?: RoundWhereInput
    isNot?: RoundWhereInput
  }

  export type PlantCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    site?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type PlantAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type PlantMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    site?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type PlantMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    site?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type PlantSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type DefuseCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type DefuseAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type DefuseMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type DefuseMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type DefuseSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    playerId?: SortOrder
    roundTimeMs?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type RoundPlayerStatsRoundIdMatchParticipationIdCompoundUniqueInput = {
    roundId: number
    matchParticipationId: number
  }

  export type RoundPlayerStatsCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    loadoutValue?: SortOrder
    creditsRemaining?: SortOrder
    weaponId?: SortOrder
    weaponName?: SortOrder
    armorId?: SortOrder
    armorName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoundPlayerStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    loadoutValue?: SortOrder
    creditsRemaining?: SortOrder
  }

  export type RoundPlayerStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    loadoutValue?: SortOrder
    creditsRemaining?: SortOrder
    weaponId?: SortOrder
    weaponName?: SortOrder
    armorId?: SortOrder
    armorName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoundPlayerStatsMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    loadoutValue?: SortOrder
    creditsRemaining?: SortOrder
    weaponId?: SortOrder
    weaponName?: SortOrder
    armorId?: SortOrder
    armorName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoundPlayerStatsSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    matchParticipationId?: SortOrder
    playerId?: SortOrder
    score?: SortOrder
    kills?: SortOrder
    headshots?: SortOrder
    bodyshots?: SortOrder
    legshots?: SortOrder
    grenadeCasts?: SortOrder
    ability1Casts?: SortOrder
    ability2Casts?: SortOrder
    ultimateCasts?: SortOrder
    loadoutValue?: SortOrder
    creditsRemaining?: SortOrder
  }

  export type RoundTeamStatsRoundIdTeamIdCompoundUniqueInput = {
    roundId: number
    teamId: number
  }

  export type RoundTeamStatsCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    won?: SortOrder
  }

  export type RoundTeamStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
  }

  export type RoundTeamStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    won?: SortOrder
  }

  export type RoundTeamStatsMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    teamSide?: SortOrder
    won?: SortOrder
  }

  export type RoundTeamStatsSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KillCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
    weaponId?: SortOrder
    weaponName?: SortOrder
    weaponType?: SortOrder
    secondaryFireMode?: SortOrder
    createdAt?: SortOrder
  }

  export type KillAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type KillMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
    weaponId?: SortOrder
    weaponName?: SortOrder
    weaponType?: SortOrder
    secondaryFireMode?: SortOrder
    createdAt?: SortOrder
  }

  export type KillMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
    weaponId?: SortOrder
    weaponName?: SortOrder
    weaponType?: SortOrder
    secondaryFireMode?: SortOrder
    createdAt?: SortOrder
  }

  export type KillSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    roundNumber?: SortOrder
    timeInRoundMs?: SortOrder
    timeInMatchMs?: SortOrder
    killerId?: SortOrder
    victimId?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type TeamRosterPlayerIdTeamIdSeasonIdCompoundUniqueInput = {
    playerId: number
    teamId: number
    seasonId: number
  }

  export type TeamRosterCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamRosterAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
  }

  export type TeamRosterMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamRosterMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamRosterSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    seasonId?: SortOrder
  }

  export type SubstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
    timestamp?: SortOrder
  }

  export type SubstitutionAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
  }

  export type SubstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
    timestamp?: SortOrder
  }

  export type SubstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
    timestamp?: SortOrder
  }

  export type SubstitutionSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    substitutedInId?: SortOrder
    substitutedOutId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MatchParticipationCreateNestedManyWithoutAgentInput = {
    create?: XOR<MatchParticipationCreateWithoutAgentInput, MatchParticipationUncheckedCreateWithoutAgentInput> | MatchParticipationCreateWithoutAgentInput[] | MatchParticipationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutAgentInput | MatchParticipationCreateOrConnectWithoutAgentInput[]
    createMany?: MatchParticipationCreateManyAgentInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type MatchPlayerStatsCreateNestedManyWithoutAgentInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutAgentInput, MatchPlayerStatsUncheckedCreateWithoutAgentInput> | MatchPlayerStatsCreateWithoutAgentInput[] | MatchPlayerStatsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutAgentInput | MatchPlayerStatsCreateOrConnectWithoutAgentInput[]
    createMany?: MatchPlayerStatsCreateManyAgentInputEnvelope
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
  }

  export type MatchParticipationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MatchParticipationCreateWithoutAgentInput, MatchParticipationUncheckedCreateWithoutAgentInput> | MatchParticipationCreateWithoutAgentInput[] | MatchParticipationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutAgentInput | MatchParticipationCreateOrConnectWithoutAgentInput[]
    createMany?: MatchParticipationCreateManyAgentInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type MatchPlayerStatsUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutAgentInput, MatchPlayerStatsUncheckedCreateWithoutAgentInput> | MatchPlayerStatsCreateWithoutAgentInput[] | MatchPlayerStatsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutAgentInput | MatchPlayerStatsCreateOrConnectWithoutAgentInput[]
    createMany?: MatchPlayerStatsCreateManyAgentInputEnvelope
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
  }

  export type MatchParticipationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutAgentInput, MatchParticipationUncheckedCreateWithoutAgentInput> | MatchParticipationCreateWithoutAgentInput[] | MatchParticipationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutAgentInput | MatchParticipationCreateOrConnectWithoutAgentInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutAgentInput | MatchParticipationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MatchParticipationCreateManyAgentInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutAgentInput | MatchParticipationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutAgentInput | MatchParticipationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type MatchPlayerStatsUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutAgentInput, MatchPlayerStatsUncheckedCreateWithoutAgentInput> | MatchPlayerStatsCreateWithoutAgentInput[] | MatchPlayerStatsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutAgentInput | MatchPlayerStatsCreateOrConnectWithoutAgentInput[]
    upsert?: MatchPlayerStatsUpsertWithWhereUniqueWithoutAgentInput | MatchPlayerStatsUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MatchPlayerStatsCreateManyAgentInputEnvelope
    set?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    disconnect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    delete?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    update?: MatchPlayerStatsUpdateWithWhereUniqueWithoutAgentInput | MatchPlayerStatsUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MatchPlayerStatsUpdateManyWithWhereWithoutAgentInput | MatchPlayerStatsUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
  }

  export type MatchParticipationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutAgentInput, MatchParticipationUncheckedCreateWithoutAgentInput> | MatchParticipationCreateWithoutAgentInput[] | MatchParticipationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutAgentInput | MatchParticipationCreateOrConnectWithoutAgentInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutAgentInput | MatchParticipationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MatchParticipationCreateManyAgentInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutAgentInput | MatchParticipationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutAgentInput | MatchParticipationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type MatchPlayerStatsUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutAgentInput, MatchPlayerStatsUncheckedCreateWithoutAgentInput> | MatchPlayerStatsCreateWithoutAgentInput[] | MatchPlayerStatsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutAgentInput | MatchPlayerStatsCreateOrConnectWithoutAgentInput[]
    upsert?: MatchPlayerStatsUpsertWithWhereUniqueWithoutAgentInput | MatchPlayerStatsUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MatchPlayerStatsCreateManyAgentInputEnvelope
    set?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    disconnect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    delete?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    update?: MatchPlayerStatsUpdateWithWhereUniqueWithoutAgentInput | MatchPlayerStatsUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MatchPlayerStatsUpdateManyWithWhereWithoutAgentInput | MatchPlayerStatsUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
  }

  export type MatchCreateNestedManyWithoutMapInput = {
    create?: XOR<MatchCreateWithoutMapInput, MatchUncheckedCreateWithoutMapInput> | MatchCreateWithoutMapInput[] | MatchUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutMapInput | MatchCreateOrConnectWithoutMapInput[]
    createMany?: MatchCreateManyMapInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<MatchCreateWithoutMapInput, MatchUncheckedCreateWithoutMapInput> | MatchCreateWithoutMapInput[] | MatchUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutMapInput | MatchCreateOrConnectWithoutMapInput[]
    createMany?: MatchCreateManyMapInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUpdateManyWithoutMapNestedInput = {
    create?: XOR<MatchCreateWithoutMapInput, MatchUncheckedCreateWithoutMapInput> | MatchCreateWithoutMapInput[] | MatchUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutMapInput | MatchCreateOrConnectWithoutMapInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutMapInput | MatchUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: MatchCreateManyMapInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutMapInput | MatchUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutMapInput | MatchUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<MatchCreateWithoutMapInput, MatchUncheckedCreateWithoutMapInput> | MatchCreateWithoutMapInput[] | MatchUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutMapInput | MatchCreateOrConnectWithoutMapInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutMapInput | MatchUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: MatchCreateManyMapInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutMapInput | MatchUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutMapInput | MatchUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type SeasonCreateNestedManyWithoutLeagueInput = {
    create?: XOR<SeasonCreateWithoutLeagueInput, SeasonUncheckedCreateWithoutLeagueInput> | SeasonCreateWithoutLeagueInput[] | SeasonUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutLeagueInput | SeasonCreateOrConnectWithoutLeagueInput[]
    createMany?: SeasonCreateManyLeagueInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type SeasonUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<SeasonCreateWithoutLeagueInput, SeasonUncheckedCreateWithoutLeagueInput> | SeasonCreateWithoutLeagueInput[] | SeasonUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutLeagueInput | SeasonCreateOrConnectWithoutLeagueInput[]
    createMany?: SeasonCreateManyLeagueInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type SeasonUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<SeasonCreateWithoutLeagueInput, SeasonUncheckedCreateWithoutLeagueInput> | SeasonCreateWithoutLeagueInput[] | SeasonUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutLeagueInput | SeasonCreateOrConnectWithoutLeagueInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutLeagueInput | SeasonUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: SeasonCreateManyLeagueInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutLeagueInput | SeasonUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutLeagueInput | SeasonUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type SeasonUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<SeasonCreateWithoutLeagueInput, SeasonUncheckedCreateWithoutLeagueInput> | SeasonCreateWithoutLeagueInput[] | SeasonUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutLeagueInput | SeasonCreateOrConnectWithoutLeagueInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutLeagueInput | SeasonUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: SeasonCreateManyLeagueInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutLeagueInput | SeasonUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutLeagueInput | SeasonUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type LeagueCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<LeagueCreateWithoutSeasonsInput, LeagueUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutSeasonsInput
    connect?: LeagueWhereUniqueInput
  }

  export type SeriesCreateNestedManyWithoutSeasonInput = {
    create?: XOR<SeriesCreateWithoutSeasonInput, SeriesUncheckedCreateWithoutSeasonInput> | SeriesCreateWithoutSeasonInput[] | SeriesUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutSeasonInput | SeriesCreateOrConnectWithoutSeasonInput[]
    createMany?: SeriesCreateManySeasonInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type TeamRosterCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TeamRosterCreateWithoutSeasonInput, TeamRosterUncheckedCreateWithoutSeasonInput> | TeamRosterCreateWithoutSeasonInput[] | TeamRosterUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutSeasonInput | TeamRosterCreateOrConnectWithoutSeasonInput[]
    createMany?: TeamRosterCreateManySeasonInputEnvelope
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<SeriesCreateWithoutSeasonInput, SeriesUncheckedCreateWithoutSeasonInput> | SeriesCreateWithoutSeasonInput[] | SeriesUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutSeasonInput | SeriesCreateOrConnectWithoutSeasonInput[]
    createMany?: SeriesCreateManySeasonInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type TeamRosterUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TeamRosterCreateWithoutSeasonInput, TeamRosterUncheckedCreateWithoutSeasonInput> | TeamRosterCreateWithoutSeasonInput[] | TeamRosterUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutSeasonInput | TeamRosterCreateOrConnectWithoutSeasonInput[]
    createMany?: TeamRosterCreateManySeasonInputEnvelope
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type LeagueUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<LeagueCreateWithoutSeasonsInput, LeagueUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutSeasonsInput
    upsert?: LeagueUpsertWithoutSeasonsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutSeasonsInput, LeagueUpdateWithoutSeasonsInput>, LeagueUncheckedUpdateWithoutSeasonsInput>
  }

  export type SeriesUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<SeriesCreateWithoutSeasonInput, SeriesUncheckedCreateWithoutSeasonInput> | SeriesCreateWithoutSeasonInput[] | SeriesUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutSeasonInput | SeriesCreateOrConnectWithoutSeasonInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutSeasonInput | SeriesUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: SeriesCreateManySeasonInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutSeasonInput | SeriesUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutSeasonInput | SeriesUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type TeamRosterUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TeamRosterCreateWithoutSeasonInput, TeamRosterUncheckedCreateWithoutSeasonInput> | TeamRosterCreateWithoutSeasonInput[] | TeamRosterUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutSeasonInput | TeamRosterCreateOrConnectWithoutSeasonInput[]
    upsert?: TeamRosterUpsertWithWhereUniqueWithoutSeasonInput | TeamRosterUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TeamRosterCreateManySeasonInputEnvelope
    set?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    disconnect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    delete?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    update?: TeamRosterUpdateWithWhereUniqueWithoutSeasonInput | TeamRosterUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TeamRosterUpdateManyWithWhereWithoutSeasonInput | TeamRosterUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<SeriesCreateWithoutSeasonInput, SeriesUncheckedCreateWithoutSeasonInput> | SeriesCreateWithoutSeasonInput[] | SeriesUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutSeasonInput | SeriesCreateOrConnectWithoutSeasonInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutSeasonInput | SeriesUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: SeriesCreateManySeasonInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutSeasonInput | SeriesUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutSeasonInput | SeriesUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type TeamRosterUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TeamRosterCreateWithoutSeasonInput, TeamRosterUncheckedCreateWithoutSeasonInput> | TeamRosterCreateWithoutSeasonInput[] | TeamRosterUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutSeasonInput | TeamRosterCreateOrConnectWithoutSeasonInput[]
    upsert?: TeamRosterUpsertWithWhereUniqueWithoutSeasonInput | TeamRosterUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TeamRosterCreateManySeasonInputEnvelope
    set?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    disconnect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    delete?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    update?: TeamRosterUpdateWithWhereUniqueWithoutSeasonInput | TeamRosterUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TeamRosterUpdateManyWithWhereWithoutSeasonInput | TeamRosterUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
  }

  export type TeamRosterCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamRosterCreateWithoutTeamInput, TeamRosterUncheckedCreateWithoutTeamInput> | TeamRosterCreateWithoutTeamInput[] | TeamRosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutTeamInput | TeamRosterCreateOrConnectWithoutTeamInput[]
    createMany?: TeamRosterCreateManyTeamInputEnvelope
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
  }

  export type SeriesCreateNestedManyWithoutRedTeamInput = {
    create?: XOR<SeriesCreateWithoutRedTeamInput, SeriesUncheckedCreateWithoutRedTeamInput> | SeriesCreateWithoutRedTeamInput[] | SeriesUncheckedCreateWithoutRedTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRedTeamInput | SeriesCreateOrConnectWithoutRedTeamInput[]
    createMany?: SeriesCreateManyRedTeamInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type SeriesCreateNestedManyWithoutBlueTeamInput = {
    create?: XOR<SeriesCreateWithoutBlueTeamInput, SeriesUncheckedCreateWithoutBlueTeamInput> | SeriesCreateWithoutBlueTeamInput[] | SeriesUncheckedCreateWithoutBlueTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutBlueTeamInput | SeriesCreateOrConnectWithoutBlueTeamInput[]
    createMany?: SeriesCreateManyBlueTeamInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type MatchTeamStatsCreateNestedManyWithoutTeamInput = {
    create?: XOR<MatchTeamStatsCreateWithoutTeamInput, MatchTeamStatsUncheckedCreateWithoutTeamInput> | MatchTeamStatsCreateWithoutTeamInput[] | MatchTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutTeamInput | MatchTeamStatsCreateOrConnectWithoutTeamInput[]
    createMany?: MatchTeamStatsCreateManyTeamInputEnvelope
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
  }

  export type SubstitutionCreateNestedManyWithoutTeamInput = {
    create?: XOR<SubstitutionCreateWithoutTeamInput, SubstitutionUncheckedCreateWithoutTeamInput> | SubstitutionCreateWithoutTeamInput[] | SubstitutionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutTeamInput | SubstitutionCreateOrConnectWithoutTeamInput[]
    createMany?: SubstitutionCreateManyTeamInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type RoundTeamStatsCreateNestedManyWithoutTeamInput = {
    create?: XOR<RoundTeamStatsCreateWithoutTeamInput, RoundTeamStatsUncheckedCreateWithoutTeamInput> | RoundTeamStatsCreateWithoutTeamInput[] | RoundTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutTeamInput | RoundTeamStatsCreateOrConnectWithoutTeamInput[]
    createMany?: RoundTeamStatsCreateManyTeamInputEnvelope
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
  }

  export type MatchParticipationCreateNestedManyWithoutTeamInput = {
    create?: XOR<MatchParticipationCreateWithoutTeamInput, MatchParticipationUncheckedCreateWithoutTeamInput> | MatchParticipationCreateWithoutTeamInput[] | MatchParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutTeamInput | MatchParticipationCreateOrConnectWithoutTeamInput[]
    createMany?: MatchParticipationCreateManyTeamInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type TeamRosterUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamRosterCreateWithoutTeamInput, TeamRosterUncheckedCreateWithoutTeamInput> | TeamRosterCreateWithoutTeamInput[] | TeamRosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutTeamInput | TeamRosterCreateOrConnectWithoutTeamInput[]
    createMany?: TeamRosterCreateManyTeamInputEnvelope
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutRedTeamInput = {
    create?: XOR<SeriesCreateWithoutRedTeamInput, SeriesUncheckedCreateWithoutRedTeamInput> | SeriesCreateWithoutRedTeamInput[] | SeriesUncheckedCreateWithoutRedTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRedTeamInput | SeriesCreateOrConnectWithoutRedTeamInput[]
    createMany?: SeriesCreateManyRedTeamInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutBlueTeamInput = {
    create?: XOR<SeriesCreateWithoutBlueTeamInput, SeriesUncheckedCreateWithoutBlueTeamInput> | SeriesCreateWithoutBlueTeamInput[] | SeriesUncheckedCreateWithoutBlueTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutBlueTeamInput | SeriesCreateOrConnectWithoutBlueTeamInput[]
    createMany?: SeriesCreateManyBlueTeamInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<MatchTeamStatsCreateWithoutTeamInput, MatchTeamStatsUncheckedCreateWithoutTeamInput> | MatchTeamStatsCreateWithoutTeamInput[] | MatchTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutTeamInput | MatchTeamStatsCreateOrConnectWithoutTeamInput[]
    createMany?: MatchTeamStatsCreateManyTeamInputEnvelope
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
  }

  export type SubstitutionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<SubstitutionCreateWithoutTeamInput, SubstitutionUncheckedCreateWithoutTeamInput> | SubstitutionCreateWithoutTeamInput[] | SubstitutionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutTeamInput | SubstitutionCreateOrConnectWithoutTeamInput[]
    createMany?: SubstitutionCreateManyTeamInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<RoundTeamStatsCreateWithoutTeamInput, RoundTeamStatsUncheckedCreateWithoutTeamInput> | RoundTeamStatsCreateWithoutTeamInput[] | RoundTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutTeamInput | RoundTeamStatsCreateOrConnectWithoutTeamInput[]
    createMany?: RoundTeamStatsCreateManyTeamInputEnvelope
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
  }

  export type MatchParticipationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<MatchParticipationCreateWithoutTeamInput, MatchParticipationUncheckedCreateWithoutTeamInput> | MatchParticipationCreateWithoutTeamInput[] | MatchParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutTeamInput | MatchParticipationCreateOrConnectWithoutTeamInput[]
    createMany?: MatchParticipationCreateManyTeamInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type TeamRosterUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamRosterCreateWithoutTeamInput, TeamRosterUncheckedCreateWithoutTeamInput> | TeamRosterCreateWithoutTeamInput[] | TeamRosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutTeamInput | TeamRosterCreateOrConnectWithoutTeamInput[]
    upsert?: TeamRosterUpsertWithWhereUniqueWithoutTeamInput | TeamRosterUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamRosterCreateManyTeamInputEnvelope
    set?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    disconnect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    delete?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    update?: TeamRosterUpdateWithWhereUniqueWithoutTeamInput | TeamRosterUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamRosterUpdateManyWithWhereWithoutTeamInput | TeamRosterUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
  }

  export type SeriesUpdateManyWithoutRedTeamNestedInput = {
    create?: XOR<SeriesCreateWithoutRedTeamInput, SeriesUncheckedCreateWithoutRedTeamInput> | SeriesCreateWithoutRedTeamInput[] | SeriesUncheckedCreateWithoutRedTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRedTeamInput | SeriesCreateOrConnectWithoutRedTeamInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutRedTeamInput | SeriesUpsertWithWhereUniqueWithoutRedTeamInput[]
    createMany?: SeriesCreateManyRedTeamInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutRedTeamInput | SeriesUpdateWithWhereUniqueWithoutRedTeamInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutRedTeamInput | SeriesUpdateManyWithWhereWithoutRedTeamInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type SeriesUpdateManyWithoutBlueTeamNestedInput = {
    create?: XOR<SeriesCreateWithoutBlueTeamInput, SeriesUncheckedCreateWithoutBlueTeamInput> | SeriesCreateWithoutBlueTeamInput[] | SeriesUncheckedCreateWithoutBlueTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutBlueTeamInput | SeriesCreateOrConnectWithoutBlueTeamInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutBlueTeamInput | SeriesUpsertWithWhereUniqueWithoutBlueTeamInput[]
    createMany?: SeriesCreateManyBlueTeamInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutBlueTeamInput | SeriesUpdateWithWhereUniqueWithoutBlueTeamInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutBlueTeamInput | SeriesUpdateManyWithWhereWithoutBlueTeamInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type MatchTeamStatsUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MatchTeamStatsCreateWithoutTeamInput, MatchTeamStatsUncheckedCreateWithoutTeamInput> | MatchTeamStatsCreateWithoutTeamInput[] | MatchTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutTeamInput | MatchTeamStatsCreateOrConnectWithoutTeamInput[]
    upsert?: MatchTeamStatsUpsertWithWhereUniqueWithoutTeamInput | MatchTeamStatsUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MatchTeamStatsCreateManyTeamInputEnvelope
    set?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    disconnect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    delete?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    update?: MatchTeamStatsUpdateWithWhereUniqueWithoutTeamInput | MatchTeamStatsUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MatchTeamStatsUpdateManyWithWhereWithoutTeamInput | MatchTeamStatsUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MatchTeamStatsScalarWhereInput | MatchTeamStatsScalarWhereInput[]
  }

  export type SubstitutionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SubstitutionCreateWithoutTeamInput, SubstitutionUncheckedCreateWithoutTeamInput> | SubstitutionCreateWithoutTeamInput[] | SubstitutionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutTeamInput | SubstitutionCreateOrConnectWithoutTeamInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutTeamInput | SubstitutionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SubstitutionCreateManyTeamInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutTeamInput | SubstitutionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutTeamInput | SubstitutionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type RoundTeamStatsUpdateManyWithoutTeamNestedInput = {
    create?: XOR<RoundTeamStatsCreateWithoutTeamInput, RoundTeamStatsUncheckedCreateWithoutTeamInput> | RoundTeamStatsCreateWithoutTeamInput[] | RoundTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutTeamInput | RoundTeamStatsCreateOrConnectWithoutTeamInput[]
    upsert?: RoundTeamStatsUpsertWithWhereUniqueWithoutTeamInput | RoundTeamStatsUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: RoundTeamStatsCreateManyTeamInputEnvelope
    set?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    disconnect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    delete?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    update?: RoundTeamStatsUpdateWithWhereUniqueWithoutTeamInput | RoundTeamStatsUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: RoundTeamStatsUpdateManyWithWhereWithoutTeamInput | RoundTeamStatsUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: RoundTeamStatsScalarWhereInput | RoundTeamStatsScalarWhereInput[]
  }

  export type MatchParticipationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutTeamInput, MatchParticipationUncheckedCreateWithoutTeamInput> | MatchParticipationCreateWithoutTeamInput[] | MatchParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutTeamInput | MatchParticipationCreateOrConnectWithoutTeamInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutTeamInput | MatchParticipationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MatchParticipationCreateManyTeamInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutTeamInput | MatchParticipationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutTeamInput | MatchParticipationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type TeamRosterUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamRosterCreateWithoutTeamInput, TeamRosterUncheckedCreateWithoutTeamInput> | TeamRosterCreateWithoutTeamInput[] | TeamRosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutTeamInput | TeamRosterCreateOrConnectWithoutTeamInput[]
    upsert?: TeamRosterUpsertWithWhereUniqueWithoutTeamInput | TeamRosterUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamRosterCreateManyTeamInputEnvelope
    set?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    disconnect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    delete?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    update?: TeamRosterUpdateWithWhereUniqueWithoutTeamInput | TeamRosterUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamRosterUpdateManyWithWhereWithoutTeamInput | TeamRosterUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutRedTeamNestedInput = {
    create?: XOR<SeriesCreateWithoutRedTeamInput, SeriesUncheckedCreateWithoutRedTeamInput> | SeriesCreateWithoutRedTeamInput[] | SeriesUncheckedCreateWithoutRedTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRedTeamInput | SeriesCreateOrConnectWithoutRedTeamInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutRedTeamInput | SeriesUpsertWithWhereUniqueWithoutRedTeamInput[]
    createMany?: SeriesCreateManyRedTeamInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutRedTeamInput | SeriesUpdateWithWhereUniqueWithoutRedTeamInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutRedTeamInput | SeriesUpdateManyWithWhereWithoutRedTeamInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput = {
    create?: XOR<SeriesCreateWithoutBlueTeamInput, SeriesUncheckedCreateWithoutBlueTeamInput> | SeriesCreateWithoutBlueTeamInput[] | SeriesUncheckedCreateWithoutBlueTeamInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutBlueTeamInput | SeriesCreateOrConnectWithoutBlueTeamInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutBlueTeamInput | SeriesUpsertWithWhereUniqueWithoutBlueTeamInput[]
    createMany?: SeriesCreateManyBlueTeamInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutBlueTeamInput | SeriesUpdateWithWhereUniqueWithoutBlueTeamInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutBlueTeamInput | SeriesUpdateManyWithWhereWithoutBlueTeamInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MatchTeamStatsCreateWithoutTeamInput, MatchTeamStatsUncheckedCreateWithoutTeamInput> | MatchTeamStatsCreateWithoutTeamInput[] | MatchTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutTeamInput | MatchTeamStatsCreateOrConnectWithoutTeamInput[]
    upsert?: MatchTeamStatsUpsertWithWhereUniqueWithoutTeamInput | MatchTeamStatsUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MatchTeamStatsCreateManyTeamInputEnvelope
    set?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    disconnect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    delete?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    update?: MatchTeamStatsUpdateWithWhereUniqueWithoutTeamInput | MatchTeamStatsUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MatchTeamStatsUpdateManyWithWhereWithoutTeamInput | MatchTeamStatsUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MatchTeamStatsScalarWhereInput | MatchTeamStatsScalarWhereInput[]
  }

  export type SubstitutionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SubstitutionCreateWithoutTeamInput, SubstitutionUncheckedCreateWithoutTeamInput> | SubstitutionCreateWithoutTeamInput[] | SubstitutionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutTeamInput | SubstitutionCreateOrConnectWithoutTeamInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutTeamInput | SubstitutionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SubstitutionCreateManyTeamInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutTeamInput | SubstitutionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutTeamInput | SubstitutionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<RoundTeamStatsCreateWithoutTeamInput, RoundTeamStatsUncheckedCreateWithoutTeamInput> | RoundTeamStatsCreateWithoutTeamInput[] | RoundTeamStatsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutTeamInput | RoundTeamStatsCreateOrConnectWithoutTeamInput[]
    upsert?: RoundTeamStatsUpsertWithWhereUniqueWithoutTeamInput | RoundTeamStatsUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: RoundTeamStatsCreateManyTeamInputEnvelope
    set?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    disconnect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    delete?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    update?: RoundTeamStatsUpdateWithWhereUniqueWithoutTeamInput | RoundTeamStatsUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: RoundTeamStatsUpdateManyWithWhereWithoutTeamInput | RoundTeamStatsUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: RoundTeamStatsScalarWhereInput | RoundTeamStatsScalarWhereInput[]
  }

  export type MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutTeamInput, MatchParticipationUncheckedCreateWithoutTeamInput> | MatchParticipationCreateWithoutTeamInput[] | MatchParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutTeamInput | MatchParticipationCreateOrConnectWithoutTeamInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutTeamInput | MatchParticipationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MatchParticipationCreateManyTeamInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutTeamInput | MatchParticipationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutTeamInput | MatchParticipationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type TeamRosterCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TeamRosterCreateWithoutPlayerInput, TeamRosterUncheckedCreateWithoutPlayerInput> | TeamRosterCreateWithoutPlayerInput[] | TeamRosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutPlayerInput | TeamRosterCreateOrConnectWithoutPlayerInput[]
    createMany?: TeamRosterCreateManyPlayerInputEnvelope
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
  }

  export type SubstitutionCreateNestedManyWithoutSubstitutedInInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedInInput, SubstitutionUncheckedCreateWithoutSubstitutedInInput> | SubstitutionCreateWithoutSubstitutedInInput[] | SubstitutionUncheckedCreateWithoutSubstitutedInInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedInInput | SubstitutionCreateOrConnectWithoutSubstitutedInInput[]
    createMany?: SubstitutionCreateManySubstitutedInInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type SubstitutionCreateNestedManyWithoutSubstitutedOutInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedOutInput, SubstitutionUncheckedCreateWithoutSubstitutedOutInput> | SubstitutionCreateWithoutSubstitutedOutInput[] | SubstitutionUncheckedCreateWithoutSubstitutedOutInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedOutInput | SubstitutionCreateOrConnectWithoutSubstitutedOutInput[]
    createMany?: SubstitutionCreateManySubstitutedOutInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type PlantCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlantCreateWithoutPlayerInput, PlantUncheckedCreateWithoutPlayerInput> | PlantCreateWithoutPlayerInput[] | PlantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutPlayerInput | PlantCreateOrConnectWithoutPlayerInput[]
    createMany?: PlantCreateManyPlayerInputEnvelope
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
  }

  export type DefuseCreateNestedManyWithoutPlayerInput = {
    create?: XOR<DefuseCreateWithoutPlayerInput, DefuseUncheckedCreateWithoutPlayerInput> | DefuseCreateWithoutPlayerInput[] | DefuseUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DefuseCreateOrConnectWithoutPlayerInput | DefuseCreateOrConnectWithoutPlayerInput[]
    createMany?: DefuseCreateManyPlayerInputEnvelope
    connect?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
  }

  export type RoundPlayerStatsCreateNestedManyWithoutPlayerInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutPlayerInput, RoundPlayerStatsUncheckedCreateWithoutPlayerInput> | RoundPlayerStatsCreateWithoutPlayerInput[] | RoundPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutPlayerInput | RoundPlayerStatsCreateOrConnectWithoutPlayerInput[]
    createMany?: RoundPlayerStatsCreateManyPlayerInputEnvelope
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
  }

  export type MatchPlayerStatsCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutPlayerInput, MatchPlayerStatsUncheckedCreateWithoutPlayerInput> | MatchPlayerStatsCreateWithoutPlayerInput[] | MatchPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutPlayerInput | MatchPlayerStatsCreateOrConnectWithoutPlayerInput[]
    createMany?: MatchPlayerStatsCreateManyPlayerInputEnvelope
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
  }

  export type KillCreateNestedManyWithoutKillerInput = {
    create?: XOR<KillCreateWithoutKillerInput, KillUncheckedCreateWithoutKillerInput> | KillCreateWithoutKillerInput[] | KillUncheckedCreateWithoutKillerInput[]
    connectOrCreate?: KillCreateOrConnectWithoutKillerInput | KillCreateOrConnectWithoutKillerInput[]
    createMany?: KillCreateManyKillerInputEnvelope
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type KillCreateNestedManyWithoutVictimInput = {
    create?: XOR<KillCreateWithoutVictimInput, KillUncheckedCreateWithoutVictimInput> | KillCreateWithoutVictimInput[] | KillUncheckedCreateWithoutVictimInput[]
    connectOrCreate?: KillCreateOrConnectWithoutVictimInput | KillCreateOrConnectWithoutVictimInput[]
    createMany?: KillCreateManyVictimInputEnvelope
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type KillCreateNestedManyWithoutAssistantsInput = {
    create?: XOR<KillCreateWithoutAssistantsInput, KillUncheckedCreateWithoutAssistantsInput> | KillCreateWithoutAssistantsInput[] | KillUncheckedCreateWithoutAssistantsInput[]
    connectOrCreate?: KillCreateOrConnectWithoutAssistantsInput | KillCreateOrConnectWithoutAssistantsInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type MatchParticipationCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MatchParticipationCreateWithoutPlayerInput, MatchParticipationUncheckedCreateWithoutPlayerInput> | MatchParticipationCreateWithoutPlayerInput[] | MatchParticipationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutPlayerInput | MatchParticipationCreateOrConnectWithoutPlayerInput[]
    createMany?: MatchParticipationCreateManyPlayerInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type TeamRosterUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TeamRosterCreateWithoutPlayerInput, TeamRosterUncheckedCreateWithoutPlayerInput> | TeamRosterCreateWithoutPlayerInput[] | TeamRosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutPlayerInput | TeamRosterCreateOrConnectWithoutPlayerInput[]
    createMany?: TeamRosterCreateManyPlayerInputEnvelope
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
  }

  export type SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedInInput, SubstitutionUncheckedCreateWithoutSubstitutedInInput> | SubstitutionCreateWithoutSubstitutedInInput[] | SubstitutionUncheckedCreateWithoutSubstitutedInInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedInInput | SubstitutionCreateOrConnectWithoutSubstitutedInInput[]
    createMany?: SubstitutionCreateManySubstitutedInInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedOutInput, SubstitutionUncheckedCreateWithoutSubstitutedOutInput> | SubstitutionCreateWithoutSubstitutedOutInput[] | SubstitutionUncheckedCreateWithoutSubstitutedOutInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedOutInput | SubstitutionCreateOrConnectWithoutSubstitutedOutInput[]
    createMany?: SubstitutionCreateManySubstitutedOutInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type PlantUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlantCreateWithoutPlayerInput, PlantUncheckedCreateWithoutPlayerInput> | PlantCreateWithoutPlayerInput[] | PlantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutPlayerInput | PlantCreateOrConnectWithoutPlayerInput[]
    createMany?: PlantCreateManyPlayerInputEnvelope
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
  }

  export type DefuseUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<DefuseCreateWithoutPlayerInput, DefuseUncheckedCreateWithoutPlayerInput> | DefuseCreateWithoutPlayerInput[] | DefuseUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DefuseCreateOrConnectWithoutPlayerInput | DefuseCreateOrConnectWithoutPlayerInput[]
    createMany?: DefuseCreateManyPlayerInputEnvelope
    connect?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
  }

  export type RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutPlayerInput, RoundPlayerStatsUncheckedCreateWithoutPlayerInput> | RoundPlayerStatsCreateWithoutPlayerInput[] | RoundPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutPlayerInput | RoundPlayerStatsCreateOrConnectWithoutPlayerInput[]
    createMany?: RoundPlayerStatsCreateManyPlayerInputEnvelope
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
  }

  export type MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutPlayerInput, MatchPlayerStatsUncheckedCreateWithoutPlayerInput> | MatchPlayerStatsCreateWithoutPlayerInput[] | MatchPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutPlayerInput | MatchPlayerStatsCreateOrConnectWithoutPlayerInput[]
    createMany?: MatchPlayerStatsCreateManyPlayerInputEnvelope
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
  }

  export type KillUncheckedCreateNestedManyWithoutKillerInput = {
    create?: XOR<KillCreateWithoutKillerInput, KillUncheckedCreateWithoutKillerInput> | KillCreateWithoutKillerInput[] | KillUncheckedCreateWithoutKillerInput[]
    connectOrCreate?: KillCreateOrConnectWithoutKillerInput | KillCreateOrConnectWithoutKillerInput[]
    createMany?: KillCreateManyKillerInputEnvelope
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type KillUncheckedCreateNestedManyWithoutVictimInput = {
    create?: XOR<KillCreateWithoutVictimInput, KillUncheckedCreateWithoutVictimInput> | KillCreateWithoutVictimInput[] | KillUncheckedCreateWithoutVictimInput[]
    connectOrCreate?: KillCreateOrConnectWithoutVictimInput | KillCreateOrConnectWithoutVictimInput[]
    createMany?: KillCreateManyVictimInputEnvelope
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type KillUncheckedCreateNestedManyWithoutAssistantsInput = {
    create?: XOR<KillCreateWithoutAssistantsInput, KillUncheckedCreateWithoutAssistantsInput> | KillCreateWithoutAssistantsInput[] | KillUncheckedCreateWithoutAssistantsInput[]
    connectOrCreate?: KillCreateOrConnectWithoutAssistantsInput | KillCreateOrConnectWithoutAssistantsInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MatchParticipationCreateWithoutPlayerInput, MatchParticipationUncheckedCreateWithoutPlayerInput> | MatchParticipationCreateWithoutPlayerInput[] | MatchParticipationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutPlayerInput | MatchParticipationCreateOrConnectWithoutPlayerInput[]
    createMany?: MatchParticipationCreateManyPlayerInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type TeamRosterUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TeamRosterCreateWithoutPlayerInput, TeamRosterUncheckedCreateWithoutPlayerInput> | TeamRosterCreateWithoutPlayerInput[] | TeamRosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutPlayerInput | TeamRosterCreateOrConnectWithoutPlayerInput[]
    upsert?: TeamRosterUpsertWithWhereUniqueWithoutPlayerInput | TeamRosterUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TeamRosterCreateManyPlayerInputEnvelope
    set?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    disconnect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    delete?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    update?: TeamRosterUpdateWithWhereUniqueWithoutPlayerInput | TeamRosterUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TeamRosterUpdateManyWithWhereWithoutPlayerInput | TeamRosterUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
  }

  export type SubstitutionUpdateManyWithoutSubstitutedInNestedInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedInInput, SubstitutionUncheckedCreateWithoutSubstitutedInInput> | SubstitutionCreateWithoutSubstitutedInInput[] | SubstitutionUncheckedCreateWithoutSubstitutedInInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedInInput | SubstitutionCreateOrConnectWithoutSubstitutedInInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutSubstitutedInInput | SubstitutionUpsertWithWhereUniqueWithoutSubstitutedInInput[]
    createMany?: SubstitutionCreateManySubstitutedInInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutSubstitutedInInput | SubstitutionUpdateWithWhereUniqueWithoutSubstitutedInInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutSubstitutedInInput | SubstitutionUpdateManyWithWhereWithoutSubstitutedInInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type SubstitutionUpdateManyWithoutSubstitutedOutNestedInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedOutInput, SubstitutionUncheckedCreateWithoutSubstitutedOutInput> | SubstitutionCreateWithoutSubstitutedOutInput[] | SubstitutionUncheckedCreateWithoutSubstitutedOutInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedOutInput | SubstitutionCreateOrConnectWithoutSubstitutedOutInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutSubstitutedOutInput | SubstitutionUpsertWithWhereUniqueWithoutSubstitutedOutInput[]
    createMany?: SubstitutionCreateManySubstitutedOutInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutSubstitutedOutInput | SubstitutionUpdateWithWhereUniqueWithoutSubstitutedOutInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutSubstitutedOutInput | SubstitutionUpdateManyWithWhereWithoutSubstitutedOutInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type PlantUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlantCreateWithoutPlayerInput, PlantUncheckedCreateWithoutPlayerInput> | PlantCreateWithoutPlayerInput[] | PlantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutPlayerInput | PlantCreateOrConnectWithoutPlayerInput[]
    upsert?: PlantUpsertWithWhereUniqueWithoutPlayerInput | PlantUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlantCreateManyPlayerInputEnvelope
    set?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    disconnect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    delete?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    update?: PlantUpdateWithWhereUniqueWithoutPlayerInput | PlantUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlantUpdateManyWithWhereWithoutPlayerInput | PlantUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlantScalarWhereInput | PlantScalarWhereInput[]
  }

  export type DefuseUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<DefuseCreateWithoutPlayerInput, DefuseUncheckedCreateWithoutPlayerInput> | DefuseCreateWithoutPlayerInput[] | DefuseUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DefuseCreateOrConnectWithoutPlayerInput | DefuseCreateOrConnectWithoutPlayerInput[]
    upsert?: DefuseUpsertWithWhereUniqueWithoutPlayerInput | DefuseUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: DefuseCreateManyPlayerInputEnvelope
    set?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    disconnect?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    delete?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    connect?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    update?: DefuseUpdateWithWhereUniqueWithoutPlayerInput | DefuseUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: DefuseUpdateManyWithWhereWithoutPlayerInput | DefuseUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: DefuseScalarWhereInput | DefuseScalarWhereInput[]
  }

  export type RoundPlayerStatsUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutPlayerInput, RoundPlayerStatsUncheckedCreateWithoutPlayerInput> | RoundPlayerStatsCreateWithoutPlayerInput[] | RoundPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutPlayerInput | RoundPlayerStatsCreateOrConnectWithoutPlayerInput[]
    upsert?: RoundPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput | RoundPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: RoundPlayerStatsCreateManyPlayerInputEnvelope
    set?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    disconnect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    delete?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    update?: RoundPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput | RoundPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: RoundPlayerStatsUpdateManyWithWhereWithoutPlayerInput | RoundPlayerStatsUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
  }

  export type MatchPlayerStatsUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutPlayerInput, MatchPlayerStatsUncheckedCreateWithoutPlayerInput> | MatchPlayerStatsCreateWithoutPlayerInput[] | MatchPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutPlayerInput | MatchPlayerStatsCreateOrConnectWithoutPlayerInput[]
    upsert?: MatchPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput | MatchPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MatchPlayerStatsCreateManyPlayerInputEnvelope
    set?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    disconnect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    delete?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    update?: MatchPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput | MatchPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MatchPlayerStatsUpdateManyWithWhereWithoutPlayerInput | MatchPlayerStatsUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
  }

  export type KillUpdateManyWithoutKillerNestedInput = {
    create?: XOR<KillCreateWithoutKillerInput, KillUncheckedCreateWithoutKillerInput> | KillCreateWithoutKillerInput[] | KillUncheckedCreateWithoutKillerInput[]
    connectOrCreate?: KillCreateOrConnectWithoutKillerInput | KillCreateOrConnectWithoutKillerInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutKillerInput | KillUpsertWithWhereUniqueWithoutKillerInput[]
    createMany?: KillCreateManyKillerInputEnvelope
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutKillerInput | KillUpdateWithWhereUniqueWithoutKillerInput[]
    updateMany?: KillUpdateManyWithWhereWithoutKillerInput | KillUpdateManyWithWhereWithoutKillerInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type KillUpdateManyWithoutVictimNestedInput = {
    create?: XOR<KillCreateWithoutVictimInput, KillUncheckedCreateWithoutVictimInput> | KillCreateWithoutVictimInput[] | KillUncheckedCreateWithoutVictimInput[]
    connectOrCreate?: KillCreateOrConnectWithoutVictimInput | KillCreateOrConnectWithoutVictimInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutVictimInput | KillUpsertWithWhereUniqueWithoutVictimInput[]
    createMany?: KillCreateManyVictimInputEnvelope
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutVictimInput | KillUpdateWithWhereUniqueWithoutVictimInput[]
    updateMany?: KillUpdateManyWithWhereWithoutVictimInput | KillUpdateManyWithWhereWithoutVictimInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type KillUpdateManyWithoutAssistantsNestedInput = {
    create?: XOR<KillCreateWithoutAssistantsInput, KillUncheckedCreateWithoutAssistantsInput> | KillCreateWithoutAssistantsInput[] | KillUncheckedCreateWithoutAssistantsInput[]
    connectOrCreate?: KillCreateOrConnectWithoutAssistantsInput | KillCreateOrConnectWithoutAssistantsInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutAssistantsInput | KillUpsertWithWhereUniqueWithoutAssistantsInput[]
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutAssistantsInput | KillUpdateWithWhereUniqueWithoutAssistantsInput[]
    updateMany?: KillUpdateManyWithWhereWithoutAssistantsInput | KillUpdateManyWithWhereWithoutAssistantsInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type MatchParticipationUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutPlayerInput, MatchParticipationUncheckedCreateWithoutPlayerInput> | MatchParticipationCreateWithoutPlayerInput[] | MatchParticipationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutPlayerInput | MatchParticipationCreateOrConnectWithoutPlayerInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutPlayerInput | MatchParticipationUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MatchParticipationCreateManyPlayerInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutPlayerInput | MatchParticipationUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutPlayerInput | MatchParticipationUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TeamRosterCreateWithoutPlayerInput, TeamRosterUncheckedCreateWithoutPlayerInput> | TeamRosterCreateWithoutPlayerInput[] | TeamRosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TeamRosterCreateOrConnectWithoutPlayerInput | TeamRosterCreateOrConnectWithoutPlayerInput[]
    upsert?: TeamRosterUpsertWithWhereUniqueWithoutPlayerInput | TeamRosterUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TeamRosterCreateManyPlayerInputEnvelope
    set?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    disconnect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    delete?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    connect?: TeamRosterWhereUniqueInput | TeamRosterWhereUniqueInput[]
    update?: TeamRosterUpdateWithWhereUniqueWithoutPlayerInput | TeamRosterUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TeamRosterUpdateManyWithWhereWithoutPlayerInput | TeamRosterUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
  }

  export type SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedInInput, SubstitutionUncheckedCreateWithoutSubstitutedInInput> | SubstitutionCreateWithoutSubstitutedInInput[] | SubstitutionUncheckedCreateWithoutSubstitutedInInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedInInput | SubstitutionCreateOrConnectWithoutSubstitutedInInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutSubstitutedInInput | SubstitutionUpsertWithWhereUniqueWithoutSubstitutedInInput[]
    createMany?: SubstitutionCreateManySubstitutedInInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutSubstitutedInInput | SubstitutionUpdateWithWhereUniqueWithoutSubstitutedInInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutSubstitutedInInput | SubstitutionUpdateManyWithWhereWithoutSubstitutedInInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput = {
    create?: XOR<SubstitutionCreateWithoutSubstitutedOutInput, SubstitutionUncheckedCreateWithoutSubstitutedOutInput> | SubstitutionCreateWithoutSubstitutedOutInput[] | SubstitutionUncheckedCreateWithoutSubstitutedOutInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutSubstitutedOutInput | SubstitutionCreateOrConnectWithoutSubstitutedOutInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutSubstitutedOutInput | SubstitutionUpsertWithWhereUniqueWithoutSubstitutedOutInput[]
    createMany?: SubstitutionCreateManySubstitutedOutInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutSubstitutedOutInput | SubstitutionUpdateWithWhereUniqueWithoutSubstitutedOutInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutSubstitutedOutInput | SubstitutionUpdateManyWithWhereWithoutSubstitutedOutInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type PlantUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlantCreateWithoutPlayerInput, PlantUncheckedCreateWithoutPlayerInput> | PlantCreateWithoutPlayerInput[] | PlantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutPlayerInput | PlantCreateOrConnectWithoutPlayerInput[]
    upsert?: PlantUpsertWithWhereUniqueWithoutPlayerInput | PlantUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlantCreateManyPlayerInputEnvelope
    set?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    disconnect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    delete?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    update?: PlantUpdateWithWhereUniqueWithoutPlayerInput | PlantUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlantUpdateManyWithWhereWithoutPlayerInput | PlantUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlantScalarWhereInput | PlantScalarWhereInput[]
  }

  export type DefuseUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<DefuseCreateWithoutPlayerInput, DefuseUncheckedCreateWithoutPlayerInput> | DefuseCreateWithoutPlayerInput[] | DefuseUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DefuseCreateOrConnectWithoutPlayerInput | DefuseCreateOrConnectWithoutPlayerInput[]
    upsert?: DefuseUpsertWithWhereUniqueWithoutPlayerInput | DefuseUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: DefuseCreateManyPlayerInputEnvelope
    set?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    disconnect?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    delete?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    connect?: DefuseWhereUniqueInput | DefuseWhereUniqueInput[]
    update?: DefuseUpdateWithWhereUniqueWithoutPlayerInput | DefuseUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: DefuseUpdateManyWithWhereWithoutPlayerInput | DefuseUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: DefuseScalarWhereInput | DefuseScalarWhereInput[]
  }

  export type RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutPlayerInput, RoundPlayerStatsUncheckedCreateWithoutPlayerInput> | RoundPlayerStatsCreateWithoutPlayerInput[] | RoundPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutPlayerInput | RoundPlayerStatsCreateOrConnectWithoutPlayerInput[]
    upsert?: RoundPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput | RoundPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: RoundPlayerStatsCreateManyPlayerInputEnvelope
    set?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    disconnect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    delete?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    update?: RoundPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput | RoundPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: RoundPlayerStatsUpdateManyWithWhereWithoutPlayerInput | RoundPlayerStatsUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
  }

  export type MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutPlayerInput, MatchPlayerStatsUncheckedCreateWithoutPlayerInput> | MatchPlayerStatsCreateWithoutPlayerInput[] | MatchPlayerStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutPlayerInput | MatchPlayerStatsCreateOrConnectWithoutPlayerInput[]
    upsert?: MatchPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput | MatchPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MatchPlayerStatsCreateManyPlayerInputEnvelope
    set?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    disconnect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    delete?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    update?: MatchPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput | MatchPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MatchPlayerStatsUpdateManyWithWhereWithoutPlayerInput | MatchPlayerStatsUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
  }

  export type KillUncheckedUpdateManyWithoutKillerNestedInput = {
    create?: XOR<KillCreateWithoutKillerInput, KillUncheckedCreateWithoutKillerInput> | KillCreateWithoutKillerInput[] | KillUncheckedCreateWithoutKillerInput[]
    connectOrCreate?: KillCreateOrConnectWithoutKillerInput | KillCreateOrConnectWithoutKillerInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutKillerInput | KillUpsertWithWhereUniqueWithoutKillerInput[]
    createMany?: KillCreateManyKillerInputEnvelope
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutKillerInput | KillUpdateWithWhereUniqueWithoutKillerInput[]
    updateMany?: KillUpdateManyWithWhereWithoutKillerInput | KillUpdateManyWithWhereWithoutKillerInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type KillUncheckedUpdateManyWithoutVictimNestedInput = {
    create?: XOR<KillCreateWithoutVictimInput, KillUncheckedCreateWithoutVictimInput> | KillCreateWithoutVictimInput[] | KillUncheckedCreateWithoutVictimInput[]
    connectOrCreate?: KillCreateOrConnectWithoutVictimInput | KillCreateOrConnectWithoutVictimInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutVictimInput | KillUpsertWithWhereUniqueWithoutVictimInput[]
    createMany?: KillCreateManyVictimInputEnvelope
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutVictimInput | KillUpdateWithWhereUniqueWithoutVictimInput[]
    updateMany?: KillUpdateManyWithWhereWithoutVictimInput | KillUpdateManyWithWhereWithoutVictimInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type KillUncheckedUpdateManyWithoutAssistantsNestedInput = {
    create?: XOR<KillCreateWithoutAssistantsInput, KillUncheckedCreateWithoutAssistantsInput> | KillCreateWithoutAssistantsInput[] | KillUncheckedCreateWithoutAssistantsInput[]
    connectOrCreate?: KillCreateOrConnectWithoutAssistantsInput | KillCreateOrConnectWithoutAssistantsInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutAssistantsInput | KillUpsertWithWhereUniqueWithoutAssistantsInput[]
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutAssistantsInput | KillUpdateWithWhereUniqueWithoutAssistantsInput[]
    updateMany?: KillUpdateManyWithWhereWithoutAssistantsInput | KillUpdateManyWithWhereWithoutAssistantsInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutPlayerInput, MatchParticipationUncheckedCreateWithoutPlayerInput> | MatchParticipationCreateWithoutPlayerInput[] | MatchParticipationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutPlayerInput | MatchParticipationCreateOrConnectWithoutPlayerInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutPlayerInput | MatchParticipationUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MatchParticipationCreateManyPlayerInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutPlayerInput | MatchParticipationUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutPlayerInput | MatchParticipationUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type SeasonCreateNestedOneWithoutSeriesInput = {
    create?: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutSeriesInput
    connect?: SeasonWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutRedSeriesInput = {
    create?: XOR<TeamCreateWithoutRedSeriesInput, TeamUncheckedCreateWithoutRedSeriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRedSeriesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutBlueSeriesInput = {
    create?: XOR<TeamCreateWithoutBlueSeriesInput, TeamUncheckedCreateWithoutBlueSeriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutBlueSeriesInput
    connect?: TeamWhereUniqueInput
  }

  export type MatchCreateNestedManyWithoutSeriesInput = {
    create?: XOR<MatchCreateWithoutSeriesInput, MatchUncheckedCreateWithoutSeriesInput> | MatchCreateWithoutSeriesInput[] | MatchUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSeriesInput | MatchCreateOrConnectWithoutSeriesInput[]
    createMany?: MatchCreateManySeriesInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<MatchCreateWithoutSeriesInput, MatchUncheckedCreateWithoutSeriesInput> | MatchCreateWithoutSeriesInput[] | MatchUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSeriesInput | MatchCreateOrConnectWithoutSeriesInput[]
    createMany?: MatchCreateManySeriesInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SeasonUpdateOneRequiredWithoutSeriesNestedInput = {
    create?: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutSeriesInput
    upsert?: SeasonUpsertWithoutSeriesInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutSeriesInput, SeasonUpdateWithoutSeriesInput>, SeasonUncheckedUpdateWithoutSeriesInput>
  }

  export type TeamUpdateOneRequiredWithoutRedSeriesNestedInput = {
    create?: XOR<TeamCreateWithoutRedSeriesInput, TeamUncheckedCreateWithoutRedSeriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRedSeriesInput
    upsert?: TeamUpsertWithoutRedSeriesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRedSeriesInput, TeamUpdateWithoutRedSeriesInput>, TeamUncheckedUpdateWithoutRedSeriesInput>
  }

  export type TeamUpdateOneRequiredWithoutBlueSeriesNestedInput = {
    create?: XOR<TeamCreateWithoutBlueSeriesInput, TeamUncheckedCreateWithoutBlueSeriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutBlueSeriesInput
    upsert?: TeamUpsertWithoutBlueSeriesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutBlueSeriesInput, TeamUpdateWithoutBlueSeriesInput>, TeamUncheckedUpdateWithoutBlueSeriesInput>
  }

  export type MatchUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<MatchCreateWithoutSeriesInput, MatchUncheckedCreateWithoutSeriesInput> | MatchCreateWithoutSeriesInput[] | MatchUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSeriesInput | MatchCreateOrConnectWithoutSeriesInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutSeriesInput | MatchUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: MatchCreateManySeriesInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutSeriesInput | MatchUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutSeriesInput | MatchUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<MatchCreateWithoutSeriesInput, MatchUncheckedCreateWithoutSeriesInput> | MatchCreateWithoutSeriesInput[] | MatchUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSeriesInput | MatchCreateOrConnectWithoutSeriesInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutSeriesInput | MatchUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: MatchCreateManySeriesInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutSeriesInput | MatchUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutSeriesInput | MatchUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type SeriesCreateNestedOneWithoutMatchesInput = {
    create?: XOR<SeriesCreateWithoutMatchesInput, SeriesUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutMatchesInput
    connect?: SeriesWhereUniqueInput
  }

  export type MapCreateNestedOneWithoutMatchesInput = {
    create?: XOR<MapCreateWithoutMatchesInput, MapUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: MapCreateOrConnectWithoutMatchesInput
    connect?: MapWhereUniqueInput
  }

  export type RoundCreateNestedManyWithoutMatchInput = {
    create?: XOR<RoundCreateWithoutMatchInput, RoundUncheckedCreateWithoutMatchInput> | RoundCreateWithoutMatchInput[] | RoundUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: RoundCreateOrConnectWithoutMatchInput | RoundCreateOrConnectWithoutMatchInput[]
    createMany?: RoundCreateManyMatchInputEnvelope
    connect?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
  }

  export type MatchPlayerStatsCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchInput, MatchPlayerStatsUncheckedCreateWithoutMatchInput> | MatchPlayerStatsCreateWithoutMatchInput[] | MatchPlayerStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchInput | MatchPlayerStatsCreateOrConnectWithoutMatchInput[]
    createMany?: MatchPlayerStatsCreateManyMatchInputEnvelope
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
  }

  export type MatchTeamStatsCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchTeamStatsCreateWithoutMatchInput, MatchTeamStatsUncheckedCreateWithoutMatchInput> | MatchTeamStatsCreateWithoutMatchInput[] | MatchTeamStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutMatchInput | MatchTeamStatsCreateOrConnectWithoutMatchInput[]
    createMany?: MatchTeamStatsCreateManyMatchInputEnvelope
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
  }

  export type SubstitutionCreateNestedManyWithoutMatchInput = {
    create?: XOR<SubstitutionCreateWithoutMatchInput, SubstitutionUncheckedCreateWithoutMatchInput> | SubstitutionCreateWithoutMatchInput[] | SubstitutionUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutMatchInput | SubstitutionCreateOrConnectWithoutMatchInput[]
    createMany?: SubstitutionCreateManyMatchInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type KillCreateNestedManyWithoutMatchInput = {
    create?: XOR<KillCreateWithoutMatchInput, KillUncheckedCreateWithoutMatchInput> | KillCreateWithoutMatchInput[] | KillUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: KillCreateOrConnectWithoutMatchInput | KillCreateOrConnectWithoutMatchInput[]
    createMany?: KillCreateManyMatchInputEnvelope
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type MatchParticipationCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchParticipationCreateWithoutMatchInput, MatchParticipationUncheckedCreateWithoutMatchInput> | MatchParticipationCreateWithoutMatchInput[] | MatchParticipationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutMatchInput | MatchParticipationCreateOrConnectWithoutMatchInput[]
    createMany?: MatchParticipationCreateManyMatchInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type RoundUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<RoundCreateWithoutMatchInput, RoundUncheckedCreateWithoutMatchInput> | RoundCreateWithoutMatchInput[] | RoundUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: RoundCreateOrConnectWithoutMatchInput | RoundCreateOrConnectWithoutMatchInput[]
    createMany?: RoundCreateManyMatchInputEnvelope
    connect?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
  }

  export type MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchInput, MatchPlayerStatsUncheckedCreateWithoutMatchInput> | MatchPlayerStatsCreateWithoutMatchInput[] | MatchPlayerStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchInput | MatchPlayerStatsCreateOrConnectWithoutMatchInput[]
    createMany?: MatchPlayerStatsCreateManyMatchInputEnvelope
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
  }

  export type MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchTeamStatsCreateWithoutMatchInput, MatchTeamStatsUncheckedCreateWithoutMatchInput> | MatchTeamStatsCreateWithoutMatchInput[] | MatchTeamStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutMatchInput | MatchTeamStatsCreateOrConnectWithoutMatchInput[]
    createMany?: MatchTeamStatsCreateManyMatchInputEnvelope
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
  }

  export type SubstitutionUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<SubstitutionCreateWithoutMatchInput, SubstitutionUncheckedCreateWithoutMatchInput> | SubstitutionCreateWithoutMatchInput[] | SubstitutionUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutMatchInput | SubstitutionCreateOrConnectWithoutMatchInput[]
    createMany?: SubstitutionCreateManyMatchInputEnvelope
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
  }

  export type KillUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<KillCreateWithoutMatchInput, KillUncheckedCreateWithoutMatchInput> | KillCreateWithoutMatchInput[] | KillUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: KillCreateOrConnectWithoutMatchInput | KillCreateOrConnectWithoutMatchInput[]
    createMany?: KillCreateManyMatchInputEnvelope
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
  }

  export type MatchParticipationUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchParticipationCreateWithoutMatchInput, MatchParticipationUncheckedCreateWithoutMatchInput> | MatchParticipationCreateWithoutMatchInput[] | MatchParticipationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutMatchInput | MatchParticipationCreateOrConnectWithoutMatchInput[]
    createMany?: MatchParticipationCreateManyMatchInputEnvelope
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SeriesUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<SeriesCreateWithoutMatchesInput, SeriesUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutMatchesInput
    upsert?: SeriesUpsertWithoutMatchesInput
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutMatchesInput, SeriesUpdateWithoutMatchesInput>, SeriesUncheckedUpdateWithoutMatchesInput>
  }

  export type MapUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<MapCreateWithoutMatchesInput, MapUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: MapCreateOrConnectWithoutMatchesInput
    upsert?: MapUpsertWithoutMatchesInput
    connect?: MapWhereUniqueInput
    update?: XOR<XOR<MapUpdateToOneWithWhereWithoutMatchesInput, MapUpdateWithoutMatchesInput>, MapUncheckedUpdateWithoutMatchesInput>
  }

  export type RoundUpdateManyWithoutMatchNestedInput = {
    create?: XOR<RoundCreateWithoutMatchInput, RoundUncheckedCreateWithoutMatchInput> | RoundCreateWithoutMatchInput[] | RoundUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: RoundCreateOrConnectWithoutMatchInput | RoundCreateOrConnectWithoutMatchInput[]
    upsert?: RoundUpsertWithWhereUniqueWithoutMatchInput | RoundUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: RoundCreateManyMatchInputEnvelope
    set?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    disconnect?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    delete?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    connect?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    update?: RoundUpdateWithWhereUniqueWithoutMatchInput | RoundUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: RoundUpdateManyWithWhereWithoutMatchInput | RoundUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: RoundScalarWhereInput | RoundScalarWhereInput[]
  }

  export type MatchPlayerStatsUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchInput, MatchPlayerStatsUncheckedCreateWithoutMatchInput> | MatchPlayerStatsCreateWithoutMatchInput[] | MatchPlayerStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchInput | MatchPlayerStatsCreateOrConnectWithoutMatchInput[]
    upsert?: MatchPlayerStatsUpsertWithWhereUniqueWithoutMatchInput | MatchPlayerStatsUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchPlayerStatsCreateManyMatchInputEnvelope
    set?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    disconnect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    delete?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    update?: MatchPlayerStatsUpdateWithWhereUniqueWithoutMatchInput | MatchPlayerStatsUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchPlayerStatsUpdateManyWithWhereWithoutMatchInput | MatchPlayerStatsUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
  }

  export type MatchTeamStatsUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchTeamStatsCreateWithoutMatchInput, MatchTeamStatsUncheckedCreateWithoutMatchInput> | MatchTeamStatsCreateWithoutMatchInput[] | MatchTeamStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutMatchInput | MatchTeamStatsCreateOrConnectWithoutMatchInput[]
    upsert?: MatchTeamStatsUpsertWithWhereUniqueWithoutMatchInput | MatchTeamStatsUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchTeamStatsCreateManyMatchInputEnvelope
    set?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    disconnect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    delete?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    update?: MatchTeamStatsUpdateWithWhereUniqueWithoutMatchInput | MatchTeamStatsUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchTeamStatsUpdateManyWithWhereWithoutMatchInput | MatchTeamStatsUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchTeamStatsScalarWhereInput | MatchTeamStatsScalarWhereInput[]
  }

  export type SubstitutionUpdateManyWithoutMatchNestedInput = {
    create?: XOR<SubstitutionCreateWithoutMatchInput, SubstitutionUncheckedCreateWithoutMatchInput> | SubstitutionCreateWithoutMatchInput[] | SubstitutionUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutMatchInput | SubstitutionCreateOrConnectWithoutMatchInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutMatchInput | SubstitutionUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: SubstitutionCreateManyMatchInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutMatchInput | SubstitutionUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutMatchInput | SubstitutionUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type KillUpdateManyWithoutMatchNestedInput = {
    create?: XOR<KillCreateWithoutMatchInput, KillUncheckedCreateWithoutMatchInput> | KillCreateWithoutMatchInput[] | KillUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: KillCreateOrConnectWithoutMatchInput | KillCreateOrConnectWithoutMatchInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutMatchInput | KillUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: KillCreateManyMatchInputEnvelope
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutMatchInput | KillUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: KillUpdateManyWithWhereWithoutMatchInput | KillUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type MatchParticipationUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutMatchInput, MatchParticipationUncheckedCreateWithoutMatchInput> | MatchParticipationCreateWithoutMatchInput[] | MatchParticipationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutMatchInput | MatchParticipationCreateOrConnectWithoutMatchInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutMatchInput | MatchParticipationUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchParticipationCreateManyMatchInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutMatchInput | MatchParticipationUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutMatchInput | MatchParticipationUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type RoundUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<RoundCreateWithoutMatchInput, RoundUncheckedCreateWithoutMatchInput> | RoundCreateWithoutMatchInput[] | RoundUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: RoundCreateOrConnectWithoutMatchInput | RoundCreateOrConnectWithoutMatchInput[]
    upsert?: RoundUpsertWithWhereUniqueWithoutMatchInput | RoundUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: RoundCreateManyMatchInputEnvelope
    set?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    disconnect?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    delete?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    connect?: RoundWhereUniqueInput | RoundWhereUniqueInput[]
    update?: RoundUpdateWithWhereUniqueWithoutMatchInput | RoundUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: RoundUpdateManyWithWhereWithoutMatchInput | RoundUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: RoundScalarWhereInput | RoundScalarWhereInput[]
  }

  export type MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchInput, MatchPlayerStatsUncheckedCreateWithoutMatchInput> | MatchPlayerStatsCreateWithoutMatchInput[] | MatchPlayerStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchInput | MatchPlayerStatsCreateOrConnectWithoutMatchInput[]
    upsert?: MatchPlayerStatsUpsertWithWhereUniqueWithoutMatchInput | MatchPlayerStatsUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchPlayerStatsCreateManyMatchInputEnvelope
    set?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    disconnect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    delete?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    connect?: MatchPlayerStatsWhereUniqueInput | MatchPlayerStatsWhereUniqueInput[]
    update?: MatchPlayerStatsUpdateWithWhereUniqueWithoutMatchInput | MatchPlayerStatsUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchPlayerStatsUpdateManyWithWhereWithoutMatchInput | MatchPlayerStatsUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
  }

  export type MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchTeamStatsCreateWithoutMatchInput, MatchTeamStatsUncheckedCreateWithoutMatchInput> | MatchTeamStatsCreateWithoutMatchInput[] | MatchTeamStatsUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchTeamStatsCreateOrConnectWithoutMatchInput | MatchTeamStatsCreateOrConnectWithoutMatchInput[]
    upsert?: MatchTeamStatsUpsertWithWhereUniqueWithoutMatchInput | MatchTeamStatsUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchTeamStatsCreateManyMatchInputEnvelope
    set?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    disconnect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    delete?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    connect?: MatchTeamStatsWhereUniqueInput | MatchTeamStatsWhereUniqueInput[]
    update?: MatchTeamStatsUpdateWithWhereUniqueWithoutMatchInput | MatchTeamStatsUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchTeamStatsUpdateManyWithWhereWithoutMatchInput | MatchTeamStatsUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchTeamStatsScalarWhereInput | MatchTeamStatsScalarWhereInput[]
  }

  export type SubstitutionUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<SubstitutionCreateWithoutMatchInput, SubstitutionUncheckedCreateWithoutMatchInput> | SubstitutionCreateWithoutMatchInput[] | SubstitutionUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: SubstitutionCreateOrConnectWithoutMatchInput | SubstitutionCreateOrConnectWithoutMatchInput[]
    upsert?: SubstitutionUpsertWithWhereUniqueWithoutMatchInput | SubstitutionUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: SubstitutionCreateManyMatchInputEnvelope
    set?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    disconnect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    delete?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    connect?: SubstitutionWhereUniqueInput | SubstitutionWhereUniqueInput[]
    update?: SubstitutionUpdateWithWhereUniqueWithoutMatchInput | SubstitutionUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: SubstitutionUpdateManyWithWhereWithoutMatchInput | SubstitutionUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
  }

  export type KillUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<KillCreateWithoutMatchInput, KillUncheckedCreateWithoutMatchInput> | KillCreateWithoutMatchInput[] | KillUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: KillCreateOrConnectWithoutMatchInput | KillCreateOrConnectWithoutMatchInput[]
    upsert?: KillUpsertWithWhereUniqueWithoutMatchInput | KillUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: KillCreateManyMatchInputEnvelope
    set?: KillWhereUniqueInput | KillWhereUniqueInput[]
    disconnect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    delete?: KillWhereUniqueInput | KillWhereUniqueInput[]
    connect?: KillWhereUniqueInput | KillWhereUniqueInput[]
    update?: KillUpdateWithWhereUniqueWithoutMatchInput | KillUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: KillUpdateManyWithWhereWithoutMatchInput | KillUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: KillScalarWhereInput | KillScalarWhereInput[]
  }

  export type MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutMatchInput, MatchParticipationUncheckedCreateWithoutMatchInput> | MatchParticipationCreateWithoutMatchInput[] | MatchParticipationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutMatchInput | MatchParticipationCreateOrConnectWithoutMatchInput[]
    upsert?: MatchParticipationUpsertWithWhereUniqueWithoutMatchInput | MatchParticipationUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchParticipationCreateManyMatchInputEnvelope
    set?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    disconnect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    delete?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    connect?: MatchParticipationWhereUniqueInput | MatchParticipationWhereUniqueInput[]
    update?: MatchParticipationUpdateWithWhereUniqueWithoutMatchInput | MatchParticipationUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchParticipationUpdateManyWithWhereWithoutMatchInput | MatchParticipationUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
  }

  export type MatchCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<MatchCreateWithoutParticipationsInput, MatchUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutParticipationsInput
    connect?: MatchWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutMatchParticipationsInput = {
    create?: XOR<PlayerCreateWithoutMatchParticipationsInput, PlayerUncheckedCreateWithoutMatchParticipationsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMatchParticipationsInput
    connect?: PlayerWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMatchParticipationsInput = {
    create?: XOR<TeamCreateWithoutMatchParticipationsInput, TeamUncheckedCreateWithoutMatchParticipationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchParticipationsInput
    connect?: TeamWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutMatchParticipationsInput = {
    create?: XOR<AgentCreateWithoutMatchParticipationsInput, AgentUncheckedCreateWithoutMatchParticipationsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMatchParticipationsInput
    connect?: AgentWhereUniqueInput
  }

  export type MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchParticipationInput
    connect?: MatchPlayerStatsWhereUniqueInput
  }

  export type RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput> | RoundPlayerStatsCreateWithoutMatchParticipationInput[] | RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput | RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput[]
    createMany?: RoundPlayerStatsCreateManyMatchParticipationInputEnvelope
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
  }

  export type MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchParticipationInput
    connect?: MatchPlayerStatsWhereUniqueInput
  }

  export type RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput> | RoundPlayerStatsCreateWithoutMatchParticipationInput[] | RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput | RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput[]
    createMany?: RoundPlayerStatsCreateManyMatchParticipationInputEnvelope
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
  }

  export type MatchUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<MatchCreateWithoutParticipationsInput, MatchUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutParticipationsInput
    upsert?: MatchUpsertWithoutParticipationsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutParticipationsInput, MatchUpdateWithoutParticipationsInput>, MatchUncheckedUpdateWithoutParticipationsInput>
  }

  export type PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput = {
    create?: XOR<PlayerCreateWithoutMatchParticipationsInput, PlayerUncheckedCreateWithoutMatchParticipationsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMatchParticipationsInput
    upsert?: PlayerUpsertWithoutMatchParticipationsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMatchParticipationsInput, PlayerUpdateWithoutMatchParticipationsInput>, PlayerUncheckedUpdateWithoutMatchParticipationsInput>
  }

  export type TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput = {
    create?: XOR<TeamCreateWithoutMatchParticipationsInput, TeamUncheckedCreateWithoutMatchParticipationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchParticipationsInput
    upsert?: TeamUpsertWithoutMatchParticipationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMatchParticipationsInput, TeamUpdateWithoutMatchParticipationsInput>, TeamUncheckedUpdateWithoutMatchParticipationsInput>
  }

  export type AgentUpdateOneWithoutMatchParticipationsNestedInput = {
    create?: XOR<AgentCreateWithoutMatchParticipationsInput, AgentUncheckedCreateWithoutMatchParticipationsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMatchParticipationsInput
    upsert?: AgentUpsertWithoutMatchParticipationsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMatchParticipationsInput, AgentUpdateWithoutMatchParticipationsInput>, AgentUncheckedUpdateWithoutMatchParticipationsInput>
  }

  export type MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchParticipationInput
    upsert?: MatchPlayerStatsUpsertWithoutMatchParticipationInput
    disconnect?: MatchPlayerStatsWhereInput | boolean
    delete?: MatchPlayerStatsWhereInput | boolean
    connect?: MatchPlayerStatsWhereUniqueInput
    update?: XOR<XOR<MatchPlayerStatsUpdateToOneWithWhereWithoutMatchParticipationInput, MatchPlayerStatsUpdateWithoutMatchParticipationInput>, MatchPlayerStatsUncheckedUpdateWithoutMatchParticipationInput>
  }

  export type RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput> | RoundPlayerStatsCreateWithoutMatchParticipationInput[] | RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput | RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput[]
    upsert?: RoundPlayerStatsUpsertWithWhereUniqueWithoutMatchParticipationInput | RoundPlayerStatsUpsertWithWhereUniqueWithoutMatchParticipationInput[]
    createMany?: RoundPlayerStatsCreateManyMatchParticipationInputEnvelope
    set?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    disconnect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    delete?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    update?: RoundPlayerStatsUpdateWithWhereUniqueWithoutMatchParticipationInput | RoundPlayerStatsUpdateWithWhereUniqueWithoutMatchParticipationInput[]
    updateMany?: RoundPlayerStatsUpdateManyWithWhereWithoutMatchParticipationInput | RoundPlayerStatsUpdateManyWithWhereWithoutMatchParticipationInput[]
    deleteMany?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
  }

  export type MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput = {
    create?: XOR<MatchPlayerStatsCreateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
    connectOrCreate?: MatchPlayerStatsCreateOrConnectWithoutMatchParticipationInput
    upsert?: MatchPlayerStatsUpsertWithoutMatchParticipationInput
    disconnect?: MatchPlayerStatsWhereInput | boolean
    delete?: MatchPlayerStatsWhereInput | boolean
    connect?: MatchPlayerStatsWhereUniqueInput
    update?: XOR<XOR<MatchPlayerStatsUpdateToOneWithWhereWithoutMatchParticipationInput, MatchPlayerStatsUpdateWithoutMatchParticipationInput>, MatchPlayerStatsUncheckedUpdateWithoutMatchParticipationInput>
  }

  export type RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput> | RoundPlayerStatsCreateWithoutMatchParticipationInput[] | RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput | RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput[]
    upsert?: RoundPlayerStatsUpsertWithWhereUniqueWithoutMatchParticipationInput | RoundPlayerStatsUpsertWithWhereUniqueWithoutMatchParticipationInput[]
    createMany?: RoundPlayerStatsCreateManyMatchParticipationInputEnvelope
    set?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    disconnect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    delete?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    update?: RoundPlayerStatsUpdateWithWhereUniqueWithoutMatchParticipationInput | RoundPlayerStatsUpdateWithWhereUniqueWithoutMatchParticipationInput[]
    updateMany?: RoundPlayerStatsUpdateManyWithWhereWithoutMatchParticipationInput | RoundPlayerStatsUpdateManyWithWhereWithoutMatchParticipationInput[]
    deleteMany?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
  }

  export type MatchParticipationCreateNestedOneWithoutMatchStatsInput = {
    create?: XOR<MatchParticipationCreateWithoutMatchStatsInput, MatchParticipationUncheckedCreateWithoutMatchStatsInput>
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutMatchStatsInput
    connect?: MatchParticipationWhereUniqueInput
  }

  export type MatchCreateNestedOneWithoutMatchPlayerStatsInput = {
    create?: XOR<MatchCreateWithoutMatchPlayerStatsInput, MatchUncheckedCreateWithoutMatchPlayerStatsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutMatchPlayerStatsInput
    connect?: MatchWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutMatchStatsInput = {
    create?: XOR<PlayerCreateWithoutMatchStatsInput, PlayerUncheckedCreateWithoutMatchStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMatchStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutMatchPlayerStatsInput = {
    create?: XOR<AgentCreateWithoutMatchPlayerStatsInput, AgentUncheckedCreateWithoutMatchPlayerStatsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMatchPlayerStatsInput
    connect?: AgentWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MatchParticipationUpdateOneRequiredWithoutMatchStatsNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutMatchStatsInput, MatchParticipationUncheckedCreateWithoutMatchStatsInput>
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutMatchStatsInput
    upsert?: MatchParticipationUpsertWithoutMatchStatsInput
    connect?: MatchParticipationWhereUniqueInput
    update?: XOR<XOR<MatchParticipationUpdateToOneWithWhereWithoutMatchStatsInput, MatchParticipationUpdateWithoutMatchStatsInput>, MatchParticipationUncheckedUpdateWithoutMatchStatsInput>
  }

  export type MatchUpdateOneRequiredWithoutMatchPlayerStatsNestedInput = {
    create?: XOR<MatchCreateWithoutMatchPlayerStatsInput, MatchUncheckedCreateWithoutMatchPlayerStatsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutMatchPlayerStatsInput
    upsert?: MatchUpsertWithoutMatchPlayerStatsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutMatchPlayerStatsInput, MatchUpdateWithoutMatchPlayerStatsInput>, MatchUncheckedUpdateWithoutMatchPlayerStatsInput>
  }

  export type PlayerUpdateOneRequiredWithoutMatchStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutMatchStatsInput, PlayerUncheckedCreateWithoutMatchStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMatchStatsInput
    upsert?: PlayerUpsertWithoutMatchStatsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMatchStatsInput, PlayerUpdateWithoutMatchStatsInput>, PlayerUncheckedUpdateWithoutMatchStatsInput>
  }

  export type AgentUpdateOneWithoutMatchPlayerStatsNestedInput = {
    create?: XOR<AgentCreateWithoutMatchPlayerStatsInput, AgentUncheckedCreateWithoutMatchPlayerStatsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMatchPlayerStatsInput
    upsert?: AgentUpsertWithoutMatchPlayerStatsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMatchPlayerStatsInput, AgentUpdateWithoutMatchPlayerStatsInput>, AgentUncheckedUpdateWithoutMatchPlayerStatsInput>
  }

  export type MatchCreateNestedOneWithoutMatchTeamStatsInput = {
    create?: XOR<MatchCreateWithoutMatchTeamStatsInput, MatchUncheckedCreateWithoutMatchTeamStatsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutMatchTeamStatsInput
    connect?: MatchWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTeamStatsInput = {
    create?: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamStatsInput
    connect?: TeamWhereUniqueInput
  }

  export type MatchUpdateOneRequiredWithoutMatchTeamStatsNestedInput = {
    create?: XOR<MatchCreateWithoutMatchTeamStatsInput, MatchUncheckedCreateWithoutMatchTeamStatsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutMatchTeamStatsInput
    upsert?: MatchUpsertWithoutMatchTeamStatsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutMatchTeamStatsInput, MatchUpdateWithoutMatchTeamStatsInput>, MatchUncheckedUpdateWithoutMatchTeamStatsInput>
  }

  export type TeamUpdateOneRequiredWithoutTeamStatsNestedInput = {
    create?: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamStatsInput
    upsert?: TeamUpsertWithoutTeamStatsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTeamStatsInput, TeamUpdateWithoutTeamStatsInput>, TeamUncheckedUpdateWithoutTeamStatsInput>
  }

  export type MatchCreateNestedOneWithoutRoundsInput = {
    create?: XOR<MatchCreateWithoutRoundsInput, MatchUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutRoundsInput
    connect?: MatchWhereUniqueInput
  }

  export type PlantCreateNestedOneWithoutRoundInput = {
    create?: XOR<PlantCreateWithoutRoundInput, PlantUncheckedCreateWithoutRoundInput>
    connectOrCreate?: PlantCreateOrConnectWithoutRoundInput
    connect?: PlantWhereUniqueInput
  }

  export type DefuseCreateNestedOneWithoutRoundInput = {
    create?: XOR<DefuseCreateWithoutRoundInput, DefuseUncheckedCreateWithoutRoundInput>
    connectOrCreate?: DefuseCreateOrConnectWithoutRoundInput
    connect?: DefuseWhereUniqueInput
  }

  export type RoundPlayerStatsCreateNestedManyWithoutRoundInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutRoundInput, RoundPlayerStatsUncheckedCreateWithoutRoundInput> | RoundPlayerStatsCreateWithoutRoundInput[] | RoundPlayerStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutRoundInput | RoundPlayerStatsCreateOrConnectWithoutRoundInput[]
    createMany?: RoundPlayerStatsCreateManyRoundInputEnvelope
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
  }

  export type RoundTeamStatsCreateNestedManyWithoutRoundInput = {
    create?: XOR<RoundTeamStatsCreateWithoutRoundInput, RoundTeamStatsUncheckedCreateWithoutRoundInput> | RoundTeamStatsCreateWithoutRoundInput[] | RoundTeamStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutRoundInput | RoundTeamStatsCreateOrConnectWithoutRoundInput[]
    createMany?: RoundTeamStatsCreateManyRoundInputEnvelope
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
  }

  export type PlantUncheckedCreateNestedOneWithoutRoundInput = {
    create?: XOR<PlantCreateWithoutRoundInput, PlantUncheckedCreateWithoutRoundInput>
    connectOrCreate?: PlantCreateOrConnectWithoutRoundInput
    connect?: PlantWhereUniqueInput
  }

  export type DefuseUncheckedCreateNestedOneWithoutRoundInput = {
    create?: XOR<DefuseCreateWithoutRoundInput, DefuseUncheckedCreateWithoutRoundInput>
    connectOrCreate?: DefuseCreateOrConnectWithoutRoundInput
    connect?: DefuseWhereUniqueInput
  }

  export type RoundPlayerStatsUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutRoundInput, RoundPlayerStatsUncheckedCreateWithoutRoundInput> | RoundPlayerStatsCreateWithoutRoundInput[] | RoundPlayerStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutRoundInput | RoundPlayerStatsCreateOrConnectWithoutRoundInput[]
    createMany?: RoundPlayerStatsCreateManyRoundInputEnvelope
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
  }

  export type RoundTeamStatsUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<RoundTeamStatsCreateWithoutRoundInput, RoundTeamStatsUncheckedCreateWithoutRoundInput> | RoundTeamStatsCreateWithoutRoundInput[] | RoundTeamStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutRoundInput | RoundTeamStatsCreateOrConnectWithoutRoundInput[]
    createMany?: RoundTeamStatsCreateManyRoundInputEnvelope
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
  }

  export type MatchUpdateOneRequiredWithoutRoundsNestedInput = {
    create?: XOR<MatchCreateWithoutRoundsInput, MatchUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutRoundsInput
    upsert?: MatchUpsertWithoutRoundsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutRoundsInput, MatchUpdateWithoutRoundsInput>, MatchUncheckedUpdateWithoutRoundsInput>
  }

  export type PlantUpdateOneWithoutRoundNestedInput = {
    create?: XOR<PlantCreateWithoutRoundInput, PlantUncheckedCreateWithoutRoundInput>
    connectOrCreate?: PlantCreateOrConnectWithoutRoundInput
    upsert?: PlantUpsertWithoutRoundInput
    disconnect?: PlantWhereInput | boolean
    delete?: PlantWhereInput | boolean
    connect?: PlantWhereUniqueInput
    update?: XOR<XOR<PlantUpdateToOneWithWhereWithoutRoundInput, PlantUpdateWithoutRoundInput>, PlantUncheckedUpdateWithoutRoundInput>
  }

  export type DefuseUpdateOneWithoutRoundNestedInput = {
    create?: XOR<DefuseCreateWithoutRoundInput, DefuseUncheckedCreateWithoutRoundInput>
    connectOrCreate?: DefuseCreateOrConnectWithoutRoundInput
    upsert?: DefuseUpsertWithoutRoundInput
    disconnect?: DefuseWhereInput | boolean
    delete?: DefuseWhereInput | boolean
    connect?: DefuseWhereUniqueInput
    update?: XOR<XOR<DefuseUpdateToOneWithWhereWithoutRoundInput, DefuseUpdateWithoutRoundInput>, DefuseUncheckedUpdateWithoutRoundInput>
  }

  export type RoundPlayerStatsUpdateManyWithoutRoundNestedInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutRoundInput, RoundPlayerStatsUncheckedCreateWithoutRoundInput> | RoundPlayerStatsCreateWithoutRoundInput[] | RoundPlayerStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutRoundInput | RoundPlayerStatsCreateOrConnectWithoutRoundInput[]
    upsert?: RoundPlayerStatsUpsertWithWhereUniqueWithoutRoundInput | RoundPlayerStatsUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: RoundPlayerStatsCreateManyRoundInputEnvelope
    set?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    disconnect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    delete?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    update?: RoundPlayerStatsUpdateWithWhereUniqueWithoutRoundInput | RoundPlayerStatsUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: RoundPlayerStatsUpdateManyWithWhereWithoutRoundInput | RoundPlayerStatsUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
  }

  export type RoundTeamStatsUpdateManyWithoutRoundNestedInput = {
    create?: XOR<RoundTeamStatsCreateWithoutRoundInput, RoundTeamStatsUncheckedCreateWithoutRoundInput> | RoundTeamStatsCreateWithoutRoundInput[] | RoundTeamStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutRoundInput | RoundTeamStatsCreateOrConnectWithoutRoundInput[]
    upsert?: RoundTeamStatsUpsertWithWhereUniqueWithoutRoundInput | RoundTeamStatsUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: RoundTeamStatsCreateManyRoundInputEnvelope
    set?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    disconnect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    delete?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    update?: RoundTeamStatsUpdateWithWhereUniqueWithoutRoundInput | RoundTeamStatsUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: RoundTeamStatsUpdateManyWithWhereWithoutRoundInput | RoundTeamStatsUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: RoundTeamStatsScalarWhereInput | RoundTeamStatsScalarWhereInput[]
  }

  export type PlantUncheckedUpdateOneWithoutRoundNestedInput = {
    create?: XOR<PlantCreateWithoutRoundInput, PlantUncheckedCreateWithoutRoundInput>
    connectOrCreate?: PlantCreateOrConnectWithoutRoundInput
    upsert?: PlantUpsertWithoutRoundInput
    disconnect?: PlantWhereInput | boolean
    delete?: PlantWhereInput | boolean
    connect?: PlantWhereUniqueInput
    update?: XOR<XOR<PlantUpdateToOneWithWhereWithoutRoundInput, PlantUpdateWithoutRoundInput>, PlantUncheckedUpdateWithoutRoundInput>
  }

  export type DefuseUncheckedUpdateOneWithoutRoundNestedInput = {
    create?: XOR<DefuseCreateWithoutRoundInput, DefuseUncheckedCreateWithoutRoundInput>
    connectOrCreate?: DefuseCreateOrConnectWithoutRoundInput
    upsert?: DefuseUpsertWithoutRoundInput
    disconnect?: DefuseWhereInput | boolean
    delete?: DefuseWhereInput | boolean
    connect?: DefuseWhereUniqueInput
    update?: XOR<XOR<DefuseUpdateToOneWithWhereWithoutRoundInput, DefuseUpdateWithoutRoundInput>, DefuseUncheckedUpdateWithoutRoundInput>
  }

  export type RoundPlayerStatsUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<RoundPlayerStatsCreateWithoutRoundInput, RoundPlayerStatsUncheckedCreateWithoutRoundInput> | RoundPlayerStatsCreateWithoutRoundInput[] | RoundPlayerStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundPlayerStatsCreateOrConnectWithoutRoundInput | RoundPlayerStatsCreateOrConnectWithoutRoundInput[]
    upsert?: RoundPlayerStatsUpsertWithWhereUniqueWithoutRoundInput | RoundPlayerStatsUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: RoundPlayerStatsCreateManyRoundInputEnvelope
    set?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    disconnect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    delete?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    connect?: RoundPlayerStatsWhereUniqueInput | RoundPlayerStatsWhereUniqueInput[]
    update?: RoundPlayerStatsUpdateWithWhereUniqueWithoutRoundInput | RoundPlayerStatsUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: RoundPlayerStatsUpdateManyWithWhereWithoutRoundInput | RoundPlayerStatsUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
  }

  export type RoundTeamStatsUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<RoundTeamStatsCreateWithoutRoundInput, RoundTeamStatsUncheckedCreateWithoutRoundInput> | RoundTeamStatsCreateWithoutRoundInput[] | RoundTeamStatsUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundTeamStatsCreateOrConnectWithoutRoundInput | RoundTeamStatsCreateOrConnectWithoutRoundInput[]
    upsert?: RoundTeamStatsUpsertWithWhereUniqueWithoutRoundInput | RoundTeamStatsUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: RoundTeamStatsCreateManyRoundInputEnvelope
    set?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    disconnect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    delete?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    connect?: RoundTeamStatsWhereUniqueInput | RoundTeamStatsWhereUniqueInput[]
    update?: RoundTeamStatsUpdateWithWhereUniqueWithoutRoundInput | RoundTeamStatsUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: RoundTeamStatsUpdateManyWithWhereWithoutRoundInput | RoundTeamStatsUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: RoundTeamStatsScalarWhereInput | RoundTeamStatsScalarWhereInput[]
  }

  export type RoundCreateNestedOneWithoutPlantInput = {
    create?: XOR<RoundCreateWithoutPlantInput, RoundUncheckedCreateWithoutPlantInput>
    connectOrCreate?: RoundCreateOrConnectWithoutPlantInput
    connect?: RoundWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutPlantsInput = {
    create?: XOR<PlayerCreateWithoutPlantsInput, PlayerUncheckedCreateWithoutPlantsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlantsInput
    connect?: PlayerWhereUniqueInput
  }

  export type RoundUpdateOneRequiredWithoutPlantNestedInput = {
    create?: XOR<RoundCreateWithoutPlantInput, RoundUncheckedCreateWithoutPlantInput>
    connectOrCreate?: RoundCreateOrConnectWithoutPlantInput
    upsert?: RoundUpsertWithoutPlantInput
    connect?: RoundWhereUniqueInput
    update?: XOR<XOR<RoundUpdateToOneWithWhereWithoutPlantInput, RoundUpdateWithoutPlantInput>, RoundUncheckedUpdateWithoutPlantInput>
  }

  export type PlayerUpdateOneRequiredWithoutPlantsNestedInput = {
    create?: XOR<PlayerCreateWithoutPlantsInput, PlayerUncheckedCreateWithoutPlantsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlantsInput
    upsert?: PlayerUpsertWithoutPlantsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPlantsInput, PlayerUpdateWithoutPlantsInput>, PlayerUncheckedUpdateWithoutPlantsInput>
  }

  export type RoundCreateNestedOneWithoutDefuseInput = {
    create?: XOR<RoundCreateWithoutDefuseInput, RoundUncheckedCreateWithoutDefuseInput>
    connectOrCreate?: RoundCreateOrConnectWithoutDefuseInput
    connect?: RoundWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutDefusesInput = {
    create?: XOR<PlayerCreateWithoutDefusesInput, PlayerUncheckedCreateWithoutDefusesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDefusesInput
    connect?: PlayerWhereUniqueInput
  }

  export type RoundUpdateOneRequiredWithoutDefuseNestedInput = {
    create?: XOR<RoundCreateWithoutDefuseInput, RoundUncheckedCreateWithoutDefuseInput>
    connectOrCreate?: RoundCreateOrConnectWithoutDefuseInput
    upsert?: RoundUpsertWithoutDefuseInput
    connect?: RoundWhereUniqueInput
    update?: XOR<XOR<RoundUpdateToOneWithWhereWithoutDefuseInput, RoundUpdateWithoutDefuseInput>, RoundUncheckedUpdateWithoutDefuseInput>
  }

  export type PlayerUpdateOneRequiredWithoutDefusesNestedInput = {
    create?: XOR<PlayerCreateWithoutDefusesInput, PlayerUncheckedCreateWithoutDefusesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDefusesInput
    upsert?: PlayerUpsertWithoutDefusesInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutDefusesInput, PlayerUpdateWithoutDefusesInput>, PlayerUncheckedUpdateWithoutDefusesInput>
  }

  export type RoundCreateNestedOneWithoutPlayerStatsInput = {
    create?: XOR<RoundCreateWithoutPlayerStatsInput, RoundUncheckedCreateWithoutPlayerStatsInput>
    connectOrCreate?: RoundCreateOrConnectWithoutPlayerStatsInput
    connect?: RoundWhereUniqueInput
  }

  export type MatchParticipationCreateNestedOneWithoutRoundStatsInput = {
    create?: XOR<MatchParticipationCreateWithoutRoundStatsInput, MatchParticipationUncheckedCreateWithoutRoundStatsInput>
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutRoundStatsInput
    connect?: MatchParticipationWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutRoundStatsInput = {
    create?: XOR<PlayerCreateWithoutRoundStatsInput, PlayerUncheckedCreateWithoutRoundStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRoundStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type RoundUpdateOneRequiredWithoutPlayerStatsNestedInput = {
    create?: XOR<RoundCreateWithoutPlayerStatsInput, RoundUncheckedCreateWithoutPlayerStatsInput>
    connectOrCreate?: RoundCreateOrConnectWithoutPlayerStatsInput
    upsert?: RoundUpsertWithoutPlayerStatsInput
    connect?: RoundWhereUniqueInput
    update?: XOR<XOR<RoundUpdateToOneWithWhereWithoutPlayerStatsInput, RoundUpdateWithoutPlayerStatsInput>, RoundUncheckedUpdateWithoutPlayerStatsInput>
  }

  export type MatchParticipationUpdateOneRequiredWithoutRoundStatsNestedInput = {
    create?: XOR<MatchParticipationCreateWithoutRoundStatsInput, MatchParticipationUncheckedCreateWithoutRoundStatsInput>
    connectOrCreate?: MatchParticipationCreateOrConnectWithoutRoundStatsInput
    upsert?: MatchParticipationUpsertWithoutRoundStatsInput
    connect?: MatchParticipationWhereUniqueInput
    update?: XOR<XOR<MatchParticipationUpdateToOneWithWhereWithoutRoundStatsInput, MatchParticipationUpdateWithoutRoundStatsInput>, MatchParticipationUncheckedUpdateWithoutRoundStatsInput>
  }

  export type PlayerUpdateOneRequiredWithoutRoundStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutRoundStatsInput, PlayerUncheckedCreateWithoutRoundStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRoundStatsInput
    upsert?: PlayerUpsertWithoutRoundStatsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRoundStatsInput, PlayerUpdateWithoutRoundStatsInput>, PlayerUncheckedUpdateWithoutRoundStatsInput>
  }

  export type RoundCreateNestedOneWithoutTeamStatsInput = {
    create?: XOR<RoundCreateWithoutTeamStatsInput, RoundUncheckedCreateWithoutTeamStatsInput>
    connectOrCreate?: RoundCreateOrConnectWithoutTeamStatsInput
    connect?: RoundWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutRoundStatsInput = {
    create?: XOR<TeamCreateWithoutRoundStatsInput, TeamUncheckedCreateWithoutRoundStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRoundStatsInput
    connect?: TeamWhereUniqueInput
  }

  export type RoundUpdateOneRequiredWithoutTeamStatsNestedInput = {
    create?: XOR<RoundCreateWithoutTeamStatsInput, RoundUncheckedCreateWithoutTeamStatsInput>
    connectOrCreate?: RoundCreateOrConnectWithoutTeamStatsInput
    upsert?: RoundUpsertWithoutTeamStatsInput
    connect?: RoundWhereUniqueInput
    update?: XOR<XOR<RoundUpdateToOneWithWhereWithoutTeamStatsInput, RoundUpdateWithoutTeamStatsInput>, RoundUncheckedUpdateWithoutTeamStatsInput>
  }

  export type TeamUpdateOneRequiredWithoutRoundStatsNestedInput = {
    create?: XOR<TeamCreateWithoutRoundStatsInput, TeamUncheckedCreateWithoutRoundStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRoundStatsInput
    upsert?: TeamUpsertWithoutRoundStatsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRoundStatsInput, TeamUpdateWithoutRoundStatsInput>, TeamUncheckedUpdateWithoutRoundStatsInput>
  }

  export type MatchCreateNestedOneWithoutKillsInput = {
    create?: XOR<MatchCreateWithoutKillsInput, MatchUncheckedCreateWithoutKillsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutKillsInput
    connect?: MatchWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutKillsInput = {
    create?: XOR<PlayerCreateWithoutKillsInput, PlayerUncheckedCreateWithoutKillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutKillsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutDeathsInput = {
    create?: XOR<PlayerCreateWithoutDeathsInput, PlayerUncheckedCreateWithoutDeathsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDeathsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerCreateNestedManyWithoutKillAssistsInput = {
    create?: XOR<PlayerCreateWithoutKillAssistsInput, PlayerUncheckedCreateWithoutKillAssistsInput> | PlayerCreateWithoutKillAssistsInput[] | PlayerUncheckedCreateWithoutKillAssistsInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutKillAssistsInput | PlayerCreateOrConnectWithoutKillAssistsInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutKillAssistsInput = {
    create?: XOR<PlayerCreateWithoutKillAssistsInput, PlayerUncheckedCreateWithoutKillAssistsInput> | PlayerCreateWithoutKillAssistsInput[] | PlayerUncheckedCreateWithoutKillAssistsInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutKillAssistsInput | PlayerCreateOrConnectWithoutKillAssistsInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type MatchUpdateOneRequiredWithoutKillsNestedInput = {
    create?: XOR<MatchCreateWithoutKillsInput, MatchUncheckedCreateWithoutKillsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutKillsInput
    upsert?: MatchUpsertWithoutKillsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutKillsInput, MatchUpdateWithoutKillsInput>, MatchUncheckedUpdateWithoutKillsInput>
  }

  export type PlayerUpdateOneRequiredWithoutKillsNestedInput = {
    create?: XOR<PlayerCreateWithoutKillsInput, PlayerUncheckedCreateWithoutKillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutKillsInput
    upsert?: PlayerUpsertWithoutKillsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutKillsInput, PlayerUpdateWithoutKillsInput>, PlayerUncheckedUpdateWithoutKillsInput>
  }

  export type PlayerUpdateOneRequiredWithoutDeathsNestedInput = {
    create?: XOR<PlayerCreateWithoutDeathsInput, PlayerUncheckedCreateWithoutDeathsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDeathsInput
    upsert?: PlayerUpsertWithoutDeathsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutDeathsInput, PlayerUpdateWithoutDeathsInput>, PlayerUncheckedUpdateWithoutDeathsInput>
  }

  export type PlayerUpdateManyWithoutKillAssistsNestedInput = {
    create?: XOR<PlayerCreateWithoutKillAssistsInput, PlayerUncheckedCreateWithoutKillAssistsInput> | PlayerCreateWithoutKillAssistsInput[] | PlayerUncheckedCreateWithoutKillAssistsInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutKillAssistsInput | PlayerCreateOrConnectWithoutKillAssistsInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutKillAssistsInput | PlayerUpsertWithWhereUniqueWithoutKillAssistsInput[]
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutKillAssistsInput | PlayerUpdateWithWhereUniqueWithoutKillAssistsInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutKillAssistsInput | PlayerUpdateManyWithWhereWithoutKillAssistsInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutKillAssistsNestedInput = {
    create?: XOR<PlayerCreateWithoutKillAssistsInput, PlayerUncheckedCreateWithoutKillAssistsInput> | PlayerCreateWithoutKillAssistsInput[] | PlayerUncheckedCreateWithoutKillAssistsInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutKillAssistsInput | PlayerCreateOrConnectWithoutKillAssistsInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutKillAssistsInput | PlayerUpsertWithWhereUniqueWithoutKillAssistsInput[]
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutKillAssistsInput | PlayerUpdateWithWhereUniqueWithoutKillAssistsInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutKillAssistsInput | PlayerUpdateManyWithWhereWithoutKillAssistsInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutRostersInput = {
    create?: XOR<TeamCreateWithoutRostersInput, TeamUncheckedCreateWithoutRostersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRostersInput
    connect?: TeamWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutRostersInput = {
    create?: XOR<PlayerCreateWithoutRostersInput, PlayerUncheckedCreateWithoutRostersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRostersInput
    connect?: PlayerWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutTeamRostersInput = {
    create?: XOR<SeasonCreateWithoutTeamRostersInput, SeasonUncheckedCreateWithoutTeamRostersInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutTeamRostersInput
    connect?: SeasonWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutRostersNestedInput = {
    create?: XOR<TeamCreateWithoutRostersInput, TeamUncheckedCreateWithoutRostersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRostersInput
    upsert?: TeamUpsertWithoutRostersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRostersInput, TeamUpdateWithoutRostersInput>, TeamUncheckedUpdateWithoutRostersInput>
  }

  export type PlayerUpdateOneRequiredWithoutRostersNestedInput = {
    create?: XOR<PlayerCreateWithoutRostersInput, PlayerUncheckedCreateWithoutRostersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRostersInput
    upsert?: PlayerUpsertWithoutRostersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRostersInput, PlayerUpdateWithoutRostersInput>, PlayerUncheckedUpdateWithoutRostersInput>
  }

  export type SeasonUpdateOneRequiredWithoutTeamRostersNestedInput = {
    create?: XOR<SeasonCreateWithoutTeamRostersInput, SeasonUncheckedCreateWithoutTeamRostersInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutTeamRostersInput
    upsert?: SeasonUpsertWithoutTeamRostersInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutTeamRostersInput, SeasonUpdateWithoutTeamRostersInput>, SeasonUncheckedUpdateWithoutTeamRostersInput>
  }

  export type MatchCreateNestedOneWithoutSubstitutionsInput = {
    create?: XOR<MatchCreateWithoutSubstitutionsInput, MatchUncheckedCreateWithoutSubstitutionsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutSubstitutionsInput
    connect?: MatchWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSubstitutionsInput = {
    create?: XOR<TeamCreateWithoutSubstitutionsInput, TeamUncheckedCreateWithoutSubstitutionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSubstitutionsInput
    connect?: TeamWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutSubInsInput = {
    create?: XOR<PlayerCreateWithoutSubInsInput, PlayerUncheckedCreateWithoutSubInsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSubInsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutSubOutsInput = {
    create?: XOR<PlayerCreateWithoutSubOutsInput, PlayerUncheckedCreateWithoutSubOutsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSubOutsInput
    connect?: PlayerWhereUniqueInput
  }

  export type MatchUpdateOneRequiredWithoutSubstitutionsNestedInput = {
    create?: XOR<MatchCreateWithoutSubstitutionsInput, MatchUncheckedCreateWithoutSubstitutionsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutSubstitutionsInput
    upsert?: MatchUpsertWithoutSubstitutionsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutSubstitutionsInput, MatchUpdateWithoutSubstitutionsInput>, MatchUncheckedUpdateWithoutSubstitutionsInput>
  }

  export type TeamUpdateOneRequiredWithoutSubstitutionsNestedInput = {
    create?: XOR<TeamCreateWithoutSubstitutionsInput, TeamUncheckedCreateWithoutSubstitutionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSubstitutionsInput
    upsert?: TeamUpsertWithoutSubstitutionsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSubstitutionsInput, TeamUpdateWithoutSubstitutionsInput>, TeamUncheckedUpdateWithoutSubstitutionsInput>
  }

  export type PlayerUpdateOneRequiredWithoutSubInsNestedInput = {
    create?: XOR<PlayerCreateWithoutSubInsInput, PlayerUncheckedCreateWithoutSubInsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSubInsInput
    upsert?: PlayerUpsertWithoutSubInsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSubInsInput, PlayerUpdateWithoutSubInsInput>, PlayerUncheckedUpdateWithoutSubInsInput>
  }

  export type PlayerUpdateOneRequiredWithoutSubOutsNestedInput = {
    create?: XOR<PlayerCreateWithoutSubOutsInput, PlayerUncheckedCreateWithoutSubOutsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSubOutsInput
    upsert?: PlayerUpsertWithoutSubOutsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSubOutsInput, PlayerUpdateWithoutSubOutsInput>, PlayerUncheckedUpdateWithoutSubOutsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MatchParticipationCreateWithoutAgentInput = {
    teamSide: string
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutParticipationsInput
    player: PlayerCreateNestedOneWithoutMatchParticipationsInput
    team: TeamCreateNestedOneWithoutMatchParticipationsInput
    matchStats?: MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateWithoutAgentInput = {
    id?: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    createdAt?: Date | string
    matchStats?: MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationCreateOrConnectWithoutAgentInput = {
    where: MatchParticipationWhereUniqueInput
    create: XOR<MatchParticipationCreateWithoutAgentInput, MatchParticipationUncheckedCreateWithoutAgentInput>
  }

  export type MatchParticipationCreateManyAgentInputEnvelope = {
    data: MatchParticipationCreateManyAgentInput | MatchParticipationCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type MatchPlayerStatsCreateWithoutAgentInput = {
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipation: MatchParticipationCreateNestedOneWithoutMatchStatsInput
    match: MatchCreateNestedOneWithoutMatchPlayerStatsInput
    player: PlayerCreateNestedOneWithoutMatchStatsInput
  }

  export type MatchPlayerStatsUncheckedCreateWithoutAgentInput = {
    id?: number
    matchParticipationId: number
    matchId: number
    playerId: number
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsCreateOrConnectWithoutAgentInput = {
    where: MatchPlayerStatsWhereUniqueInput
    create: XOR<MatchPlayerStatsCreateWithoutAgentInput, MatchPlayerStatsUncheckedCreateWithoutAgentInput>
  }

  export type MatchPlayerStatsCreateManyAgentInputEnvelope = {
    data: MatchPlayerStatsCreateManyAgentInput | MatchPlayerStatsCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type MatchParticipationUpsertWithWhereUniqueWithoutAgentInput = {
    where: MatchParticipationWhereUniqueInput
    update: XOR<MatchParticipationUpdateWithoutAgentInput, MatchParticipationUncheckedUpdateWithoutAgentInput>
    create: XOR<MatchParticipationCreateWithoutAgentInput, MatchParticipationUncheckedCreateWithoutAgentInput>
  }

  export type MatchParticipationUpdateWithWhereUniqueWithoutAgentInput = {
    where: MatchParticipationWhereUniqueInput
    data: XOR<MatchParticipationUpdateWithoutAgentInput, MatchParticipationUncheckedUpdateWithoutAgentInput>
  }

  export type MatchParticipationUpdateManyWithWhereWithoutAgentInput = {
    where: MatchParticipationScalarWhereInput
    data: XOR<MatchParticipationUpdateManyMutationInput, MatchParticipationUncheckedUpdateManyWithoutAgentInput>
  }

  export type MatchParticipationScalarWhereInput = {
    AND?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
    OR?: MatchParticipationScalarWhereInput[]
    NOT?: MatchParticipationScalarWhereInput | MatchParticipationScalarWhereInput[]
    id?: IntFilter<"MatchParticipation"> | number
    matchId?: IntFilter<"MatchParticipation"> | number
    playerId?: IntFilter<"MatchParticipation"> | number
    teamId?: IntFilter<"MatchParticipation"> | number
    teamSide?: StringFilter<"MatchParticipation"> | string
    agentId?: StringNullableFilter<"MatchParticipation"> | string | null
    createdAt?: DateTimeFilter<"MatchParticipation"> | Date | string
  }

  export type MatchPlayerStatsUpsertWithWhereUniqueWithoutAgentInput = {
    where: MatchPlayerStatsWhereUniqueInput
    update: XOR<MatchPlayerStatsUpdateWithoutAgentInput, MatchPlayerStatsUncheckedUpdateWithoutAgentInput>
    create: XOR<MatchPlayerStatsCreateWithoutAgentInput, MatchPlayerStatsUncheckedCreateWithoutAgentInput>
  }

  export type MatchPlayerStatsUpdateWithWhereUniqueWithoutAgentInput = {
    where: MatchPlayerStatsWhereUniqueInput
    data: XOR<MatchPlayerStatsUpdateWithoutAgentInput, MatchPlayerStatsUncheckedUpdateWithoutAgentInput>
  }

  export type MatchPlayerStatsUpdateManyWithWhereWithoutAgentInput = {
    where: MatchPlayerStatsScalarWhereInput
    data: XOR<MatchPlayerStatsUpdateManyMutationInput, MatchPlayerStatsUncheckedUpdateManyWithoutAgentInput>
  }

  export type MatchPlayerStatsScalarWhereInput = {
    AND?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
    OR?: MatchPlayerStatsScalarWhereInput[]
    NOT?: MatchPlayerStatsScalarWhereInput | MatchPlayerStatsScalarWhereInput[]
    id?: IntFilter<"MatchPlayerStats"> | number
    matchParticipationId?: IntFilter<"MatchPlayerStats"> | number
    matchId?: IntFilter<"MatchPlayerStats"> | number
    playerId?: IntFilter<"MatchPlayerStats"> | number
    agentId?: StringNullableFilter<"MatchPlayerStats"> | string | null
    agentName?: StringNullableFilter<"MatchPlayerStats"> | string | null
    score?: IntFilter<"MatchPlayerStats"> | number
    kills?: IntFilter<"MatchPlayerStats"> | number
    deaths?: IntFilter<"MatchPlayerStats"> | number
    assists?: IntFilter<"MatchPlayerStats"> | number
    headshots?: IntFilter<"MatchPlayerStats"> | number
    bodyshots?: IntFilter<"MatchPlayerStats"> | number
    legshots?: IntFilter<"MatchPlayerStats"> | number
    damageDealt?: IntFilter<"MatchPlayerStats"> | number
    damageReceived?: IntFilter<"MatchPlayerStats"> | number
    adr?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    acs?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    kd?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    hsPercent?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    kast?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    firstKills?: IntNullableFilter<"MatchPlayerStats"> | number | null
    firstDeaths?: IntNullableFilter<"MatchPlayerStats"> | number | null
    grenadeCasts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ability1Casts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ability2Casts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    ultimateCasts?: IntNullableFilter<"MatchPlayerStats"> | number | null
    spentOverall?: IntNullableFilter<"MatchPlayerStats"> | number | null
    spentAverage?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    loadoutOverall?: IntNullableFilter<"MatchPlayerStats"> | number | null
    loadoutAverage?: FloatNullableFilter<"MatchPlayerStats"> | number | null
    createdAt?: DateTimeFilter<"MatchPlayerStats"> | Date | string
    updatedAt?: DateTimeFilter<"MatchPlayerStats"> | Date | string
  }

  export type MatchCreateWithoutMapInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutMapInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutMapInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutMapInput, MatchUncheckedCreateWithoutMapInput>
  }

  export type MatchCreateManyMapInputEnvelope = {
    data: MatchCreateManyMapInput | MatchCreateManyMapInput[]
    skipDuplicates?: boolean
  }

  export type MatchUpsertWithWhereUniqueWithoutMapInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutMapInput, MatchUncheckedUpdateWithoutMapInput>
    create: XOR<MatchCreateWithoutMapInput, MatchUncheckedCreateWithoutMapInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutMapInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutMapInput, MatchUncheckedUpdateWithoutMapInput>
  }

  export type MatchUpdateManyWithWhereWithoutMapInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutMapInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: IntFilter<"Match"> | number
    seriesId?: IntFilter<"Match"> | number
    matchNumber?: IntFilter<"Match"> | number
    riotMatchId?: StringNullableFilter<"Match"> | string | null
    mapId?: StringFilter<"Match"> | string
    gameLengthMs?: IntNullableFilter<"Match"> | number | null
    startedAt?: DateTimeFilter<"Match"> | Date | string
    completedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    isCompleted?: BoolFilter<"Match"> | boolean
    status?: StringFilter<"Match"> | string
    winnerTeamSide?: StringNullableFilter<"Match"> | string | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type SeasonCreateWithoutLeagueInput = {
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesCreateNestedManyWithoutSeasonInput
    teamRosters?: TeamRosterCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutLeagueInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutSeasonInput
    teamRosters?: TeamRosterUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutLeagueInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutLeagueInput, SeasonUncheckedCreateWithoutLeagueInput>
  }

  export type SeasonCreateManyLeagueInputEnvelope = {
    data: SeasonCreateManyLeagueInput | SeasonCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type SeasonUpsertWithWhereUniqueWithoutLeagueInput = {
    where: SeasonWhereUniqueInput
    update: XOR<SeasonUpdateWithoutLeagueInput, SeasonUncheckedUpdateWithoutLeagueInput>
    create: XOR<SeasonCreateWithoutLeagueInput, SeasonUncheckedCreateWithoutLeagueInput>
  }

  export type SeasonUpdateWithWhereUniqueWithoutLeagueInput = {
    where: SeasonWhereUniqueInput
    data: XOR<SeasonUpdateWithoutLeagueInput, SeasonUncheckedUpdateWithoutLeagueInput>
  }

  export type SeasonUpdateManyWithWhereWithoutLeagueInput = {
    where: SeasonScalarWhereInput
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyWithoutLeagueInput>
  }

  export type SeasonScalarWhereInput = {
    AND?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    OR?: SeasonScalarWhereInput[]
    NOT?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    id?: IntFilter<"Season"> | number
    leagueId?: IntFilter<"Season"> | number
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeNullableFilter<"Season"> | Date | string | null
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
  }

  export type LeagueCreateWithoutSeasonsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueUncheckedCreateWithoutSeasonsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueCreateOrConnectWithoutSeasonsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutSeasonsInput, LeagueUncheckedCreateWithoutSeasonsInput>
  }

  export type SeriesCreateWithoutSeasonInput = {
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    redTeam: TeamCreateNestedOneWithoutRedSeriesInput
    blueTeam: TeamCreateNestedOneWithoutBlueSeriesInput
    matches?: MatchCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutSeasonInput = {
    id?: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutSeasonInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutSeasonInput, SeriesUncheckedCreateWithoutSeasonInput>
  }

  export type SeriesCreateManySeasonInputEnvelope = {
    data: SeriesCreateManySeasonInput | SeriesCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type TeamRosterCreateWithoutSeasonInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutRostersInput
    player: PlayerCreateNestedOneWithoutRostersInput
  }

  export type TeamRosterUncheckedCreateWithoutSeasonInput = {
    id?: number
    teamId: number
    playerId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamRosterCreateOrConnectWithoutSeasonInput = {
    where: TeamRosterWhereUniqueInput
    create: XOR<TeamRosterCreateWithoutSeasonInput, TeamRosterUncheckedCreateWithoutSeasonInput>
  }

  export type TeamRosterCreateManySeasonInputEnvelope = {
    data: TeamRosterCreateManySeasonInput | TeamRosterCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithoutSeasonsInput = {
    update: XOR<LeagueUpdateWithoutSeasonsInput, LeagueUncheckedUpdateWithoutSeasonsInput>
    create: XOR<LeagueCreateWithoutSeasonsInput, LeagueUncheckedCreateWithoutSeasonsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutSeasonsInput, LeagueUncheckedUpdateWithoutSeasonsInput>
  }

  export type LeagueUpdateWithoutSeasonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueUncheckedUpdateWithoutSeasonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUpsertWithWhereUniqueWithoutSeasonInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutSeasonInput, SeriesUncheckedUpdateWithoutSeasonInput>
    create: XOR<SeriesCreateWithoutSeasonInput, SeriesUncheckedCreateWithoutSeasonInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutSeasonInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutSeasonInput, SeriesUncheckedUpdateWithoutSeasonInput>
  }

  export type SeriesUpdateManyWithWhereWithoutSeasonInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutSeasonInput>
  }

  export type SeriesScalarWhereInput = {
    AND?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
    OR?: SeriesScalarWhereInput[]
    NOT?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
    id?: IntFilter<"Series"> | number
    seasonId?: IntFilter<"Series"> | number
    redTeamId?: IntFilter<"Series"> | number
    blueTeamId?: IntFilter<"Series"> | number
    bestOf?: IntFilter<"Series"> | number
    winnerTeamId?: IntNullableFilter<"Series"> | number | null
    status?: StringFilter<"Series"> | string
    startDate?: DateTimeFilter<"Series"> | Date | string
    endDate?: DateTimeNullableFilter<"Series"> | Date | string | null
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
  }

  export type TeamRosterUpsertWithWhereUniqueWithoutSeasonInput = {
    where: TeamRosterWhereUniqueInput
    update: XOR<TeamRosterUpdateWithoutSeasonInput, TeamRosterUncheckedUpdateWithoutSeasonInput>
    create: XOR<TeamRosterCreateWithoutSeasonInput, TeamRosterUncheckedCreateWithoutSeasonInput>
  }

  export type TeamRosterUpdateWithWhereUniqueWithoutSeasonInput = {
    where: TeamRosterWhereUniqueInput
    data: XOR<TeamRosterUpdateWithoutSeasonInput, TeamRosterUncheckedUpdateWithoutSeasonInput>
  }

  export type TeamRosterUpdateManyWithWhereWithoutSeasonInput = {
    where: TeamRosterScalarWhereInput
    data: XOR<TeamRosterUpdateManyMutationInput, TeamRosterUncheckedUpdateManyWithoutSeasonInput>
  }

  export type TeamRosterScalarWhereInput = {
    AND?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
    OR?: TeamRosterScalarWhereInput[]
    NOT?: TeamRosterScalarWhereInput | TeamRosterScalarWhereInput[]
    id?: IntFilter<"TeamRoster"> | number
    teamId?: IntFilter<"TeamRoster"> | number
    playerId?: IntFilter<"TeamRoster"> | number
    seasonId?: IntFilter<"TeamRoster"> | number
    startDate?: DateTimeFilter<"TeamRoster"> | Date | string
    endDate?: DateTimeNullableFilter<"TeamRoster"> | Date | string | null
    createdAt?: DateTimeFilter<"TeamRoster"> | Date | string
    updatedAt?: DateTimeFilter<"TeamRoster"> | Date | string
  }

  export type TeamRosterCreateWithoutTeamInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutRostersInput
    season: SeasonCreateNestedOneWithoutTeamRostersInput
  }

  export type TeamRosterUncheckedCreateWithoutTeamInput = {
    id?: number
    playerId: number
    seasonId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamRosterCreateOrConnectWithoutTeamInput = {
    where: TeamRosterWhereUniqueInput
    create: XOR<TeamRosterCreateWithoutTeamInput, TeamRosterUncheckedCreateWithoutTeamInput>
  }

  export type TeamRosterCreateManyTeamInputEnvelope = {
    data: TeamRosterCreateManyTeamInput | TeamRosterCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type SeriesCreateWithoutRedTeamInput = {
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season: SeasonCreateNestedOneWithoutSeriesInput
    blueTeam: TeamCreateNestedOneWithoutBlueSeriesInput
    matches?: MatchCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutRedTeamInput = {
    id?: number
    seasonId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutRedTeamInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutRedTeamInput, SeriesUncheckedCreateWithoutRedTeamInput>
  }

  export type SeriesCreateManyRedTeamInputEnvelope = {
    data: SeriesCreateManyRedTeamInput | SeriesCreateManyRedTeamInput[]
    skipDuplicates?: boolean
  }

  export type SeriesCreateWithoutBlueTeamInput = {
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season: SeasonCreateNestedOneWithoutSeriesInput
    redTeam: TeamCreateNestedOneWithoutRedSeriesInput
    matches?: MatchCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutBlueTeamInput = {
    id?: number
    seasonId: number
    redTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutBlueTeamInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutBlueTeamInput, SeriesUncheckedCreateWithoutBlueTeamInput>
  }

  export type SeriesCreateManyBlueTeamInputEnvelope = {
    data: SeriesCreateManyBlueTeamInput | SeriesCreateManyBlueTeamInput[]
    skipDuplicates?: boolean
  }

  export type MatchTeamStatsCreateWithoutTeamInput = {
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutMatchTeamStatsInput
  }

  export type MatchTeamStatsUncheckedCreateWithoutTeamInput = {
    id?: number
    matchId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchTeamStatsCreateOrConnectWithoutTeamInput = {
    where: MatchTeamStatsWhereUniqueInput
    create: XOR<MatchTeamStatsCreateWithoutTeamInput, MatchTeamStatsUncheckedCreateWithoutTeamInput>
  }

  export type MatchTeamStatsCreateManyTeamInputEnvelope = {
    data: MatchTeamStatsCreateManyTeamInput | MatchTeamStatsCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type SubstitutionCreateWithoutTeamInput = {
    timestamp?: Date | string
    match: MatchCreateNestedOneWithoutSubstitutionsInput
    substitutedIn: PlayerCreateNestedOneWithoutSubInsInput
    substitutedOut: PlayerCreateNestedOneWithoutSubOutsInput
  }

  export type SubstitutionUncheckedCreateWithoutTeamInput = {
    id?: number
    matchId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type SubstitutionCreateOrConnectWithoutTeamInput = {
    where: SubstitutionWhereUniqueInput
    create: XOR<SubstitutionCreateWithoutTeamInput, SubstitutionUncheckedCreateWithoutTeamInput>
  }

  export type SubstitutionCreateManyTeamInputEnvelope = {
    data: SubstitutionCreateManyTeamInput | SubstitutionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type RoundTeamStatsCreateWithoutTeamInput = {
    teamSide: string
    won: boolean
    round: RoundCreateNestedOneWithoutTeamStatsInput
  }

  export type RoundTeamStatsUncheckedCreateWithoutTeamInput = {
    id?: number
    roundId: number
    teamSide: string
    won: boolean
  }

  export type RoundTeamStatsCreateOrConnectWithoutTeamInput = {
    where: RoundTeamStatsWhereUniqueInput
    create: XOR<RoundTeamStatsCreateWithoutTeamInput, RoundTeamStatsUncheckedCreateWithoutTeamInput>
  }

  export type RoundTeamStatsCreateManyTeamInputEnvelope = {
    data: RoundTeamStatsCreateManyTeamInput | RoundTeamStatsCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type MatchParticipationCreateWithoutTeamInput = {
    teamSide: string
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutParticipationsInput
    player: PlayerCreateNestedOneWithoutMatchParticipationsInput
    agent?: AgentCreateNestedOneWithoutMatchParticipationsInput
    matchStats?: MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateWithoutTeamInput = {
    id?: number
    matchId: number
    playerId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
    matchStats?: MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationCreateOrConnectWithoutTeamInput = {
    where: MatchParticipationWhereUniqueInput
    create: XOR<MatchParticipationCreateWithoutTeamInput, MatchParticipationUncheckedCreateWithoutTeamInput>
  }

  export type MatchParticipationCreateManyTeamInputEnvelope = {
    data: MatchParticipationCreateManyTeamInput | MatchParticipationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamRosterUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamRosterWhereUniqueInput
    update: XOR<TeamRosterUpdateWithoutTeamInput, TeamRosterUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamRosterCreateWithoutTeamInput, TeamRosterUncheckedCreateWithoutTeamInput>
  }

  export type TeamRosterUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamRosterWhereUniqueInput
    data: XOR<TeamRosterUpdateWithoutTeamInput, TeamRosterUncheckedUpdateWithoutTeamInput>
  }

  export type TeamRosterUpdateManyWithWhereWithoutTeamInput = {
    where: TeamRosterScalarWhereInput
    data: XOR<TeamRosterUpdateManyMutationInput, TeamRosterUncheckedUpdateManyWithoutTeamInput>
  }

  export type SeriesUpsertWithWhereUniqueWithoutRedTeamInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutRedTeamInput, SeriesUncheckedUpdateWithoutRedTeamInput>
    create: XOR<SeriesCreateWithoutRedTeamInput, SeriesUncheckedCreateWithoutRedTeamInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutRedTeamInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutRedTeamInput, SeriesUncheckedUpdateWithoutRedTeamInput>
  }

  export type SeriesUpdateManyWithWhereWithoutRedTeamInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutRedTeamInput>
  }

  export type SeriesUpsertWithWhereUniqueWithoutBlueTeamInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutBlueTeamInput, SeriesUncheckedUpdateWithoutBlueTeamInput>
    create: XOR<SeriesCreateWithoutBlueTeamInput, SeriesUncheckedCreateWithoutBlueTeamInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutBlueTeamInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutBlueTeamInput, SeriesUncheckedUpdateWithoutBlueTeamInput>
  }

  export type SeriesUpdateManyWithWhereWithoutBlueTeamInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutBlueTeamInput>
  }

  export type MatchTeamStatsUpsertWithWhereUniqueWithoutTeamInput = {
    where: MatchTeamStatsWhereUniqueInput
    update: XOR<MatchTeamStatsUpdateWithoutTeamInput, MatchTeamStatsUncheckedUpdateWithoutTeamInput>
    create: XOR<MatchTeamStatsCreateWithoutTeamInput, MatchTeamStatsUncheckedCreateWithoutTeamInput>
  }

  export type MatchTeamStatsUpdateWithWhereUniqueWithoutTeamInput = {
    where: MatchTeamStatsWhereUniqueInput
    data: XOR<MatchTeamStatsUpdateWithoutTeamInput, MatchTeamStatsUncheckedUpdateWithoutTeamInput>
  }

  export type MatchTeamStatsUpdateManyWithWhereWithoutTeamInput = {
    where: MatchTeamStatsScalarWhereInput
    data: XOR<MatchTeamStatsUpdateManyMutationInput, MatchTeamStatsUncheckedUpdateManyWithoutTeamInput>
  }

  export type MatchTeamStatsScalarWhereInput = {
    AND?: MatchTeamStatsScalarWhereInput | MatchTeamStatsScalarWhereInput[]
    OR?: MatchTeamStatsScalarWhereInput[]
    NOT?: MatchTeamStatsScalarWhereInput | MatchTeamStatsScalarWhereInput[]
    id?: IntFilter<"MatchTeamStats"> | number
    matchId?: IntFilter<"MatchTeamStats"> | number
    teamId?: IntFilter<"MatchTeamStats"> | number
    teamSide?: StringFilter<"MatchTeamStats"> | string
    roundsWon?: IntFilter<"MatchTeamStats"> | number
    roundsLost?: IntFilter<"MatchTeamStats"> | number
    won?: BoolFilter<"MatchTeamStats"> | boolean
    createdAt?: DateTimeFilter<"MatchTeamStats"> | Date | string
    updatedAt?: DateTimeFilter<"MatchTeamStats"> | Date | string
  }

  export type SubstitutionUpsertWithWhereUniqueWithoutTeamInput = {
    where: SubstitutionWhereUniqueInput
    update: XOR<SubstitutionUpdateWithoutTeamInput, SubstitutionUncheckedUpdateWithoutTeamInput>
    create: XOR<SubstitutionCreateWithoutTeamInput, SubstitutionUncheckedCreateWithoutTeamInput>
  }

  export type SubstitutionUpdateWithWhereUniqueWithoutTeamInput = {
    where: SubstitutionWhereUniqueInput
    data: XOR<SubstitutionUpdateWithoutTeamInput, SubstitutionUncheckedUpdateWithoutTeamInput>
  }

  export type SubstitutionUpdateManyWithWhereWithoutTeamInput = {
    where: SubstitutionScalarWhereInput
    data: XOR<SubstitutionUpdateManyMutationInput, SubstitutionUncheckedUpdateManyWithoutTeamInput>
  }

  export type SubstitutionScalarWhereInput = {
    AND?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
    OR?: SubstitutionScalarWhereInput[]
    NOT?: SubstitutionScalarWhereInput | SubstitutionScalarWhereInput[]
    id?: IntFilter<"Substitution"> | number
    matchId?: IntFilter<"Substitution"> | number
    teamId?: IntFilter<"Substitution"> | number
    substitutedInId?: IntFilter<"Substitution"> | number
    substitutedOutId?: IntFilter<"Substitution"> | number
    timestamp?: DateTimeFilter<"Substitution"> | Date | string
  }

  export type RoundTeamStatsUpsertWithWhereUniqueWithoutTeamInput = {
    where: RoundTeamStatsWhereUniqueInput
    update: XOR<RoundTeamStatsUpdateWithoutTeamInput, RoundTeamStatsUncheckedUpdateWithoutTeamInput>
    create: XOR<RoundTeamStatsCreateWithoutTeamInput, RoundTeamStatsUncheckedCreateWithoutTeamInput>
  }

  export type RoundTeamStatsUpdateWithWhereUniqueWithoutTeamInput = {
    where: RoundTeamStatsWhereUniqueInput
    data: XOR<RoundTeamStatsUpdateWithoutTeamInput, RoundTeamStatsUncheckedUpdateWithoutTeamInput>
  }

  export type RoundTeamStatsUpdateManyWithWhereWithoutTeamInput = {
    where: RoundTeamStatsScalarWhereInput
    data: XOR<RoundTeamStatsUpdateManyMutationInput, RoundTeamStatsUncheckedUpdateManyWithoutTeamInput>
  }

  export type RoundTeamStatsScalarWhereInput = {
    AND?: RoundTeamStatsScalarWhereInput | RoundTeamStatsScalarWhereInput[]
    OR?: RoundTeamStatsScalarWhereInput[]
    NOT?: RoundTeamStatsScalarWhereInput | RoundTeamStatsScalarWhereInput[]
    id?: IntFilter<"RoundTeamStats"> | number
    roundId?: IntFilter<"RoundTeamStats"> | number
    teamId?: IntFilter<"RoundTeamStats"> | number
    teamSide?: StringFilter<"RoundTeamStats"> | string
    won?: BoolFilter<"RoundTeamStats"> | boolean
  }

  export type MatchParticipationUpsertWithWhereUniqueWithoutTeamInput = {
    where: MatchParticipationWhereUniqueInput
    update: XOR<MatchParticipationUpdateWithoutTeamInput, MatchParticipationUncheckedUpdateWithoutTeamInput>
    create: XOR<MatchParticipationCreateWithoutTeamInput, MatchParticipationUncheckedCreateWithoutTeamInput>
  }

  export type MatchParticipationUpdateWithWhereUniqueWithoutTeamInput = {
    where: MatchParticipationWhereUniqueInput
    data: XOR<MatchParticipationUpdateWithoutTeamInput, MatchParticipationUncheckedUpdateWithoutTeamInput>
  }

  export type MatchParticipationUpdateManyWithWhereWithoutTeamInput = {
    where: MatchParticipationScalarWhereInput
    data: XOR<MatchParticipationUpdateManyMutationInput, MatchParticipationUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamRosterCreateWithoutPlayerInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutRostersInput
    season: SeasonCreateNestedOneWithoutTeamRostersInput
  }

  export type TeamRosterUncheckedCreateWithoutPlayerInput = {
    id?: number
    teamId: number
    seasonId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamRosterCreateOrConnectWithoutPlayerInput = {
    where: TeamRosterWhereUniqueInput
    create: XOR<TeamRosterCreateWithoutPlayerInput, TeamRosterUncheckedCreateWithoutPlayerInput>
  }

  export type TeamRosterCreateManyPlayerInputEnvelope = {
    data: TeamRosterCreateManyPlayerInput | TeamRosterCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type SubstitutionCreateWithoutSubstitutedInInput = {
    timestamp?: Date | string
    match: MatchCreateNestedOneWithoutSubstitutionsInput
    team: TeamCreateNestedOneWithoutSubstitutionsInput
    substitutedOut: PlayerCreateNestedOneWithoutSubOutsInput
  }

  export type SubstitutionUncheckedCreateWithoutSubstitutedInInput = {
    id?: number
    matchId: number
    teamId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type SubstitutionCreateOrConnectWithoutSubstitutedInInput = {
    where: SubstitutionWhereUniqueInput
    create: XOR<SubstitutionCreateWithoutSubstitutedInInput, SubstitutionUncheckedCreateWithoutSubstitutedInInput>
  }

  export type SubstitutionCreateManySubstitutedInInputEnvelope = {
    data: SubstitutionCreateManySubstitutedInInput | SubstitutionCreateManySubstitutedInInput[]
    skipDuplicates?: boolean
  }

  export type SubstitutionCreateWithoutSubstitutedOutInput = {
    timestamp?: Date | string
    match: MatchCreateNestedOneWithoutSubstitutionsInput
    team: TeamCreateNestedOneWithoutSubstitutionsInput
    substitutedIn: PlayerCreateNestedOneWithoutSubInsInput
  }

  export type SubstitutionUncheckedCreateWithoutSubstitutedOutInput = {
    id?: number
    matchId: number
    teamId: number
    substitutedInId: number
    timestamp?: Date | string
  }

  export type SubstitutionCreateOrConnectWithoutSubstitutedOutInput = {
    where: SubstitutionWhereUniqueInput
    create: XOR<SubstitutionCreateWithoutSubstitutedOutInput, SubstitutionUncheckedCreateWithoutSubstitutedOutInput>
  }

  export type SubstitutionCreateManySubstitutedOutInputEnvelope = {
    data: SubstitutionCreateManySubstitutedOutInput | SubstitutionCreateManySubstitutedOutInput[]
    skipDuplicates?: boolean
  }

  export type PlantCreateWithoutPlayerInput = {
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
    round: RoundCreateNestedOneWithoutPlantInput
  }

  export type PlantUncheckedCreateWithoutPlayerInput = {
    id?: number
    roundId: number
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
  }

  export type PlantCreateOrConnectWithoutPlayerInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutPlayerInput, PlantUncheckedCreateWithoutPlayerInput>
  }

  export type PlantCreateManyPlayerInputEnvelope = {
    data: PlantCreateManyPlayerInput | PlantCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type DefuseCreateWithoutPlayerInput = {
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
    round: RoundCreateNestedOneWithoutDefuseInput
  }

  export type DefuseUncheckedCreateWithoutPlayerInput = {
    id?: number
    roundId: number
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
  }

  export type DefuseCreateOrConnectWithoutPlayerInput = {
    where: DefuseWhereUniqueInput
    create: XOR<DefuseCreateWithoutPlayerInput, DefuseUncheckedCreateWithoutPlayerInput>
  }

  export type DefuseCreateManyPlayerInputEnvelope = {
    data: DefuseCreateManyPlayerInput | DefuseCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type RoundPlayerStatsCreateWithoutPlayerInput = {
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
    round: RoundCreateNestedOneWithoutPlayerStatsInput
    matchParticipation: MatchParticipationCreateNestedOneWithoutRoundStatsInput
  }

  export type RoundPlayerStatsUncheckedCreateWithoutPlayerInput = {
    id?: number
    roundId: number
    matchParticipationId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundPlayerStatsCreateOrConnectWithoutPlayerInput = {
    where: RoundPlayerStatsWhereUniqueInput
    create: XOR<RoundPlayerStatsCreateWithoutPlayerInput, RoundPlayerStatsUncheckedCreateWithoutPlayerInput>
  }

  export type RoundPlayerStatsCreateManyPlayerInputEnvelope = {
    data: RoundPlayerStatsCreateManyPlayerInput | RoundPlayerStatsCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type MatchPlayerStatsCreateWithoutPlayerInput = {
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipation: MatchParticipationCreateNestedOneWithoutMatchStatsInput
    match: MatchCreateNestedOneWithoutMatchPlayerStatsInput
    Agent?: AgentCreateNestedOneWithoutMatchPlayerStatsInput
  }

  export type MatchPlayerStatsUncheckedCreateWithoutPlayerInput = {
    id?: number
    matchParticipationId: number
    matchId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsCreateOrConnectWithoutPlayerInput = {
    where: MatchPlayerStatsWhereUniqueInput
    create: XOR<MatchPlayerStatsCreateWithoutPlayerInput, MatchPlayerStatsUncheckedCreateWithoutPlayerInput>
  }

  export type MatchPlayerStatsCreateManyPlayerInputEnvelope = {
    data: MatchPlayerStatsCreateManyPlayerInput | MatchPlayerStatsCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type KillCreateWithoutKillerInput = {
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutKillsInput
    victim: PlayerCreateNestedOneWithoutDeathsInput
    assistants?: PlayerCreateNestedManyWithoutKillAssistsInput
  }

  export type KillUncheckedCreateWithoutKillerInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    assistants?: PlayerUncheckedCreateNestedManyWithoutKillAssistsInput
  }

  export type KillCreateOrConnectWithoutKillerInput = {
    where: KillWhereUniqueInput
    create: XOR<KillCreateWithoutKillerInput, KillUncheckedCreateWithoutKillerInput>
  }

  export type KillCreateManyKillerInputEnvelope = {
    data: KillCreateManyKillerInput | KillCreateManyKillerInput[]
    skipDuplicates?: boolean
  }

  export type KillCreateWithoutVictimInput = {
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutKillsInput
    killer: PlayerCreateNestedOneWithoutKillsInput
    assistants?: PlayerCreateNestedManyWithoutKillAssistsInput
  }

  export type KillUncheckedCreateWithoutVictimInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    assistants?: PlayerUncheckedCreateNestedManyWithoutKillAssistsInput
  }

  export type KillCreateOrConnectWithoutVictimInput = {
    where: KillWhereUniqueInput
    create: XOR<KillCreateWithoutVictimInput, KillUncheckedCreateWithoutVictimInput>
  }

  export type KillCreateManyVictimInputEnvelope = {
    data: KillCreateManyVictimInput | KillCreateManyVictimInput[]
    skipDuplicates?: boolean
  }

  export type KillCreateWithoutAssistantsInput = {
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutKillsInput
    killer: PlayerCreateNestedOneWithoutKillsInput
    victim: PlayerCreateNestedOneWithoutDeathsInput
  }

  export type KillUncheckedCreateWithoutAssistantsInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
  }

  export type KillCreateOrConnectWithoutAssistantsInput = {
    where: KillWhereUniqueInput
    create: XOR<KillCreateWithoutAssistantsInput, KillUncheckedCreateWithoutAssistantsInput>
  }

  export type MatchParticipationCreateWithoutPlayerInput = {
    teamSide: string
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutParticipationsInput
    team: TeamCreateNestedOneWithoutMatchParticipationsInput
    agent?: AgentCreateNestedOneWithoutMatchParticipationsInput
    matchStats?: MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateWithoutPlayerInput = {
    id?: number
    matchId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
    matchStats?: MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationCreateOrConnectWithoutPlayerInput = {
    where: MatchParticipationWhereUniqueInput
    create: XOR<MatchParticipationCreateWithoutPlayerInput, MatchParticipationUncheckedCreateWithoutPlayerInput>
  }

  export type MatchParticipationCreateManyPlayerInputEnvelope = {
    data: MatchParticipationCreateManyPlayerInput | MatchParticipationCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type TeamRosterUpsertWithWhereUniqueWithoutPlayerInput = {
    where: TeamRosterWhereUniqueInput
    update: XOR<TeamRosterUpdateWithoutPlayerInput, TeamRosterUncheckedUpdateWithoutPlayerInput>
    create: XOR<TeamRosterCreateWithoutPlayerInput, TeamRosterUncheckedCreateWithoutPlayerInput>
  }

  export type TeamRosterUpdateWithWhereUniqueWithoutPlayerInput = {
    where: TeamRosterWhereUniqueInput
    data: XOR<TeamRosterUpdateWithoutPlayerInput, TeamRosterUncheckedUpdateWithoutPlayerInput>
  }

  export type TeamRosterUpdateManyWithWhereWithoutPlayerInput = {
    where: TeamRosterScalarWhereInput
    data: XOR<TeamRosterUpdateManyMutationInput, TeamRosterUncheckedUpdateManyWithoutPlayerInput>
  }

  export type SubstitutionUpsertWithWhereUniqueWithoutSubstitutedInInput = {
    where: SubstitutionWhereUniqueInput
    update: XOR<SubstitutionUpdateWithoutSubstitutedInInput, SubstitutionUncheckedUpdateWithoutSubstitutedInInput>
    create: XOR<SubstitutionCreateWithoutSubstitutedInInput, SubstitutionUncheckedCreateWithoutSubstitutedInInput>
  }

  export type SubstitutionUpdateWithWhereUniqueWithoutSubstitutedInInput = {
    where: SubstitutionWhereUniqueInput
    data: XOR<SubstitutionUpdateWithoutSubstitutedInInput, SubstitutionUncheckedUpdateWithoutSubstitutedInInput>
  }

  export type SubstitutionUpdateManyWithWhereWithoutSubstitutedInInput = {
    where: SubstitutionScalarWhereInput
    data: XOR<SubstitutionUpdateManyMutationInput, SubstitutionUncheckedUpdateManyWithoutSubstitutedInInput>
  }

  export type SubstitutionUpsertWithWhereUniqueWithoutSubstitutedOutInput = {
    where: SubstitutionWhereUniqueInput
    update: XOR<SubstitutionUpdateWithoutSubstitutedOutInput, SubstitutionUncheckedUpdateWithoutSubstitutedOutInput>
    create: XOR<SubstitutionCreateWithoutSubstitutedOutInput, SubstitutionUncheckedCreateWithoutSubstitutedOutInput>
  }

  export type SubstitutionUpdateWithWhereUniqueWithoutSubstitutedOutInput = {
    where: SubstitutionWhereUniqueInput
    data: XOR<SubstitutionUpdateWithoutSubstitutedOutInput, SubstitutionUncheckedUpdateWithoutSubstitutedOutInput>
  }

  export type SubstitutionUpdateManyWithWhereWithoutSubstitutedOutInput = {
    where: SubstitutionScalarWhereInput
    data: XOR<SubstitutionUpdateManyMutationInput, SubstitutionUncheckedUpdateManyWithoutSubstitutedOutInput>
  }

  export type PlantUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlantWhereUniqueInput
    update: XOR<PlantUpdateWithoutPlayerInput, PlantUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlantCreateWithoutPlayerInput, PlantUncheckedCreateWithoutPlayerInput>
  }

  export type PlantUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlantWhereUniqueInput
    data: XOR<PlantUpdateWithoutPlayerInput, PlantUncheckedUpdateWithoutPlayerInput>
  }

  export type PlantUpdateManyWithWhereWithoutPlayerInput = {
    where: PlantScalarWhereInput
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlantScalarWhereInput = {
    AND?: PlantScalarWhereInput | PlantScalarWhereInput[]
    OR?: PlantScalarWhereInput[]
    NOT?: PlantScalarWhereInput | PlantScalarWhereInput[]
    id?: IntFilter<"Plant"> | number
    roundId?: IntFilter<"Plant"> | number
    playerId?: IntFilter<"Plant"> | number
    roundTimeMs?: IntFilter<"Plant"> | number
    site?: StringFilter<"Plant"> | string
    locationX?: FloatNullableFilter<"Plant"> | number | null
    locationY?: FloatNullableFilter<"Plant"> | number | null
  }

  export type DefuseUpsertWithWhereUniqueWithoutPlayerInput = {
    where: DefuseWhereUniqueInput
    update: XOR<DefuseUpdateWithoutPlayerInput, DefuseUncheckedUpdateWithoutPlayerInput>
    create: XOR<DefuseCreateWithoutPlayerInput, DefuseUncheckedCreateWithoutPlayerInput>
  }

  export type DefuseUpdateWithWhereUniqueWithoutPlayerInput = {
    where: DefuseWhereUniqueInput
    data: XOR<DefuseUpdateWithoutPlayerInput, DefuseUncheckedUpdateWithoutPlayerInput>
  }

  export type DefuseUpdateManyWithWhereWithoutPlayerInput = {
    where: DefuseScalarWhereInput
    data: XOR<DefuseUpdateManyMutationInput, DefuseUncheckedUpdateManyWithoutPlayerInput>
  }

  export type DefuseScalarWhereInput = {
    AND?: DefuseScalarWhereInput | DefuseScalarWhereInput[]
    OR?: DefuseScalarWhereInput[]
    NOT?: DefuseScalarWhereInput | DefuseScalarWhereInput[]
    id?: IntFilter<"Defuse"> | number
    roundId?: IntFilter<"Defuse"> | number
    playerId?: IntFilter<"Defuse"> | number
    roundTimeMs?: IntFilter<"Defuse"> | number
    locationX?: FloatNullableFilter<"Defuse"> | number | null
    locationY?: FloatNullableFilter<"Defuse"> | number | null
  }

  export type RoundPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput = {
    where: RoundPlayerStatsWhereUniqueInput
    update: XOR<RoundPlayerStatsUpdateWithoutPlayerInput, RoundPlayerStatsUncheckedUpdateWithoutPlayerInput>
    create: XOR<RoundPlayerStatsCreateWithoutPlayerInput, RoundPlayerStatsUncheckedCreateWithoutPlayerInput>
  }

  export type RoundPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput = {
    where: RoundPlayerStatsWhereUniqueInput
    data: XOR<RoundPlayerStatsUpdateWithoutPlayerInput, RoundPlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type RoundPlayerStatsUpdateManyWithWhereWithoutPlayerInput = {
    where: RoundPlayerStatsScalarWhereInput
    data: XOR<RoundPlayerStatsUpdateManyMutationInput, RoundPlayerStatsUncheckedUpdateManyWithoutPlayerInput>
  }

  export type RoundPlayerStatsScalarWhereInput = {
    AND?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
    OR?: RoundPlayerStatsScalarWhereInput[]
    NOT?: RoundPlayerStatsScalarWhereInput | RoundPlayerStatsScalarWhereInput[]
    id?: IntFilter<"RoundPlayerStats"> | number
    roundId?: IntFilter<"RoundPlayerStats"> | number
    matchParticipationId?: IntFilter<"RoundPlayerStats"> | number
    playerId?: IntFilter<"RoundPlayerStats"> | number
    score?: IntFilter<"RoundPlayerStats"> | number
    kills?: IntFilter<"RoundPlayerStats"> | number
    headshots?: IntFilter<"RoundPlayerStats"> | number
    bodyshots?: IntFilter<"RoundPlayerStats"> | number
    legshots?: IntFilter<"RoundPlayerStats"> | number
    grenadeCasts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ability1Casts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ability2Casts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    ultimateCasts?: IntNullableFilter<"RoundPlayerStats"> | number | null
    loadoutValue?: IntNullableFilter<"RoundPlayerStats"> | number | null
    creditsRemaining?: IntNullableFilter<"RoundPlayerStats"> | number | null
    weaponId?: StringNullableFilter<"RoundPlayerStats"> | string | null
    weaponName?: StringNullableFilter<"RoundPlayerStats"> | string | null
    armorId?: StringNullableFilter<"RoundPlayerStats"> | string | null
    armorName?: StringNullableFilter<"RoundPlayerStats"> | string | null
    createdAt?: DateTimeFilter<"RoundPlayerStats"> | Date | string
  }

  export type MatchPlayerStatsUpsertWithWhereUniqueWithoutPlayerInput = {
    where: MatchPlayerStatsWhereUniqueInput
    update: XOR<MatchPlayerStatsUpdateWithoutPlayerInput, MatchPlayerStatsUncheckedUpdateWithoutPlayerInput>
    create: XOR<MatchPlayerStatsCreateWithoutPlayerInput, MatchPlayerStatsUncheckedCreateWithoutPlayerInput>
  }

  export type MatchPlayerStatsUpdateWithWhereUniqueWithoutPlayerInput = {
    where: MatchPlayerStatsWhereUniqueInput
    data: XOR<MatchPlayerStatsUpdateWithoutPlayerInput, MatchPlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type MatchPlayerStatsUpdateManyWithWhereWithoutPlayerInput = {
    where: MatchPlayerStatsScalarWhereInput
    data: XOR<MatchPlayerStatsUpdateManyMutationInput, MatchPlayerStatsUncheckedUpdateManyWithoutPlayerInput>
  }

  export type KillUpsertWithWhereUniqueWithoutKillerInput = {
    where: KillWhereUniqueInput
    update: XOR<KillUpdateWithoutKillerInput, KillUncheckedUpdateWithoutKillerInput>
    create: XOR<KillCreateWithoutKillerInput, KillUncheckedCreateWithoutKillerInput>
  }

  export type KillUpdateWithWhereUniqueWithoutKillerInput = {
    where: KillWhereUniqueInput
    data: XOR<KillUpdateWithoutKillerInput, KillUncheckedUpdateWithoutKillerInput>
  }

  export type KillUpdateManyWithWhereWithoutKillerInput = {
    where: KillScalarWhereInput
    data: XOR<KillUpdateManyMutationInput, KillUncheckedUpdateManyWithoutKillerInput>
  }

  export type KillScalarWhereInput = {
    AND?: KillScalarWhereInput | KillScalarWhereInput[]
    OR?: KillScalarWhereInput[]
    NOT?: KillScalarWhereInput | KillScalarWhereInput[]
    id?: IntFilter<"Kill"> | number
    matchId?: IntFilter<"Kill"> | number
    roundNumber?: IntFilter<"Kill"> | number
    timeInRoundMs?: IntFilter<"Kill"> | number
    timeInMatchMs?: IntFilter<"Kill"> | number
    killerId?: IntFilter<"Kill"> | number
    victimId?: IntFilter<"Kill"> | number
    locationX?: FloatNullableFilter<"Kill"> | number | null
    locationY?: FloatNullableFilter<"Kill"> | number | null
    weaponId?: StringNullableFilter<"Kill"> | string | null
    weaponName?: StringNullableFilter<"Kill"> | string | null
    weaponType?: StringNullableFilter<"Kill"> | string | null
    secondaryFireMode?: BoolFilter<"Kill"> | boolean
    createdAt?: DateTimeFilter<"Kill"> | Date | string
  }

  export type KillUpsertWithWhereUniqueWithoutVictimInput = {
    where: KillWhereUniqueInput
    update: XOR<KillUpdateWithoutVictimInput, KillUncheckedUpdateWithoutVictimInput>
    create: XOR<KillCreateWithoutVictimInput, KillUncheckedCreateWithoutVictimInput>
  }

  export type KillUpdateWithWhereUniqueWithoutVictimInput = {
    where: KillWhereUniqueInput
    data: XOR<KillUpdateWithoutVictimInput, KillUncheckedUpdateWithoutVictimInput>
  }

  export type KillUpdateManyWithWhereWithoutVictimInput = {
    where: KillScalarWhereInput
    data: XOR<KillUpdateManyMutationInput, KillUncheckedUpdateManyWithoutVictimInput>
  }

  export type KillUpsertWithWhereUniqueWithoutAssistantsInput = {
    where: KillWhereUniqueInput
    update: XOR<KillUpdateWithoutAssistantsInput, KillUncheckedUpdateWithoutAssistantsInput>
    create: XOR<KillCreateWithoutAssistantsInput, KillUncheckedCreateWithoutAssistantsInput>
  }

  export type KillUpdateWithWhereUniqueWithoutAssistantsInput = {
    where: KillWhereUniqueInput
    data: XOR<KillUpdateWithoutAssistantsInput, KillUncheckedUpdateWithoutAssistantsInput>
  }

  export type KillUpdateManyWithWhereWithoutAssistantsInput = {
    where: KillScalarWhereInput
    data: XOR<KillUpdateManyMutationInput, KillUncheckedUpdateManyWithoutAssistantsInput>
  }

  export type MatchParticipationUpsertWithWhereUniqueWithoutPlayerInput = {
    where: MatchParticipationWhereUniqueInput
    update: XOR<MatchParticipationUpdateWithoutPlayerInput, MatchParticipationUncheckedUpdateWithoutPlayerInput>
    create: XOR<MatchParticipationCreateWithoutPlayerInput, MatchParticipationUncheckedCreateWithoutPlayerInput>
  }

  export type MatchParticipationUpdateWithWhereUniqueWithoutPlayerInput = {
    where: MatchParticipationWhereUniqueInput
    data: XOR<MatchParticipationUpdateWithoutPlayerInput, MatchParticipationUncheckedUpdateWithoutPlayerInput>
  }

  export type MatchParticipationUpdateManyWithWhereWithoutPlayerInput = {
    where: MatchParticipationScalarWhereInput
    data: XOR<MatchParticipationUpdateManyMutationInput, MatchParticipationUncheckedUpdateManyWithoutPlayerInput>
  }

  export type SeasonCreateWithoutSeriesInput = {
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutSeasonsInput
    teamRosters?: TeamRosterCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutSeriesInput = {
    id?: number
    leagueId: number
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamRosters?: TeamRosterUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutSeriesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput>
  }

  export type TeamCreateWithoutRedSeriesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutRedSeriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutRedSeriesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRedSeriesInput, TeamUncheckedCreateWithoutRedSeriesInput>
  }

  export type TeamCreateWithoutBlueSeriesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutBlueSeriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutBlueSeriesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutBlueSeriesInput, TeamUncheckedCreateWithoutBlueSeriesInput>
  }

  export type MatchCreateWithoutSeriesInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutSeriesInput = {
    id?: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutSeriesInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutSeriesInput, MatchUncheckedCreateWithoutSeriesInput>
  }

  export type MatchCreateManySeriesInputEnvelope = {
    data: MatchCreateManySeriesInput | MatchCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type SeasonUpsertWithoutSeriesInput = {
    update: XOR<SeasonUpdateWithoutSeriesInput, SeasonUncheckedUpdateWithoutSeriesInput>
    create: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutSeriesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutSeriesInput, SeasonUncheckedUpdateWithoutSeriesInput>
  }

  export type SeasonUpdateWithoutSeriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutSeasonsNestedInput
    teamRosters?: TeamRosterUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamRosters?: TeamRosterUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type TeamUpsertWithoutRedSeriesInput = {
    update: XOR<TeamUpdateWithoutRedSeriesInput, TeamUncheckedUpdateWithoutRedSeriesInput>
    create: XOR<TeamCreateWithoutRedSeriesInput, TeamUncheckedCreateWithoutRedSeriesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRedSeriesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRedSeriesInput, TeamUncheckedUpdateWithoutRedSeriesInput>
  }

  export type TeamUpdateWithoutRedSeriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRedSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutBlueSeriesInput = {
    update: XOR<TeamUpdateWithoutBlueSeriesInput, TeamUncheckedUpdateWithoutBlueSeriesInput>
    create: XOR<TeamCreateWithoutBlueSeriesInput, TeamUncheckedCreateWithoutBlueSeriesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutBlueSeriesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutBlueSeriesInput, TeamUncheckedUpdateWithoutBlueSeriesInput>
  }

  export type TeamUpdateWithoutBlueSeriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutBlueSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type MatchUpsertWithWhereUniqueWithoutSeriesInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutSeriesInput, MatchUncheckedUpdateWithoutSeriesInput>
    create: XOR<MatchCreateWithoutSeriesInput, MatchUncheckedCreateWithoutSeriesInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutSeriesInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutSeriesInput, MatchUncheckedUpdateWithoutSeriesInput>
  }

  export type MatchUpdateManyWithWhereWithoutSeriesInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutSeriesInput>
  }

  export type SeriesCreateWithoutMatchesInput = {
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season: SeasonCreateNestedOneWithoutSeriesInput
    redTeam: TeamCreateNestedOneWithoutRedSeriesInput
    blueTeam: TeamCreateNestedOneWithoutBlueSeriesInput
  }

  export type SeriesUncheckedCreateWithoutMatchesInput = {
    id?: number
    seasonId: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesCreateOrConnectWithoutMatchesInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutMatchesInput, SeriesUncheckedCreateWithoutMatchesInput>
  }

  export type MapCreateWithoutMatchesInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapUncheckedCreateWithoutMatchesInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapCreateOrConnectWithoutMatchesInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutMatchesInput, MapUncheckedCreateWithoutMatchesInput>
  }

  export type RoundCreateWithoutMatchInput = {
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plant?: PlantCreateNestedOneWithoutRoundInput
    defuse?: DefuseCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutMatchInput = {
    id?: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plant?: PlantUncheckedCreateNestedOneWithoutRoundInput
    defuse?: DefuseUncheckedCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutMatchInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutMatchInput, RoundUncheckedCreateWithoutMatchInput>
  }

  export type RoundCreateManyMatchInputEnvelope = {
    data: RoundCreateManyMatchInput | RoundCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type MatchPlayerStatsCreateWithoutMatchInput = {
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipation: MatchParticipationCreateNestedOneWithoutMatchStatsInput
    player: PlayerCreateNestedOneWithoutMatchStatsInput
    Agent?: AgentCreateNestedOneWithoutMatchPlayerStatsInput
  }

  export type MatchPlayerStatsUncheckedCreateWithoutMatchInput = {
    id?: number
    matchParticipationId: number
    playerId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsCreateOrConnectWithoutMatchInput = {
    where: MatchPlayerStatsWhereUniqueInput
    create: XOR<MatchPlayerStatsCreateWithoutMatchInput, MatchPlayerStatsUncheckedCreateWithoutMatchInput>
  }

  export type MatchPlayerStatsCreateManyMatchInputEnvelope = {
    data: MatchPlayerStatsCreateManyMatchInput | MatchPlayerStatsCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type MatchTeamStatsCreateWithoutMatchInput = {
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
  }

  export type MatchTeamStatsUncheckedCreateWithoutMatchInput = {
    id?: number
    teamId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchTeamStatsCreateOrConnectWithoutMatchInput = {
    where: MatchTeamStatsWhereUniqueInput
    create: XOR<MatchTeamStatsCreateWithoutMatchInput, MatchTeamStatsUncheckedCreateWithoutMatchInput>
  }

  export type MatchTeamStatsCreateManyMatchInputEnvelope = {
    data: MatchTeamStatsCreateManyMatchInput | MatchTeamStatsCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type SubstitutionCreateWithoutMatchInput = {
    timestamp?: Date | string
    team: TeamCreateNestedOneWithoutSubstitutionsInput
    substitutedIn: PlayerCreateNestedOneWithoutSubInsInput
    substitutedOut: PlayerCreateNestedOneWithoutSubOutsInput
  }

  export type SubstitutionUncheckedCreateWithoutMatchInput = {
    id?: number
    teamId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type SubstitutionCreateOrConnectWithoutMatchInput = {
    where: SubstitutionWhereUniqueInput
    create: XOR<SubstitutionCreateWithoutMatchInput, SubstitutionUncheckedCreateWithoutMatchInput>
  }

  export type SubstitutionCreateManyMatchInputEnvelope = {
    data: SubstitutionCreateManyMatchInput | SubstitutionCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type KillCreateWithoutMatchInput = {
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    killer: PlayerCreateNestedOneWithoutKillsInput
    victim: PlayerCreateNestedOneWithoutDeathsInput
    assistants?: PlayerCreateNestedManyWithoutKillAssistsInput
  }

  export type KillUncheckedCreateWithoutMatchInput = {
    id?: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
    assistants?: PlayerUncheckedCreateNestedManyWithoutKillAssistsInput
  }

  export type KillCreateOrConnectWithoutMatchInput = {
    where: KillWhereUniqueInput
    create: XOR<KillCreateWithoutMatchInput, KillUncheckedCreateWithoutMatchInput>
  }

  export type KillCreateManyMatchInputEnvelope = {
    data: KillCreateManyMatchInput | KillCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type MatchParticipationCreateWithoutMatchInput = {
    teamSide: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutMatchParticipationsInput
    team: TeamCreateNestedOneWithoutMatchParticipationsInput
    agent?: AgentCreateNestedOneWithoutMatchParticipationsInput
    matchStats?: MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateWithoutMatchInput = {
    id?: number
    playerId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
    matchStats?: MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationCreateOrConnectWithoutMatchInput = {
    where: MatchParticipationWhereUniqueInput
    create: XOR<MatchParticipationCreateWithoutMatchInput, MatchParticipationUncheckedCreateWithoutMatchInput>
  }

  export type MatchParticipationCreateManyMatchInputEnvelope = {
    data: MatchParticipationCreateManyMatchInput | MatchParticipationCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type SeriesUpsertWithoutMatchesInput = {
    update: XOR<SeriesUpdateWithoutMatchesInput, SeriesUncheckedUpdateWithoutMatchesInput>
    create: XOR<SeriesCreateWithoutMatchesInput, SeriesUncheckedCreateWithoutMatchesInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutMatchesInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutMatchesInput, SeriesUncheckedUpdateWithoutMatchesInput>
  }

  export type SeriesUpdateWithoutMatchesInput = {
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneRequiredWithoutSeriesNestedInput
    redTeam?: TeamUpdateOneRequiredWithoutRedSeriesNestedInput
    blueTeam?: TeamUpdateOneRequiredWithoutBlueSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUpsertWithoutMatchesInput = {
    update: XOR<MapUpdateWithoutMatchesInput, MapUncheckedUpdateWithoutMatchesInput>
    create: XOR<MapCreateWithoutMatchesInput, MapUncheckedCreateWithoutMatchesInput>
    where?: MapWhereInput
  }

  export type MapUpdateToOneWithWhereWithoutMatchesInput = {
    where?: MapWhereInput
    data: XOR<MapUpdateWithoutMatchesInput, MapUncheckedUpdateWithoutMatchesInput>
  }

  export type MapUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpsertWithWhereUniqueWithoutMatchInput = {
    where: RoundWhereUniqueInput
    update: XOR<RoundUpdateWithoutMatchInput, RoundUncheckedUpdateWithoutMatchInput>
    create: XOR<RoundCreateWithoutMatchInput, RoundUncheckedCreateWithoutMatchInput>
  }

  export type RoundUpdateWithWhereUniqueWithoutMatchInput = {
    where: RoundWhereUniqueInput
    data: XOR<RoundUpdateWithoutMatchInput, RoundUncheckedUpdateWithoutMatchInput>
  }

  export type RoundUpdateManyWithWhereWithoutMatchInput = {
    where: RoundScalarWhereInput
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyWithoutMatchInput>
  }

  export type RoundScalarWhereInput = {
    AND?: RoundScalarWhereInput | RoundScalarWhereInput[]
    OR?: RoundScalarWhereInput[]
    NOT?: RoundScalarWhereInput | RoundScalarWhereInput[]
    id?: IntFilter<"Round"> | number
    matchId?: IntFilter<"Round"> | number
    roundNumber?: IntFilter<"Round"> | number
    result?: StringFilter<"Round"> | string
    winningTeam?: StringFilter<"Round"> | string
    createdAt?: DateTimeFilter<"Round"> | Date | string
    updatedAt?: DateTimeFilter<"Round"> | Date | string
  }

  export type MatchPlayerStatsUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchPlayerStatsWhereUniqueInput
    update: XOR<MatchPlayerStatsUpdateWithoutMatchInput, MatchPlayerStatsUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchPlayerStatsCreateWithoutMatchInput, MatchPlayerStatsUncheckedCreateWithoutMatchInput>
  }

  export type MatchPlayerStatsUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchPlayerStatsWhereUniqueInput
    data: XOR<MatchPlayerStatsUpdateWithoutMatchInput, MatchPlayerStatsUncheckedUpdateWithoutMatchInput>
  }

  export type MatchPlayerStatsUpdateManyWithWhereWithoutMatchInput = {
    where: MatchPlayerStatsScalarWhereInput
    data: XOR<MatchPlayerStatsUpdateManyMutationInput, MatchPlayerStatsUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchTeamStatsUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchTeamStatsWhereUniqueInput
    update: XOR<MatchTeamStatsUpdateWithoutMatchInput, MatchTeamStatsUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchTeamStatsCreateWithoutMatchInput, MatchTeamStatsUncheckedCreateWithoutMatchInput>
  }

  export type MatchTeamStatsUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchTeamStatsWhereUniqueInput
    data: XOR<MatchTeamStatsUpdateWithoutMatchInput, MatchTeamStatsUncheckedUpdateWithoutMatchInput>
  }

  export type MatchTeamStatsUpdateManyWithWhereWithoutMatchInput = {
    where: MatchTeamStatsScalarWhereInput
    data: XOR<MatchTeamStatsUpdateManyMutationInput, MatchTeamStatsUncheckedUpdateManyWithoutMatchInput>
  }

  export type SubstitutionUpsertWithWhereUniqueWithoutMatchInput = {
    where: SubstitutionWhereUniqueInput
    update: XOR<SubstitutionUpdateWithoutMatchInput, SubstitutionUncheckedUpdateWithoutMatchInput>
    create: XOR<SubstitutionCreateWithoutMatchInput, SubstitutionUncheckedCreateWithoutMatchInput>
  }

  export type SubstitutionUpdateWithWhereUniqueWithoutMatchInput = {
    where: SubstitutionWhereUniqueInput
    data: XOR<SubstitutionUpdateWithoutMatchInput, SubstitutionUncheckedUpdateWithoutMatchInput>
  }

  export type SubstitutionUpdateManyWithWhereWithoutMatchInput = {
    where: SubstitutionScalarWhereInput
    data: XOR<SubstitutionUpdateManyMutationInput, SubstitutionUncheckedUpdateManyWithoutMatchInput>
  }

  export type KillUpsertWithWhereUniqueWithoutMatchInput = {
    where: KillWhereUniqueInput
    update: XOR<KillUpdateWithoutMatchInput, KillUncheckedUpdateWithoutMatchInput>
    create: XOR<KillCreateWithoutMatchInput, KillUncheckedCreateWithoutMatchInput>
  }

  export type KillUpdateWithWhereUniqueWithoutMatchInput = {
    where: KillWhereUniqueInput
    data: XOR<KillUpdateWithoutMatchInput, KillUncheckedUpdateWithoutMatchInput>
  }

  export type KillUpdateManyWithWhereWithoutMatchInput = {
    where: KillScalarWhereInput
    data: XOR<KillUpdateManyMutationInput, KillUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchParticipationUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchParticipationWhereUniqueInput
    update: XOR<MatchParticipationUpdateWithoutMatchInput, MatchParticipationUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchParticipationCreateWithoutMatchInput, MatchParticipationUncheckedCreateWithoutMatchInput>
  }

  export type MatchParticipationUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchParticipationWhereUniqueInput
    data: XOR<MatchParticipationUpdateWithoutMatchInput, MatchParticipationUncheckedUpdateWithoutMatchInput>
  }

  export type MatchParticipationUpdateManyWithWhereWithoutMatchInput = {
    where: MatchParticipationScalarWhereInput
    data: XOR<MatchParticipationUpdateManyMutationInput, MatchParticipationUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchCreateWithoutParticipationsInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutParticipationsInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutParticipationsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutParticipationsInput, MatchUncheckedCreateWithoutParticipationsInput>
  }

  export type PlayerCreateWithoutMatchParticipationsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
  }

  export type PlayerUncheckedCreateWithoutMatchParticipationsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
  }

  export type PlayerCreateOrConnectWithoutMatchParticipationsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMatchParticipationsInput, PlayerUncheckedCreateWithoutMatchParticipationsInput>
  }

  export type TeamCreateWithoutMatchParticipationsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMatchParticipationsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMatchParticipationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMatchParticipationsInput, TeamUncheckedCreateWithoutMatchParticipationsInput>
  }

  export type AgentCreateWithoutMatchParticipationsInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMatchParticipationsInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMatchParticipationsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMatchParticipationsInput, AgentUncheckedCreateWithoutMatchParticipationsInput>
  }

  export type MatchPlayerStatsCreateWithoutMatchParticipationInput = {
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutMatchPlayerStatsInput
    player: PlayerCreateNestedOneWithoutMatchStatsInput
    Agent?: AgentCreateNestedOneWithoutMatchPlayerStatsInput
  }

  export type MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput = {
    id?: number
    matchId: number
    playerId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsCreateOrConnectWithoutMatchParticipationInput = {
    where: MatchPlayerStatsWhereUniqueInput
    create: XOR<MatchPlayerStatsCreateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
  }

  export type RoundPlayerStatsCreateWithoutMatchParticipationInput = {
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
    round: RoundCreateNestedOneWithoutPlayerStatsInput
    player: PlayerCreateNestedOneWithoutRoundStatsInput
  }

  export type RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput = {
    id?: number
    roundId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundPlayerStatsCreateOrConnectWithoutMatchParticipationInput = {
    where: RoundPlayerStatsWhereUniqueInput
    create: XOR<RoundPlayerStatsCreateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
  }

  export type RoundPlayerStatsCreateManyMatchParticipationInputEnvelope = {
    data: RoundPlayerStatsCreateManyMatchParticipationInput | RoundPlayerStatsCreateManyMatchParticipationInput[]
    skipDuplicates?: boolean
  }

  export type MatchUpsertWithoutParticipationsInput = {
    update: XOR<MatchUpdateWithoutParticipationsInput, MatchUncheckedUpdateWithoutParticipationsInput>
    create: XOR<MatchCreateWithoutParticipationsInput, MatchUncheckedCreateWithoutParticipationsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutParticipationsInput, MatchUncheckedUpdateWithoutParticipationsInput>
  }

  export type MatchUpdateWithoutParticipationsInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutParticipationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type PlayerUpsertWithoutMatchParticipationsInput = {
    update: XOR<PlayerUpdateWithoutMatchParticipationsInput, PlayerUncheckedUpdateWithoutMatchParticipationsInput>
    create: XOR<PlayerCreateWithoutMatchParticipationsInput, PlayerUncheckedCreateWithoutMatchParticipationsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMatchParticipationsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMatchParticipationsInput, PlayerUncheckedUpdateWithoutMatchParticipationsInput>
  }

  export type PlayerUpdateWithoutMatchParticipationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMatchParticipationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
  }

  export type TeamUpsertWithoutMatchParticipationsInput = {
    update: XOR<TeamUpdateWithoutMatchParticipationsInput, TeamUncheckedUpdateWithoutMatchParticipationsInput>
    create: XOR<TeamCreateWithoutMatchParticipationsInput, TeamUncheckedCreateWithoutMatchParticipationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMatchParticipationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMatchParticipationsInput, TeamUncheckedUpdateWithoutMatchParticipationsInput>
  }

  export type TeamUpdateWithoutMatchParticipationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMatchParticipationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type AgentUpsertWithoutMatchParticipationsInput = {
    update: XOR<AgentUpdateWithoutMatchParticipationsInput, AgentUncheckedUpdateWithoutMatchParticipationsInput>
    create: XOR<AgentCreateWithoutMatchParticipationsInput, AgentUncheckedCreateWithoutMatchParticipationsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMatchParticipationsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMatchParticipationsInput, AgentUncheckedUpdateWithoutMatchParticipationsInput>
  }

  export type AgentUpdateWithoutMatchParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMatchParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type MatchPlayerStatsUpsertWithoutMatchParticipationInput = {
    update: XOR<MatchPlayerStatsUpdateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedUpdateWithoutMatchParticipationInput>
    create: XOR<MatchPlayerStatsCreateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
    where?: MatchPlayerStatsWhereInput
  }

  export type MatchPlayerStatsUpdateToOneWithWhereWithoutMatchParticipationInput = {
    where?: MatchPlayerStatsWhereInput
    data: XOR<MatchPlayerStatsUpdateWithoutMatchParticipationInput, MatchPlayerStatsUncheckedUpdateWithoutMatchParticipationInput>
  }

  export type MatchPlayerStatsUpdateWithoutMatchParticipationInput = {
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutMatchPlayerStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchStatsNestedInput
    Agent?: AgentUpdateOneWithoutMatchPlayerStatsNestedInput
  }

  export type MatchPlayerStatsUncheckedUpdateWithoutMatchParticipationInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsUpsertWithWhereUniqueWithoutMatchParticipationInput = {
    where: RoundPlayerStatsWhereUniqueInput
    update: XOR<RoundPlayerStatsUpdateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedUpdateWithoutMatchParticipationInput>
    create: XOR<RoundPlayerStatsCreateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedCreateWithoutMatchParticipationInput>
  }

  export type RoundPlayerStatsUpdateWithWhereUniqueWithoutMatchParticipationInput = {
    where: RoundPlayerStatsWhereUniqueInput
    data: XOR<RoundPlayerStatsUpdateWithoutMatchParticipationInput, RoundPlayerStatsUncheckedUpdateWithoutMatchParticipationInput>
  }

  export type RoundPlayerStatsUpdateManyWithWhereWithoutMatchParticipationInput = {
    where: RoundPlayerStatsScalarWhereInput
    data: XOR<RoundPlayerStatsUpdateManyMutationInput, RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationInput>
  }

  export type MatchParticipationCreateWithoutMatchStatsInput = {
    teamSide: string
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutParticipationsInput
    player: PlayerCreateNestedOneWithoutMatchParticipationsInput
    team: TeamCreateNestedOneWithoutMatchParticipationsInput
    agent?: AgentCreateNestedOneWithoutMatchParticipationsInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateWithoutMatchStatsInput = {
    id?: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutMatchParticipationInput
  }

  export type MatchParticipationCreateOrConnectWithoutMatchStatsInput = {
    where: MatchParticipationWhereUniqueInput
    create: XOR<MatchParticipationCreateWithoutMatchStatsInput, MatchParticipationUncheckedCreateWithoutMatchStatsInput>
  }

  export type MatchCreateWithoutMatchPlayerStatsInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutMatchPlayerStatsInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutMatchPlayerStatsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutMatchPlayerStatsInput, MatchUncheckedCreateWithoutMatchPlayerStatsInput>
  }

  export type PlayerCreateWithoutMatchStatsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMatchStatsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMatchStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMatchStatsInput, PlayerUncheckedCreateWithoutMatchStatsInput>
  }

  export type AgentCreateWithoutMatchPlayerStatsInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipations?: MatchParticipationCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMatchPlayerStatsInput = {
    id: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMatchPlayerStatsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMatchPlayerStatsInput, AgentUncheckedCreateWithoutMatchPlayerStatsInput>
  }

  export type MatchParticipationUpsertWithoutMatchStatsInput = {
    update: XOR<MatchParticipationUpdateWithoutMatchStatsInput, MatchParticipationUncheckedUpdateWithoutMatchStatsInput>
    create: XOR<MatchParticipationCreateWithoutMatchStatsInput, MatchParticipationUncheckedCreateWithoutMatchStatsInput>
    where?: MatchParticipationWhereInput
  }

  export type MatchParticipationUpdateToOneWithWhereWithoutMatchStatsInput = {
    where?: MatchParticipationWhereInput
    data: XOR<MatchParticipationUpdateWithoutMatchStatsInput, MatchParticipationUncheckedUpdateWithoutMatchStatsInput>
  }

  export type MatchParticipationUpdateWithoutMatchStatsInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutParticipationsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput
    agent?: AgentUpdateOneWithoutMatchParticipationsNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateWithoutMatchStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchUpsertWithoutMatchPlayerStatsInput = {
    update: XOR<MatchUpdateWithoutMatchPlayerStatsInput, MatchUncheckedUpdateWithoutMatchPlayerStatsInput>
    create: XOR<MatchCreateWithoutMatchPlayerStatsInput, MatchUncheckedCreateWithoutMatchPlayerStatsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutMatchPlayerStatsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutMatchPlayerStatsInput, MatchUncheckedUpdateWithoutMatchPlayerStatsInput>
  }

  export type MatchUpdateWithoutMatchPlayerStatsInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutMatchPlayerStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type PlayerUpsertWithoutMatchStatsInput = {
    update: XOR<PlayerUpdateWithoutMatchStatsInput, PlayerUncheckedUpdateWithoutMatchStatsInput>
    create: XOR<PlayerCreateWithoutMatchStatsInput, PlayerUncheckedCreateWithoutMatchStatsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMatchStatsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMatchStatsInput, PlayerUncheckedUpdateWithoutMatchStatsInput>
  }

  export type PlayerUpdateWithoutMatchStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMatchStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type AgentUpsertWithoutMatchPlayerStatsInput = {
    update: XOR<AgentUpdateWithoutMatchPlayerStatsInput, AgentUncheckedUpdateWithoutMatchPlayerStatsInput>
    create: XOR<AgentCreateWithoutMatchPlayerStatsInput, AgentUncheckedCreateWithoutMatchPlayerStatsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMatchPlayerStatsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMatchPlayerStatsInput, AgentUncheckedUpdateWithoutMatchPlayerStatsInput>
  }

  export type AgentUpdateWithoutMatchPlayerStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipations?: MatchParticipationUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMatchPlayerStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type MatchCreateWithoutMatchTeamStatsInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutMatchTeamStatsInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutMatchTeamStatsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutMatchTeamStatsInput, MatchUncheckedCreateWithoutMatchTeamStatsInput>
  }

  export type TeamCreateWithoutTeamStatsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamStatsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamStatsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
  }

  export type MatchUpsertWithoutMatchTeamStatsInput = {
    update: XOR<MatchUpdateWithoutMatchTeamStatsInput, MatchUncheckedUpdateWithoutMatchTeamStatsInput>
    create: XOR<MatchCreateWithoutMatchTeamStatsInput, MatchUncheckedCreateWithoutMatchTeamStatsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutMatchTeamStatsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutMatchTeamStatsInput, MatchUncheckedUpdateWithoutMatchTeamStatsInput>
  }

  export type MatchUpdateWithoutMatchTeamStatsInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutMatchTeamStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type TeamUpsertWithoutTeamStatsInput = {
    update: XOR<TeamUpdateWithoutTeamStatsInput, TeamUncheckedUpdateWithoutTeamStatsInput>
    create: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTeamStatsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTeamStatsInput, TeamUncheckedUpdateWithoutTeamStatsInput>
  }

  export type TeamUpdateWithoutTeamStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type MatchCreateWithoutRoundsInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutRoundsInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutRoundsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutRoundsInput, MatchUncheckedCreateWithoutRoundsInput>
  }

  export type PlantCreateWithoutRoundInput = {
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
    player: PlayerCreateNestedOneWithoutPlantsInput
  }

  export type PlantUncheckedCreateWithoutRoundInput = {
    id?: number
    playerId: number
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
  }

  export type PlantCreateOrConnectWithoutRoundInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutRoundInput, PlantUncheckedCreateWithoutRoundInput>
  }

  export type DefuseCreateWithoutRoundInput = {
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
    player: PlayerCreateNestedOneWithoutDefusesInput
  }

  export type DefuseUncheckedCreateWithoutRoundInput = {
    id?: number
    playerId: number
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
  }

  export type DefuseCreateOrConnectWithoutRoundInput = {
    where: DefuseWhereUniqueInput
    create: XOR<DefuseCreateWithoutRoundInput, DefuseUncheckedCreateWithoutRoundInput>
  }

  export type RoundPlayerStatsCreateWithoutRoundInput = {
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
    matchParticipation: MatchParticipationCreateNestedOneWithoutRoundStatsInput
    player: PlayerCreateNestedOneWithoutRoundStatsInput
  }

  export type RoundPlayerStatsUncheckedCreateWithoutRoundInput = {
    id?: number
    matchParticipationId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundPlayerStatsCreateOrConnectWithoutRoundInput = {
    where: RoundPlayerStatsWhereUniqueInput
    create: XOR<RoundPlayerStatsCreateWithoutRoundInput, RoundPlayerStatsUncheckedCreateWithoutRoundInput>
  }

  export type RoundPlayerStatsCreateManyRoundInputEnvelope = {
    data: RoundPlayerStatsCreateManyRoundInput | RoundPlayerStatsCreateManyRoundInput[]
    skipDuplicates?: boolean
  }

  export type RoundTeamStatsCreateWithoutRoundInput = {
    teamSide: string
    won: boolean
    team: TeamCreateNestedOneWithoutRoundStatsInput
  }

  export type RoundTeamStatsUncheckedCreateWithoutRoundInput = {
    id?: number
    teamId: number
    teamSide: string
    won: boolean
  }

  export type RoundTeamStatsCreateOrConnectWithoutRoundInput = {
    where: RoundTeamStatsWhereUniqueInput
    create: XOR<RoundTeamStatsCreateWithoutRoundInput, RoundTeamStatsUncheckedCreateWithoutRoundInput>
  }

  export type RoundTeamStatsCreateManyRoundInputEnvelope = {
    data: RoundTeamStatsCreateManyRoundInput | RoundTeamStatsCreateManyRoundInput[]
    skipDuplicates?: boolean
  }

  export type MatchUpsertWithoutRoundsInput = {
    update: XOR<MatchUpdateWithoutRoundsInput, MatchUncheckedUpdateWithoutRoundsInput>
    create: XOR<MatchCreateWithoutRoundsInput, MatchUncheckedCreateWithoutRoundsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutRoundsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutRoundsInput, MatchUncheckedUpdateWithoutRoundsInput>
  }

  export type MatchUpdateWithoutRoundsInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type PlantUpsertWithoutRoundInput = {
    update: XOR<PlantUpdateWithoutRoundInput, PlantUncheckedUpdateWithoutRoundInput>
    create: XOR<PlantCreateWithoutRoundInput, PlantUncheckedCreateWithoutRoundInput>
    where?: PlantWhereInput
  }

  export type PlantUpdateToOneWithWhereWithoutRoundInput = {
    where?: PlantWhereInput
    data: XOR<PlantUpdateWithoutRoundInput, PlantUncheckedUpdateWithoutRoundInput>
  }

  export type PlantUpdateWithoutRoundInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    player?: PlayerUpdateOneRequiredWithoutPlantsNestedInput
  }

  export type PlantUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefuseUpsertWithoutRoundInput = {
    update: XOR<DefuseUpdateWithoutRoundInput, DefuseUncheckedUpdateWithoutRoundInput>
    create: XOR<DefuseCreateWithoutRoundInput, DefuseUncheckedCreateWithoutRoundInput>
    where?: DefuseWhereInput
  }

  export type DefuseUpdateToOneWithWhereWithoutRoundInput = {
    where?: DefuseWhereInput
    data: XOR<DefuseUpdateWithoutRoundInput, DefuseUncheckedUpdateWithoutRoundInput>
  }

  export type DefuseUpdateWithoutRoundInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    player?: PlayerUpdateOneRequiredWithoutDefusesNestedInput
  }

  export type DefuseUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RoundPlayerStatsUpsertWithWhereUniqueWithoutRoundInput = {
    where: RoundPlayerStatsWhereUniqueInput
    update: XOR<RoundPlayerStatsUpdateWithoutRoundInput, RoundPlayerStatsUncheckedUpdateWithoutRoundInput>
    create: XOR<RoundPlayerStatsCreateWithoutRoundInput, RoundPlayerStatsUncheckedCreateWithoutRoundInput>
  }

  export type RoundPlayerStatsUpdateWithWhereUniqueWithoutRoundInput = {
    where: RoundPlayerStatsWhereUniqueInput
    data: XOR<RoundPlayerStatsUpdateWithoutRoundInput, RoundPlayerStatsUncheckedUpdateWithoutRoundInput>
  }

  export type RoundPlayerStatsUpdateManyWithWhereWithoutRoundInput = {
    where: RoundPlayerStatsScalarWhereInput
    data: XOR<RoundPlayerStatsUpdateManyMutationInput, RoundPlayerStatsUncheckedUpdateManyWithoutRoundInput>
  }

  export type RoundTeamStatsUpsertWithWhereUniqueWithoutRoundInput = {
    where: RoundTeamStatsWhereUniqueInput
    update: XOR<RoundTeamStatsUpdateWithoutRoundInput, RoundTeamStatsUncheckedUpdateWithoutRoundInput>
    create: XOR<RoundTeamStatsCreateWithoutRoundInput, RoundTeamStatsUncheckedCreateWithoutRoundInput>
  }

  export type RoundTeamStatsUpdateWithWhereUniqueWithoutRoundInput = {
    where: RoundTeamStatsWhereUniqueInput
    data: XOR<RoundTeamStatsUpdateWithoutRoundInput, RoundTeamStatsUncheckedUpdateWithoutRoundInput>
  }

  export type RoundTeamStatsUpdateManyWithWhereWithoutRoundInput = {
    where: RoundTeamStatsScalarWhereInput
    data: XOR<RoundTeamStatsUpdateManyMutationInput, RoundTeamStatsUncheckedUpdateManyWithoutRoundInput>
  }

  export type RoundCreateWithoutPlantInput = {
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutRoundsInput
    defuse?: DefuseCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutPlantInput = {
    id?: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    defuse?: DefuseUncheckedCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutPlantInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutPlantInput, RoundUncheckedCreateWithoutPlantInput>
  }

  export type PlayerCreateWithoutPlantsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPlantsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPlantsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlantsInput, PlayerUncheckedCreateWithoutPlantsInput>
  }

  export type RoundUpsertWithoutPlantInput = {
    update: XOR<RoundUpdateWithoutPlantInput, RoundUncheckedUpdateWithoutPlantInput>
    create: XOR<RoundCreateWithoutPlantInput, RoundUncheckedCreateWithoutPlantInput>
    where?: RoundWhereInput
  }

  export type RoundUpdateToOneWithWhereWithoutPlantInput = {
    where?: RoundWhereInput
    data: XOR<RoundUpdateWithoutPlantInput, RoundUncheckedUpdateWithoutPlantInput>
  }

  export type RoundUpdateWithoutPlantInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutRoundsNestedInput
    defuse?: DefuseUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defuse?: DefuseUncheckedUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUncheckedUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type PlayerUpsertWithoutPlantsInput = {
    update: XOR<PlayerUpdateWithoutPlantsInput, PlayerUncheckedUpdateWithoutPlantsInput>
    create: XOR<PlayerCreateWithoutPlantsInput, PlayerUncheckedCreateWithoutPlantsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPlantsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPlantsInput, PlayerUncheckedUpdateWithoutPlantsInput>
  }

  export type PlayerUpdateWithoutPlantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type RoundCreateWithoutDefuseInput = {
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutRoundsInput
    plant?: PlantCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutDefuseInput = {
    id?: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plant?: PlantUncheckedCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutRoundInput
    teamStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutDefuseInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutDefuseInput, RoundUncheckedCreateWithoutDefuseInput>
  }

  export type PlayerCreateWithoutDefusesInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutDefusesInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutDefusesInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutDefusesInput, PlayerUncheckedCreateWithoutDefusesInput>
  }

  export type RoundUpsertWithoutDefuseInput = {
    update: XOR<RoundUpdateWithoutDefuseInput, RoundUncheckedUpdateWithoutDefuseInput>
    create: XOR<RoundCreateWithoutDefuseInput, RoundUncheckedCreateWithoutDefuseInput>
    where?: RoundWhereInput
  }

  export type RoundUpdateToOneWithWhereWithoutDefuseInput = {
    where?: RoundWhereInput
    data: XOR<RoundUpdateWithoutDefuseInput, RoundUncheckedUpdateWithoutDefuseInput>
  }

  export type RoundUpdateWithoutDefuseInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutRoundsNestedInput
    plant?: PlantUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutDefuseInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantUncheckedUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUncheckedUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type PlayerUpsertWithoutDefusesInput = {
    update: XOR<PlayerUpdateWithoutDefusesInput, PlayerUncheckedUpdateWithoutDefusesInput>
    create: XOR<PlayerCreateWithoutDefusesInput, PlayerUncheckedCreateWithoutDefusesInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutDefusesInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutDefusesInput, PlayerUncheckedUpdateWithoutDefusesInput>
  }

  export type PlayerUpdateWithoutDefusesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutDefusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type RoundCreateWithoutPlayerStatsInput = {
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutRoundsInput
    plant?: PlantCreateNestedOneWithoutRoundInput
    defuse?: DefuseCreateNestedOneWithoutRoundInput
    teamStats?: RoundTeamStatsCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutPlayerStatsInput = {
    id?: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plant?: PlantUncheckedCreateNestedOneWithoutRoundInput
    defuse?: DefuseUncheckedCreateNestedOneWithoutRoundInput
    teamStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutPlayerStatsInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutPlayerStatsInput, RoundUncheckedCreateWithoutPlayerStatsInput>
  }

  export type MatchParticipationCreateWithoutRoundStatsInput = {
    teamSide: string
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutParticipationsInput
    player: PlayerCreateNestedOneWithoutMatchParticipationsInput
    team: TeamCreateNestedOneWithoutMatchParticipationsInput
    agent?: AgentCreateNestedOneWithoutMatchParticipationsInput
    matchStats?: MatchPlayerStatsCreateNestedOneWithoutMatchParticipationInput
  }

  export type MatchParticipationUncheckedCreateWithoutRoundStatsInput = {
    id?: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
    matchStats?: MatchPlayerStatsUncheckedCreateNestedOneWithoutMatchParticipationInput
  }

  export type MatchParticipationCreateOrConnectWithoutRoundStatsInput = {
    where: MatchParticipationWhereUniqueInput
    create: XOR<MatchParticipationCreateWithoutRoundStatsInput, MatchParticipationUncheckedCreateWithoutRoundStatsInput>
  }

  export type PlayerCreateWithoutRoundStatsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutRoundStatsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutRoundStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutRoundStatsInput, PlayerUncheckedCreateWithoutRoundStatsInput>
  }

  export type RoundUpsertWithoutPlayerStatsInput = {
    update: XOR<RoundUpdateWithoutPlayerStatsInput, RoundUncheckedUpdateWithoutPlayerStatsInput>
    create: XOR<RoundCreateWithoutPlayerStatsInput, RoundUncheckedCreateWithoutPlayerStatsInput>
    where?: RoundWhereInput
  }

  export type RoundUpdateToOneWithWhereWithoutPlayerStatsInput = {
    where?: RoundWhereInput
    data: XOR<RoundUpdateWithoutPlayerStatsInput, RoundUncheckedUpdateWithoutPlayerStatsInput>
  }

  export type RoundUpdateWithoutPlayerStatsInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutRoundsNestedInput
    plant?: PlantUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUpdateOneWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutPlayerStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantUncheckedUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUncheckedUpdateOneWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type MatchParticipationUpsertWithoutRoundStatsInput = {
    update: XOR<MatchParticipationUpdateWithoutRoundStatsInput, MatchParticipationUncheckedUpdateWithoutRoundStatsInput>
    create: XOR<MatchParticipationCreateWithoutRoundStatsInput, MatchParticipationUncheckedCreateWithoutRoundStatsInput>
    where?: MatchParticipationWhereInput
  }

  export type MatchParticipationUpdateToOneWithWhereWithoutRoundStatsInput = {
    where?: MatchParticipationWhereInput
    data: XOR<MatchParticipationUpdateWithoutRoundStatsInput, MatchParticipationUncheckedUpdateWithoutRoundStatsInput>
  }

  export type MatchParticipationUpdateWithoutRoundStatsInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutParticipationsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput
    agent?: AgentUpdateOneWithoutMatchParticipationsNestedInput
    matchStats?: MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateWithoutRoundStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchStats?: MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput
  }

  export type PlayerUpsertWithoutRoundStatsInput = {
    update: XOR<PlayerUpdateWithoutRoundStatsInput, PlayerUncheckedUpdateWithoutRoundStatsInput>
    create: XOR<PlayerCreateWithoutRoundStatsInput, PlayerUncheckedCreateWithoutRoundStatsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutRoundStatsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutRoundStatsInput, PlayerUncheckedUpdateWithoutRoundStatsInput>
  }

  export type PlayerUpdateWithoutRoundStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutRoundStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type RoundCreateWithoutTeamStatsInput = {
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutRoundsInput
    plant?: PlantCreateNestedOneWithoutRoundInput
    defuse?: DefuseCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutTeamStatsInput = {
    id?: number
    matchId: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plant?: PlantUncheckedCreateNestedOneWithoutRoundInput
    defuse?: DefuseUncheckedCreateNestedOneWithoutRoundInput
    playerStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutTeamStatsInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutTeamStatsInput, RoundUncheckedCreateWithoutTeamStatsInput>
  }

  export type TeamCreateWithoutRoundStatsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutRoundStatsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutRoundStatsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRoundStatsInput, TeamUncheckedCreateWithoutRoundStatsInput>
  }

  export type RoundUpsertWithoutTeamStatsInput = {
    update: XOR<RoundUpdateWithoutTeamStatsInput, RoundUncheckedUpdateWithoutTeamStatsInput>
    create: XOR<RoundCreateWithoutTeamStatsInput, RoundUncheckedCreateWithoutTeamStatsInput>
    where?: RoundWhereInput
  }

  export type RoundUpdateToOneWithWhereWithoutTeamStatsInput = {
    where?: RoundWhereInput
    data: XOR<RoundUpdateWithoutTeamStatsInput, RoundUncheckedUpdateWithoutTeamStatsInput>
  }

  export type RoundUpdateWithoutTeamStatsInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutRoundsNestedInput
    plant?: PlantUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutTeamStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantUncheckedUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUncheckedUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type TeamUpsertWithoutRoundStatsInput = {
    update: XOR<TeamUpdateWithoutRoundStatsInput, TeamUncheckedUpdateWithoutRoundStatsInput>
    create: XOR<TeamCreateWithoutRoundStatsInput, TeamUncheckedCreateWithoutRoundStatsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRoundStatsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRoundStatsInput, TeamUncheckedUpdateWithoutRoundStatsInput>
  }

  export type TeamUpdateWithoutRoundStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRoundStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type MatchCreateWithoutKillsInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutKillsInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutKillsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutKillsInput, MatchUncheckedCreateWithoutKillsInput>
  }

  export type PlayerCreateWithoutKillsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutKillsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutKillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutKillsInput, PlayerUncheckedCreateWithoutKillsInput>
  }

  export type PlayerCreateWithoutDeathsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutDeathsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutDeathsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutDeathsInput, PlayerUncheckedCreateWithoutDeathsInput>
  }

  export type PlayerCreateWithoutKillAssistsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutKillAssistsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutKillAssistsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutKillAssistsInput, PlayerUncheckedCreateWithoutKillAssistsInput>
  }

  export type MatchUpsertWithoutKillsInput = {
    update: XOR<MatchUpdateWithoutKillsInput, MatchUncheckedUpdateWithoutKillsInput>
    create: XOR<MatchCreateWithoutKillsInput, MatchUncheckedCreateWithoutKillsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutKillsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutKillsInput, MatchUncheckedUpdateWithoutKillsInput>
  }

  export type MatchUpdateWithoutKillsInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutKillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type PlayerUpsertWithoutKillsInput = {
    update: XOR<PlayerUpdateWithoutKillsInput, PlayerUncheckedUpdateWithoutKillsInput>
    create: XOR<PlayerCreateWithoutKillsInput, PlayerUncheckedCreateWithoutKillsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutKillsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutKillsInput, PlayerUncheckedUpdateWithoutKillsInput>
  }

  export type PlayerUpdateWithoutKillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutKillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUpsertWithoutDeathsInput = {
    update: XOR<PlayerUpdateWithoutDeathsInput, PlayerUncheckedUpdateWithoutDeathsInput>
    create: XOR<PlayerCreateWithoutDeathsInput, PlayerUncheckedCreateWithoutDeathsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutDeathsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutDeathsInput, PlayerUncheckedUpdateWithoutDeathsInput>
  }

  export type PlayerUpdateWithoutDeathsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutDeathsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUpsertWithWhereUniqueWithoutKillAssistsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutKillAssistsInput, PlayerUncheckedUpdateWithoutKillAssistsInput>
    create: XOR<PlayerCreateWithoutKillAssistsInput, PlayerUncheckedCreateWithoutKillAssistsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutKillAssistsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutKillAssistsInput, PlayerUncheckedUpdateWithoutKillAssistsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutKillAssistsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutKillAssistsInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: IntFilter<"Player"> | number
    name?: StringFilter<"Player"> | string
    tag?: StringFilter<"Player"> | string
    puuid?: StringFilter<"Player"> | string
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
  }

  export type TeamCreateWithoutRostersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutRostersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    substitutions?: SubstitutionUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutRostersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRostersInput, TeamUncheckedCreateWithoutRostersInput>
  }

  export type PlayerCreateWithoutRostersInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutRostersInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutRostersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutRostersInput, PlayerUncheckedCreateWithoutRostersInput>
  }

  export type SeasonCreateWithoutTeamRostersInput = {
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutSeasonsInput
    series?: SeriesCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutTeamRostersInput = {
    id?: number
    leagueId: number
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutTeamRostersInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutTeamRostersInput, SeasonUncheckedCreateWithoutTeamRostersInput>
  }

  export type TeamUpsertWithoutRostersInput = {
    update: XOR<TeamUpdateWithoutRostersInput, TeamUncheckedUpdateWithoutRostersInput>
    create: XOR<TeamCreateWithoutRostersInput, TeamUncheckedCreateWithoutRostersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRostersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRostersInput, TeamUncheckedUpdateWithoutRostersInput>
  }

  export type TeamUpdateWithoutRostersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRostersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type PlayerUpsertWithoutRostersInput = {
    update: XOR<PlayerUpdateWithoutRostersInput, PlayerUncheckedUpdateWithoutRostersInput>
    create: XOR<PlayerCreateWithoutRostersInput, PlayerUncheckedCreateWithoutRostersInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutRostersInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutRostersInput, PlayerUncheckedUpdateWithoutRostersInput>
  }

  export type PlayerUpdateWithoutRostersInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutRostersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SeasonUpsertWithoutTeamRostersInput = {
    update: XOR<SeasonUpdateWithoutTeamRostersInput, SeasonUncheckedUpdateWithoutTeamRostersInput>
    create: XOR<SeasonCreateWithoutTeamRostersInput, SeasonUncheckedCreateWithoutTeamRostersInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutTeamRostersInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutTeamRostersInput, SeasonUncheckedUpdateWithoutTeamRostersInput>
  }

  export type SeasonUpdateWithoutTeamRostersInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutSeasonsNestedInput
    series?: SeriesUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutTeamRostersInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type MatchCreateWithoutSubstitutionsInput = {
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutMatchesInput
    map: MapCreateNestedOneWithoutMatchesInput
    rounds?: RoundCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsCreateNestedManyWithoutMatchInput
    kills?: KillCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutSubstitutionsInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: RoundUncheckedCreateNestedManyWithoutMatchInput
    matchPlayerStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutMatchInput
    matchTeamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutMatchInput
    kills?: KillUncheckedCreateNestedManyWithoutMatchInput
    participations?: MatchParticipationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutSubstitutionsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutSubstitutionsInput, MatchUncheckedCreateWithoutSubstitutionsInput>
  }

  export type TeamCreateWithoutSubstitutionsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutTeamInput
    redSeries?: SeriesCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSubstitutionsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutTeamInput
    redSeries?: SeriesUncheckedCreateNestedManyWithoutRedTeamInput
    blueSeries?: SeriesUncheckedCreateNestedManyWithoutBlueTeamInput
    teamStats?: MatchTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    roundStats?: RoundTeamStatsUncheckedCreateNestedManyWithoutTeamInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSubstitutionsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSubstitutionsInput, TeamUncheckedCreateWithoutSubstitutionsInput>
  }

  export type PlayerCreateWithoutSubInsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subOuts?: SubstitutionCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSubInsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subOuts?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedOutInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSubInsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSubInsInput, PlayerUncheckedCreateWithoutSubInsInput>
  }

  export type PlayerCreateWithoutSubOutsInput = {
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionCreateNestedManyWithoutSubstitutedInInput
    plants?: PlantCreateNestedManyWithoutPlayerInput
    defuses?: DefuseCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsCreateNestedManyWithoutPlayerInput
    kills?: KillCreateNestedManyWithoutKillerInput
    deaths?: KillCreateNestedManyWithoutVictimInput
    killAssists?: KillCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSubOutsInput = {
    id?: number
    name: string
    tag: string
    puuid: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rosters?: TeamRosterUncheckedCreateNestedManyWithoutPlayerInput
    subIns?: SubstitutionUncheckedCreateNestedManyWithoutSubstitutedInInput
    plants?: PlantUncheckedCreateNestedManyWithoutPlayerInput
    defuses?: DefuseUncheckedCreateNestedManyWithoutPlayerInput
    roundStats?: RoundPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    matchStats?: MatchPlayerStatsUncheckedCreateNestedManyWithoutPlayerInput
    kills?: KillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: KillUncheckedCreateNestedManyWithoutVictimInput
    killAssists?: KillUncheckedCreateNestedManyWithoutAssistantsInput
    matchParticipations?: MatchParticipationUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSubOutsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSubOutsInput, PlayerUncheckedCreateWithoutSubOutsInput>
  }

  export type MatchUpsertWithoutSubstitutionsInput = {
    update: XOR<MatchUpdateWithoutSubstitutionsInput, MatchUncheckedUpdateWithoutSubstitutionsInput>
    create: XOR<MatchCreateWithoutSubstitutionsInput, MatchUncheckedCreateWithoutSubstitutionsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutSubstitutionsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutSubstitutionsInput, MatchUncheckedUpdateWithoutSubstitutionsInput>
  }

  export type MatchUpdateWithoutSubstitutionsInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutSubstitutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type TeamUpsertWithoutSubstitutionsInput = {
    update: XOR<TeamUpdateWithoutSubstitutionsInput, TeamUncheckedUpdateWithoutSubstitutionsInput>
    create: XOR<TeamCreateWithoutSubstitutionsInput, TeamUncheckedCreateWithoutSubstitutionsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSubstitutionsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSubstitutionsInput, TeamUncheckedUpdateWithoutSubstitutionsInput>
  }

  export type TeamUpdateWithoutSubstitutionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSubstitutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutTeamNestedInput
    redSeries?: SeriesUncheckedUpdateManyWithoutRedTeamNestedInput
    blueSeries?: SeriesUncheckedUpdateManyWithoutBlueTeamNestedInput
    teamStats?: MatchTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    roundStats?: RoundTeamStatsUncheckedUpdateManyWithoutTeamNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type PlayerUpsertWithoutSubInsInput = {
    update: XOR<PlayerUpdateWithoutSubInsInput, PlayerUncheckedUpdateWithoutSubInsInput>
    create: XOR<PlayerCreateWithoutSubInsInput, PlayerUncheckedCreateWithoutSubInsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSubInsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSubInsInput, PlayerUncheckedUpdateWithoutSubInsInput>
  }

  export type PlayerUpdateWithoutSubInsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSubInsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUpsertWithoutSubOutsInput = {
    update: XOR<PlayerUpdateWithoutSubOutsInput, PlayerUncheckedUpdateWithoutSubOutsInput>
    create: XOR<PlayerCreateWithoutSubOutsInput, PlayerUncheckedCreateWithoutSubOutsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSubOutsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSubOutsInput, PlayerUncheckedUpdateWithoutSubOutsInput>
  }

  export type PlayerUpdateWithoutSubOutsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    killAssists?: KillUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSubOutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    killAssists?: KillUncheckedUpdateManyWithoutAssistantsNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type MatchParticipationCreateManyAgentInput = {
    id?: number
    matchId: number
    playerId: number
    teamId: number
    teamSide: string
    createdAt?: Date | string
  }

  export type MatchPlayerStatsCreateManyAgentInput = {
    id?: number
    matchParticipationId: number
    matchId: number
    playerId: number
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchParticipationUpdateWithoutAgentInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutParticipationsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput
    matchStats?: MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchStats?: MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUpdateWithoutAgentInput = {
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutMatchStatsNestedInput
    match?: MatchUpdateOneRequiredWithoutMatchPlayerStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchStatsNestedInput
  }

  export type MatchPlayerStatsUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManyMapInput = {
    id?: number
    seriesId: number
    matchNumber: number
    riotMatchId?: string | null
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateWithoutMapInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    seriesId?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateManyLeagueInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonUpdateWithoutLeagueInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateManyWithoutSeasonNestedInput
    teamRosters?: TeamRosterUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutSeasonNestedInput
    teamRosters?: TeamRosterUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateManyWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesCreateManySeasonInput = {
    id?: number
    redTeamId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamRosterCreateManySeasonInput = {
    id?: number
    teamId: number
    playerId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesUpdateWithoutSeasonInput = {
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redTeam?: TeamUpdateOneRequiredWithoutRedSeriesNestedInput
    blueTeam?: TeamUpdateOneRequiredWithoutBlueSeriesNestedInput
    matches?: MatchUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterUpdateWithoutSeasonInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutRostersNestedInput
    player?: PlayerUpdateOneRequiredWithoutRostersNestedInput
  }

  export type TeamRosterUncheckedUpdateWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterUncheckedUpdateManyWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterCreateManyTeamInput = {
    id?: number
    playerId: number
    seasonId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesCreateManyRedTeamInput = {
    id?: number
    seasonId: number
    blueTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesCreateManyBlueTeamInput = {
    id?: number
    seasonId: number
    redTeamId: number
    bestOf: number
    winnerTeamId?: number | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchTeamStatsCreateManyTeamInput = {
    id?: number
    matchId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubstitutionCreateManyTeamInput = {
    id?: number
    matchId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type RoundTeamStatsCreateManyTeamInput = {
    id?: number
    roundId: number
    teamSide: string
    won: boolean
  }

  export type MatchParticipationCreateManyTeamInput = {
    id?: number
    matchId: number
    playerId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
  }

  export type TeamRosterUpdateWithoutTeamInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutRostersNestedInput
    season?: SeasonUpdateOneRequiredWithoutTeamRostersNestedInput
  }

  export type TeamRosterUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUpdateWithoutRedTeamInput = {
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneRequiredWithoutSeriesNestedInput
    blueTeam?: TeamUpdateOneRequiredWithoutBlueSeriesNestedInput
    matches?: MatchUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutRedTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutRedTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    blueTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUpdateWithoutBlueTeamInput = {
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneRequiredWithoutSeriesNestedInput
    redTeam?: TeamUpdateOneRequiredWithoutRedSeriesNestedInput
    matches?: MatchUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutBlueTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutBlueTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    redTeamId?: IntFieldUpdateOperationsInput | number
    bestOf?: IntFieldUpdateOperationsInput | number
    winnerTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsUpdateWithoutTeamInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutMatchTeamStatsNestedInput
  }

  export type MatchTeamStatsUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUpdateWithoutTeamInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutSubstitutionsNestedInput
    substitutedIn?: PlayerUpdateOneRequiredWithoutSubInsNestedInput
    substitutedOut?: PlayerUpdateOneRequiredWithoutSubOutsNestedInput
  }

  export type SubstitutionUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundTeamStatsUpdateWithoutTeamInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
    round?: RoundUpdateOneRequiredWithoutTeamStatsNestedInput
  }

  export type RoundTeamStatsUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoundTeamStatsUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchParticipationUpdateWithoutTeamInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutParticipationsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput
    agent?: AgentUpdateOneWithoutMatchParticipationsNestedInput
    matchStats?: MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchStats?: MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterCreateManyPlayerInput = {
    id?: number
    teamId: number
    seasonId: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubstitutionCreateManySubstitutedInInput = {
    id?: number
    matchId: number
    teamId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type SubstitutionCreateManySubstitutedOutInput = {
    id?: number
    matchId: number
    teamId: number
    substitutedInId: number
    timestamp?: Date | string
  }

  export type PlantCreateManyPlayerInput = {
    id?: number
    roundId: number
    roundTimeMs: number
    site: string
    locationX?: number | null
    locationY?: number | null
  }

  export type DefuseCreateManyPlayerInput = {
    id?: number
    roundId: number
    roundTimeMs: number
    locationX?: number | null
    locationY?: number | null
  }

  export type RoundPlayerStatsCreateManyPlayerInput = {
    id?: number
    roundId: number
    matchParticipationId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type MatchPlayerStatsCreateManyPlayerInput = {
    id?: number
    matchParticipationId: number
    matchId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KillCreateManyKillerInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
  }

  export type KillCreateManyVictimInput = {
    id?: number
    matchId: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
  }

  export type MatchParticipationCreateManyPlayerInput = {
    id?: number
    matchId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
  }

  export type TeamRosterUpdateWithoutPlayerInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutRostersNestedInput
    season?: SeasonUpdateOneRequiredWithoutTeamRostersNestedInput
  }

  export type TeamRosterUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamRosterUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUpdateWithoutSubstitutedInInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutSubstitutionsNestedInput
    team?: TeamUpdateOneRequiredWithoutSubstitutionsNestedInput
    substitutedOut?: PlayerUpdateOneRequiredWithoutSubOutsNestedInput
  }

  export type SubstitutionUncheckedUpdateWithoutSubstitutedInInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUncheckedUpdateManyWithoutSubstitutedInInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUpdateWithoutSubstitutedOutInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutSubstitutionsNestedInput
    team?: TeamUpdateOneRequiredWithoutSubstitutionsNestedInput
    substitutedIn?: PlayerUpdateOneRequiredWithoutSubInsNestedInput
  }

  export type SubstitutionUncheckedUpdateWithoutSubstitutedOutInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUncheckedUpdateManyWithoutSubstitutedOutInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantUpdateWithoutPlayerInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    round?: RoundUpdateOneRequiredWithoutPlantNestedInput
  }

  export type PlantUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PlantUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    site?: StringFieldUpdateOperationsInput | string
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefuseUpdateWithoutPlayerInput = {
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    round?: RoundUpdateOneRequiredWithoutDefuseNestedInput
  }

  export type DefuseUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DefuseUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roundTimeMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RoundPlayerStatsUpdateWithoutPlayerInput = {
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: RoundUpdateOneRequiredWithoutPlayerStatsNestedInput
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutRoundStatsNestedInput
  }

  export type RoundPlayerStatsUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUpdateWithoutPlayerInput = {
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutMatchStatsNestedInput
    match?: MatchUpdateOneRequiredWithoutMatchPlayerStatsNestedInput
    Agent?: AgentUpdateOneWithoutMatchPlayerStatsNestedInput
  }

  export type MatchPlayerStatsUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KillUpdateWithoutKillerInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutKillsNestedInput
    victim?: PlayerUpdateOneRequiredWithoutDeathsNestedInput
    assistants?: PlayerUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateWithoutKillerInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: PlayerUncheckedUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateManyWithoutKillerInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KillUpdateWithoutVictimInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutKillsNestedInput
    killer?: PlayerUpdateOneRequiredWithoutKillsNestedInput
    assistants?: PlayerUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateWithoutVictimInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: PlayerUncheckedUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateManyWithoutVictimInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KillUpdateWithoutAssistantsInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutKillsNestedInput
    killer?: PlayerUpdateOneRequiredWithoutKillsNestedInput
    victim?: PlayerUpdateOneRequiredWithoutDeathsNestedInput
  }

  export type KillUncheckedUpdateWithoutAssistantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KillUncheckedUpdateManyWithoutAssistantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchParticipationUpdateWithoutPlayerInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutParticipationsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput
    agent?: AgentUpdateOneWithoutMatchParticipationsNestedInput
    matchStats?: MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchStats?: MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManySeriesInput = {
    id?: number
    matchNumber: number
    riotMatchId?: string | null
    mapId: string
    gameLengthMs?: number | null
    startedAt: Date | string
    completedAt?: Date | string | null
    isCompleted?: boolean
    status?: string
    winnerTeamSide?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateWithoutSeriesInput = {
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapUpdateOneRequiredWithoutMatchesNestedInput
    rounds?: RoundUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUpdateManyWithoutMatchNestedInput
    kills?: KillUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: RoundUncheckedUpdateManyWithoutMatchNestedInput
    matchPlayerStats?: MatchPlayerStatsUncheckedUpdateManyWithoutMatchNestedInput
    matchTeamStats?: MatchTeamStatsUncheckedUpdateManyWithoutMatchNestedInput
    substitutions?: SubstitutionUncheckedUpdateManyWithoutMatchNestedInput
    kills?: KillUncheckedUpdateManyWithoutMatchNestedInput
    participations?: MatchParticipationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    riotMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    mapId?: StringFieldUpdateOperationsInput | string
    gameLengthMs?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    winnerTeamSide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundCreateManyMatchInput = {
    id?: number
    roundNumber: number
    result: string
    winningTeam: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchPlayerStatsCreateManyMatchInput = {
    id?: number
    matchParticipationId: number
    playerId: number
    agentId?: string | null
    agentName?: string | null
    score: number
    kills: number
    deaths: number
    assists: number
    headshots: number
    bodyshots: number
    legshots: number
    damageDealt: number
    damageReceived: number
    adr?: number | null
    acs?: number | null
    kd?: number | null
    hsPercent?: number | null
    kast?: number | null
    firstKills?: number | null
    firstDeaths?: number | null
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    spentOverall?: number | null
    spentAverage?: number | null
    loadoutOverall?: number | null
    loadoutAverage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchTeamStatsCreateManyMatchInput = {
    id?: number
    teamId: number
    teamSide: string
    roundsWon: number
    roundsLost: number
    won: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubstitutionCreateManyMatchInput = {
    id?: number
    teamId: number
    substitutedInId: number
    substitutedOutId: number
    timestamp?: Date | string
  }

  export type KillCreateManyMatchInput = {
    id?: number
    roundNumber: number
    timeInRoundMs: number
    timeInMatchMs: number
    killerId: number
    victimId: number
    locationX?: number | null
    locationY?: number | null
    weaponId?: string | null
    weaponName?: string | null
    weaponType?: string | null
    secondaryFireMode?: boolean
    createdAt?: Date | string
  }

  export type MatchParticipationCreateManyMatchInput = {
    id?: number
    playerId: number
    teamId: number
    teamSide: string
    agentId?: string | null
    createdAt?: Date | string
  }

  export type RoundUpdateWithoutMatchInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantUncheckedUpdateOneWithoutRoundNestedInput
    defuse?: DefuseUncheckedUpdateOneWithoutRoundNestedInput
    playerStats?: RoundPlayerStatsUncheckedUpdateManyWithoutRoundNestedInput
    teamStats?: RoundTeamStatsUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateManyWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
    winningTeam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUpdateWithoutMatchInput = {
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutMatchStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchStatsNestedInput
    Agent?: AgentUpdateOneWithoutMatchPlayerStatsNestedInput
  }

  export type MatchPlayerStatsUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchPlayerStatsUncheckedUpdateManyWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    deaths?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    adr?: NullableFloatFieldUpdateOperationsInput | number | null
    acs?: NullableFloatFieldUpdateOperationsInput | number | null
    kd?: NullableFloatFieldUpdateOperationsInput | number | null
    hsPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    kast?: NullableFloatFieldUpdateOperationsInput | number | null
    firstKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstDeaths?: NullableIntFieldUpdateOperationsInput | number | null
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    spentOverall?: NullableIntFieldUpdateOperationsInput | number | null
    spentAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    loadoutOverall?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsUpdateWithoutMatchInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
  }

  export type MatchTeamStatsUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchTeamStatsUncheckedUpdateManyWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    roundsWon?: IntFieldUpdateOperationsInput | number
    roundsLost?: IntFieldUpdateOperationsInput | number
    won?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUpdateWithoutMatchInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutSubstitutionsNestedInput
    substitutedIn?: PlayerUpdateOneRequiredWithoutSubInsNestedInput
    substitutedOut?: PlayerUpdateOneRequiredWithoutSubOutsNestedInput
  }

  export type SubstitutionUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubstitutionUncheckedUpdateManyWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    substitutedInId?: IntFieldUpdateOperationsInput | number
    substitutedOutId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KillUpdateWithoutMatchInput = {
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    killer?: PlayerUpdateOneRequiredWithoutKillsNestedInput
    victim?: PlayerUpdateOneRequiredWithoutDeathsNestedInput
    assistants?: PlayerUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: PlayerUncheckedUpdateManyWithoutKillAssistsNestedInput
  }

  export type KillUncheckedUpdateManyWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundNumber?: IntFieldUpdateOperationsInput | number
    timeInRoundMs?: IntFieldUpdateOperationsInput | number
    timeInMatchMs?: IntFieldUpdateOperationsInput | number
    killerId?: IntFieldUpdateOperationsInput | number
    victimId?: IntFieldUpdateOperationsInput | number
    locationX?: NullableFloatFieldUpdateOperationsInput | number | null
    locationY?: NullableFloatFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryFireMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchParticipationUpdateWithoutMatchInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMatchParticipationsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchParticipationsNestedInput
    agent?: AgentUpdateOneWithoutMatchParticipationsNestedInput
    matchStats?: MatchPlayerStatsUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchStats?: MatchPlayerStatsUncheckedUpdateOneWithoutMatchParticipationNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationNestedInput
  }

  export type MatchParticipationUncheckedUpdateManyWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsCreateManyMatchParticipationInput = {
    id?: number
    roundId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundPlayerStatsUpdateWithoutMatchParticipationInput = {
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: RoundUpdateOneRequiredWithoutPlayerStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutRoundStatsNestedInput
  }

  export type RoundPlayerStatsUncheckedUpdateWithoutMatchParticipationInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsUncheckedUpdateManyWithoutMatchParticipationInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsCreateManyRoundInput = {
    id?: number
    matchParticipationId: number
    playerId: number
    score: number
    kills: number
    headshots: number
    bodyshots: number
    legshots: number
    grenadeCasts?: number | null
    ability1Casts?: number | null
    ability2Casts?: number | null
    ultimateCasts?: number | null
    loadoutValue?: number | null
    creditsRemaining?: number | null
    weaponId?: string | null
    weaponName?: string | null
    armorId?: string | null
    armorName?: string | null
    createdAt?: Date | string
  }

  export type RoundTeamStatsCreateManyRoundInput = {
    id?: number
    teamId: number
    teamSide: string
    won: boolean
  }

  export type RoundPlayerStatsUpdateWithoutRoundInput = {
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchParticipation?: MatchParticipationUpdateOneRequiredWithoutRoundStatsNestedInput
    player?: PlayerUpdateOneRequiredWithoutRoundStatsNestedInput
  }

  export type RoundPlayerStatsUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundPlayerStatsUncheckedUpdateManyWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    matchParticipationId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    headshots?: IntFieldUpdateOperationsInput | number
    bodyshots?: IntFieldUpdateOperationsInput | number
    legshots?: IntFieldUpdateOperationsInput | number
    grenadeCasts?: NullableIntFieldUpdateOperationsInput | number | null
    ability1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ability2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    ultimateCasts?: NullableIntFieldUpdateOperationsInput | number | null
    loadoutValue?: NullableIntFieldUpdateOperationsInput | number | null
    creditsRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponName?: NullableStringFieldUpdateOperationsInput | string | null
    armorId?: NullableStringFieldUpdateOperationsInput | string | null
    armorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundTeamStatsUpdateWithoutRoundInput = {
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutRoundStatsNestedInput
  }

  export type RoundTeamStatsUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoundTeamStatsUncheckedUpdateManyWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamSide?: StringFieldUpdateOperationsInput | string
    won?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerUpdateWithoutKillAssistsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUpdateManyWithoutPlayerNestedInput
    kills?: KillUpdateManyWithoutKillerNestedInput
    deaths?: KillUpdateManyWithoutVictimNestedInput
    matchParticipations?: MatchParticipationUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutKillAssistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rosters?: TeamRosterUncheckedUpdateManyWithoutPlayerNestedInput
    subIns?: SubstitutionUncheckedUpdateManyWithoutSubstitutedInNestedInput
    subOuts?: SubstitutionUncheckedUpdateManyWithoutSubstitutedOutNestedInput
    plants?: PlantUncheckedUpdateManyWithoutPlayerNestedInput
    defuses?: DefuseUncheckedUpdateManyWithoutPlayerNestedInput
    roundStats?: RoundPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    matchStats?: MatchPlayerStatsUncheckedUpdateManyWithoutPlayerNestedInput
    kills?: KillUncheckedUpdateManyWithoutKillerNestedInput
    deaths?: KillUncheckedUpdateManyWithoutVictimNestedInput
    matchParticipations?: MatchParticipationUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutKillAssistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}